<!doctype html>
<html lang="fr">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ManhwaReader Pro</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&amp;display=swap" rel="stylesheet">
  <!-- Google Drive API -->
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
        body {
            font-family: 'Poppins', sans-serif;
            box-sizing: border-box;
        }
        
        .dark-mode {
            background-color: #1a1a1a !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode .card {
            background-color: #2d2d2d !important;
            border-color: #404040 !important;
            color: #e2e8f0 !important;
        }
        
        /* Galerie masonry */
        #gallery-grid {
            column-gap: 1rem;
        }
        
        #gallery-grid .break-inside-avoid {
            break-inside: avoid;
            page-break-inside: avoid;
            margin-bottom: 1rem;
        }
        
        @media (min-width: 640px) {
            #gallery-grid {
                columns: 2;
            }
        }
        
        @media (min-width: 768px) {
            #gallery-grid {
                columns: 3;
            }
        }
        
        @media (min-width: 1024px) {
            #gallery-grid {
                columns: 4;
            }
        }
        
        .dark-mode .input-field {
            background-color: #2d2d2d !important;
            border-color: #404040 !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode .nav-item:hover {
            background-color: #404040 !important;
        }
        
        .dark-mode .chapter-item {
            background-color: #2d2d2d !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode .chapter-item:hover {
            background-color: #404040 !important;
        }
        
        .dark-mode .badge {
            background-color: #404040 !important;
            color: #a5b4fc !important;
        }
        
        .dark-mode button:not(.bg-indigo-600) {
            background-color: #2d2d2d !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode h1, .dark-mode h2, .dark-mode h3, .dark-mode h4 {
            color: #e2e8f0 !important;
        }
        
        /* AmÃ©lioration de la visibilitÃ© des textes en mode sombre */
        .dark-mode .text-gray-500 {
            color: #cbd5e1 !important;
        }
        
        .dark-mode .text-gray-600 {
            color: #e2e8f0 !important;
        }
        
        .dark-mode .text-gray-700 {
            color: #f1f5f9 !important;
        }
        
        .dark-mode .text-gray-400 {
            color: #94a3b8 !important;
        }
        
        .dark-mode .text-gray-300 {
            color: #cbd5e1 !important;
        }
        
        /* Panneau de paramÃ¨tres en mode sombre */
        .dark-mode #settings-panel {
            background-color: #2d2d2d !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode #settings-panel h2,
        .dark-mode #settings-panel h3 {
            color: #f1f5f9 !important;
        }
        
        .dark-mode #settings-panel .text-indigo-900 {
            color: #c7d2fe !important;
        }
        
        .dark-mode #settings-panel .text-indigo-600 {
            color: #818cf8 !important;
        }
        
        .dark-mode #settings-panel .bg-indigo-50 {
            background-color: #312e81 !important;
        }
        
        .dark-mode #settings-panel .bg-indigo-100 {
            background-color: #3730a3 !important;
        }
        
        .dark-mode #settings-panel .bg-gray-50 {
            background-color: #374151 !important;
        }
        
        /* Section Suivi en mode sombre */
        .dark-mode #tracking-page .bg-white {
            background-color: #2d2d2d !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode #tracking-page .text-gray-600 {
            color: #cbd5e1 !important;
        }
        
        .dark-mode #tracking-page .bg-gray-50 {
            background-color: #374151 !important;
        }
        
        .dark-mode #tracking-page .bg-gray-100 {
            background-color: #4b5563 !important;
        }
        
        .dark-mode #tracking-page .bg-gray-200 {
            background-color: #6b7280 !important;
        }
        
        .dark-mode #tracking-page .border-t {
            border-color: #404040 !important;
        }
        
        .dark-mode #tracking-page .text-gray-900 {
            color: #f1f5f9 !important;
        }
        
        .dark-mode #tracking-page .text-indigo-600 {
            color: #818cf8 !important;
        }
        
        .dark-mode #tracking-page .text-gray-700 {
            color: #cbd5e1 !important;
        }
        
        .dark-mode #tracking-page .border-gray-200 {
            border-color: #404040 !important;
        }
        
        .dark-mode #tracking-page .bg-gray-100 {
            background-color: #4b5563 !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode #tracking-page .bg-gray-100:hover {
            background-color: #6b7280 !important;
        }
        
        .dark-mode #tracking-page .hover\:bg-blue-50:hover {
            background-color: #1e3a8a !important;
        }
        
        .dark-mode #tracking-page .hover\:bg-red-50:hover {
            background-color: #7f1d1d !important;
        }
        
        /* Modals en mode sombre */
        .dark-mode .fixed.inset-0 > div.bg-white,
        .dark-mode #add-manhwa-modal > div,
        .dark-mode #add-chapter-modal > div,
        .dark-mode #edit-manhwa-modal > div,
        .dark-mode #edit-chapter-modal > div,
        .dark-mode #tracking-modal > div {
            background-color: #2d2d2d !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode .fixed.inset-0 > div.bg-white h2,
        .dark-mode #add-manhwa-modal h2,
        .dark-mode #add-chapter-modal h2,
        .dark-mode #edit-manhwa-modal h2,
        .dark-mode #edit-chapter-modal h2,
        .dark-mode #tracking-modal h2 {
            color: #f1f5f9 !important;
        }
        
        .dark-mode .fixed.inset-0 > div.bg-white label,
        .dark-mode #add-manhwa-modal label,
        .dark-mode #add-chapter-modal label,
        .dark-mode #edit-manhwa-modal label,
        .dark-mode #edit-chapter-modal label,
        .dark-mode #tracking-modal label {
            color: #e2e8f0 !important;
        }
        
        .dark-mode .fixed.inset-0 > div.bg-white .border-b,
        .dark-mode #add-manhwa-modal .border-b,
        .dark-mode #add-chapter-modal .border-b,
        .dark-mode #edit-manhwa-modal .border-b,
        .dark-mode #edit-chapter-modal .border-b,
        .dark-mode #tracking-modal .border-b {
            border-color: #404040 !important;
        }
        
        /* Sidebar en mode sombre */
        .dark-mode #sidebar {
            background-color: #2d2d2d !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode #sidebar .nav-item {
            color: #e2e8f0 !important;
        }
        
        .dark-mode #sidebar h2 {
            color: #f1f5f9 !important;
        }
        
        .card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        
        .manhwa-cover {
            width: 100%;
            height: 300px;
            object-fit: cover;
            border-radius: 12px;
        }
        
        .chapter-item {
            transition: all 0.2s ease;
        }
        
        .chapter-item:hover {
            background-color: rgba(99, 102, 241, 0.1);
            transform: translateX(5px);
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .reading-page img {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            display: block;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .loading-spinner {
            border: 3px solid rgba(99, 102, 241, 0.1);
            border-top: 3px solid #6366f1;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .progress-bar {
            height: 4px;
            background-color: #6366f1;
            transition: width 0.3s ease;
        }
    </style>
  <style>@view-transition { navigation: auto; }</style>
 </head>
 <body class="bg-gray-50 min-h-screen"><!-- Navigation -->
  <nav id="navbar" class="bg-white shadow-md sticky top-0 z-50">
   <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <div class="flex justify-between items-center h-16">
     <div class="flex items-center"><button id="menu-btn" class="mr-4 p-2 rounded-lg hover:bg-gray-100">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
       </svg></button>
      <h1 class="text-2xl font-bold text-indigo-600">ManhwaReader</h1>
     </div>
     <div class="flex items-center space-x-4"><button id="settings-btn" class="p-2 rounded-lg hover:bg-gray-100">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
       </svg></button>
     </div>
    </div>
   </div>
  </nav><!-- Sidebar -->
  <aside id="sidebar" class="fixed top-16 left-0 h-full w-64 bg-white shadow-lg transform -translate-x-full transition-transform duration-300 z-40">
   <div class="p-4">
    <h2 class="text-lg font-semibold mb-4">Navigation</h2>
    <ul class="space-y-2">
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="home">
       <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
       </svg> Accueil </button></li>
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="library">
       <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 14v3m4-3v3m4-3v3M3 21h18M3 10h18M3 7l9-4 9 4M4 10h16v11H4V10z"></path>
       </svg> Ma BibliothÃ¨que </button></li>
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="recent">
       <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
       </svg> RÃ©cents </button></li>
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="favorites">
       <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
       </svg> Favoris </button></li>
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="tracking">
      <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
      </svg> Suivi </button></li>
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="gallery">
      <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
      </svg> Galerie </button></li>
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="trash">
      <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
      </svg> Corbeille </button></li>
    </ul>
   </div>
  </aside><!-- Main Content -->
  <main id="main-content" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><!-- Home Page -->
   <div id="home-page" class="page-content hidden fade-in">
    <h2 class="text-3xl font-bold mb-8">Continuer la lecture</h2>
    <div id="continue-reading" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 mb-12"><!-- Les manhwas en cours seront ajoutÃ©s ici -->
    </div>
    <h2 class="text-3xl font-bold mb-8">Derniers chapitres ajoutÃ©s</h2>
    <div id="latest-chapters" class="space-y-4"><!-- Les derniers chapitres seront ajoutÃ©s ici -->
    </div>
   </div><!-- Library Page -->
   <div id="library-page" class="page-content hidden fade-in">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-3xl font-bold">Ma BibliothÃ¨que</h2>
     <div class="flex items-center space-x-3">
      <input type="text" id="library-search" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field" placeholder="ðŸ” Rechercher...">
      <select id="library-filter" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field">
       <option value="all">Tous</option>
       <option value="az">A-Z</option>
       <option value="za">Z-A</option>
       <option value="recent">RÃ©cent</option>
       <option value="oldest">Plus ancien</option>
      </select>
     </div>
    </div>
    <div id="library-grid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"><!-- Les manhwas seront ajoutÃ©s ici -->
    </div>
   </div><!-- Recent Page -->
   <div id="recent-page" class="page-content hidden fade-in">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-3xl font-bold">Chapitres rÃ©cemment lus</h2>
     <div class="flex items-center space-x-3">
      <input type="text" id="recent-search" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field" placeholder="ðŸ” Rechercher...">
      <select id="recent-filter" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field">
       <option value="recent">Plus rÃ©cent</option>
       <option value="oldest">Plus ancien</option>
       <option value="az">A-Z</option>
       <option value="za">Z-A</option>
      </select>
     </div>
    </div>
    <div id="recent-list" class="space-y-4"><!-- L'historique de lecture sera ajoutÃ© ici -->
    </div>
   </div><!-- Favorites Page -->
   <div id="favorites-page" class="page-content hidden fade-in">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-3xl font-bold">Favoris</h2>
     <div class="flex items-center space-x-3">
      <input type="text" id="favorites-search" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field" placeholder="ðŸ” Rechercher...">
      <select id="favorites-filter" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field">
       <option value="recent">Plus rÃ©cent</option>
       <option value="oldest">Plus ancien</option>
       <option value="az">A-Z</option>
       <option value="za">Z-A</option>
      </select>
     </div>
    </div>
    <div id="favorites-list" class="space-y-4"><!-- Les chapitres favoris seront ajoutÃ©s ici -->
    </div>
   </div><!-- Trash Page -->
   <div id="gallery-page" class="page-content hidden fade-in">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-3xl font-bold">Galerie</h2>
     <div class="flex items-center space-x-3">
      <button onclick="shuffleGallery()" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors">
       ðŸ”€ MÃ©langer
      </button>
     </div>
    </div>
    <div id="gallery-grid" class="columns-1 sm:columns-2 md:columns-3 lg:columns-4 gap-4 space-y-4"><!-- Les images seront ajoutÃ©es ici -->
    </div>
   </div>
   <div id="trash-page" class="page-content hidden fade-in">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-3xl font-bold">Corbeille</h2>
     <div class="flex items-center space-x-3">
      <input type="text" id="trash-search" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field" placeholder="ðŸ” Rechercher...">
      <select id="trash-filter" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field">
       <option value="all">Tous</option>
       <option value="manhwa">Manhwas</option>
       <option value="chapter">Chapitres</option>
       <option value="tracking">Suivis</option>
       <option value="recent">Plus rÃ©cent</option>
       <option value="oldest">Plus ancien</option>
      </select>
      <button onclick="deleteAllPermanentlyFromTrash()" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors">
       Tout supprimer dÃ©finitivement
      </button>
     </div>
    </div>
    <div id="trash-list" class="space-y-4"><!-- Les Ã©lÃ©ments supprimÃ©s seront ajoutÃ©s ici -->
    </div>
   </div><!-- Tracking Page -->
   <div id="tracking-page" class="page-content hidden fade-in">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-3xl font-bold">Suivi de lecture</h2>
     <div class="flex items-center space-x-3">
      <input type="text" id="tracking-search" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field" placeholder="ðŸ” Rechercher...">
      <select id="tracking-filter" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field">
       <option value="all">Tous</option>
       <option value="en-cours">En cours</option>
       <option value="fini">Fini</option>
       <option value="en-pause">En pause</option>
       <option value="az">A-Z</option>
       <option value="za">Z-A</option>
      </select>
      <button id="add-tracking-btn" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 flex items-center">
       <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
       </svg>
       Ajouter un suivi
      </button>
     </div>
    </div>
    <div id="tracking-list" class="space-y-4"><!-- Les suivis seront ajoutÃ©s ici -->
    </div>
   </div><!-- Manhwa Detail Page -->
   <div id="manhwa-detail-page" class="page-content hidden fade-in"><button id="back-to-library" class="mb-6 flex items-center text-indigo-600 hover:text-indigo-800">
     <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
     </svg> Retour </button>
    <div id="manhwa-detail-content"><!-- Le dÃ©tail du manhwa sera ajoutÃ© ici -->
    </div>
   </div><!-- Reader Page -->
   <div id="reader-page" class="page-content hidden">
    <div class="mb-4 flex justify-between items-center"><button id="back-to-detail" class="flex items-center text-indigo-600 hover:text-indigo-800">
      <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
      </svg> Retour </button>
     <div class="flex items-center space-x-4"><button id="prev-chapter" class="bg-gray-200 px-4 py-2 rounded-lg hover:bg-gray-300">
       <svg class="w-5 h-5" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
       </svg></button> <span id="chapter-info" class="font-semibold"></span> <button id="next-chapter" class="bg-gray-200 px-4 py-2 rounded-lg hover:bg-gray-300">
       <svg class="w-5 h-5" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
       </svg></button>
     </div>
    </div>
    <div class="bg-black rounded-lg overflow-hidden">
     <div id="reading-progress" class="progress-bar"></div>
     <div id="reader-content" class="reading-page py-4"><!-- Les pages du chapitre seront ajoutÃ©es ici -->
     </div>
     <!-- Section Commentaires -->
     <div id="comments-section" class="mt-8 border-t border-gray-200 dark-mode:border-gray-700 pt-8">
      <h3 class="text-2xl font-bold mb-4 text-gray-900 dark-mode:text-gray-100">Commentaires</h3>
      <div class="mb-4 flex items-center space-x-3">
       <input type="text" id="comment-search" class="flex-1 px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field" placeholder="ðŸ” Rechercher dans les commentaires...">
       <select id="comment-filter" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field">
        <option value="all">Tous</option>
        <option value="recent">Plus rÃ©cent</option>
        <option value="oldest">Plus ancien</option>
       </select>
      </div>
      <div id="comments-list" class="space-y-4 mb-6"><!-- Les commentaires seront ajoutÃ©s ici -->
      </div>
      <div class="bg-gray-50 dark-mode:bg-gray-900 rounded-lg p-4 border border-gray-300 dark-mode:border-gray-600">
       <h4 class="font-semibold mb-3 text-gray-900 dark-mode:text-gray-100">Ajouter un commentaire</h4>
       <div class="flex items-start space-x-2 mb-3">
       <textarea id="comment-text" rows="3" class="flex-1 px-4 py-2 border border-gray-300 dark-mode:border-gray-600 rounded-lg focus:ring-2 focus:ring-indigo-600 bg-white dark-mode:bg-gray-800 text-gray-900 dark-mode:text-gray-100 placeholder-gray-500 dark-mode:placeholder-gray-400" placeholder="Votre commentaire..."></textarea>
       <button onclick="openEmojiPicker()" class="px-3 py-2 bg-gray-200 dark-mode:bg-gray-700 text-gray-700 dark-mode:text-gray-200 rounded-lg hover:bg-gray-300 dark-mode:hover:bg-gray-600 transition-colors text-2xl" title="Ajouter un emoji">
        ðŸ˜Š
       </button>
      </div>
      <div class="mb-3">
       <button onclick="openGalleryForComment()" class="px-4 py-2 bg-gray-200 dark-mode:bg-gray-700 text-gray-700 dark-mode:text-gray-200 rounded-lg hover:bg-gray-300 dark-mode:hover:bg-gray-600 transition-colors">
        ðŸ“· Ajouter une image de la galerie
       </button>
        <div id="comment-images-preview" class="mt-2 flex flex-wrap gap-2"></div>
       </div>
       <div class="flex justify-end">
        <button onclick="addComment()" class="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors">
         Publier
        </button>
       </div>
      </div>
     </div>
    </div>
   </div>
  </main><!-- Modal: Ajouter un Manhwa -->
  <div id="add-manhwa-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
   <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90%] overflow-y-auto">
    <div class="p-6 border-b">
     <div class="flex justify-between items-center">
      <h2 class="text-2xl font-bold">Ajouter un Manhwa</h2><button id="close-manhwa-modal" class="text-gray-400 hover:text-gray-600">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
       </svg></button>
     </div>
    </div>
    <form id="add-manhwa-form" class="p-6">
     <div class="mb-4"><label for="manhwa-title" class="block text-sm font-medium mb-2">Titre du Manhwa</label> <input type="text" id="manhwa-title" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Solo Leveling" required>
     </div>
     <div class="mb-4"><label for="manhwa-cover-url" class="block text-sm font-medium mb-2">ðŸ“· Chemin de l'image de couverture</label> <input type="text" id="manhwa-cover-url" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Image/passion.jpg" required>
      <p class="text-xs text-gray-500 mt-1">ðŸ’¡ Entrez le chemin du fichier image (ex: Image/passion.jpg ou Image/mon-manhwa.png)</p>
      <div id="image-preview" class="mt-2 hidden"><img id="preview-img" class="w-32 h-40 object-cover rounded-lg shadow-md" alt="AperÃ§u">
      </div>
     </div>
     <div class="mb-4"><label for="manhwa-season" class="block text-sm font-medium mb-2">Saison (optionnel)</label> <input type="text" id="manhwa-season" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Saison 1, Saison 2...">
     </div>
     <div class="mb-6"><label for="manhwa-description" class="block text-sm font-medium mb-2">Description</label> <textarea id="manhwa-description" rows="3" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Description du manhwa..." required></textarea>
     </div>
     <div class="flex justify-end space-x-3"><button type="button" id="cancel-manhwa" class="px-4 py-2 border rounded-lg hover:bg-gray-100">Annuler</button> <button type="submit" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700"> <span id="manhwa-submit-text">Ajouter</span> <span id="manhwa-loading" class="hidden"> <span class="inline-block loading-spinner w-5 h-5"></span> </span> </button>
     </div>
    </form>
   </div>
  </div><!-- Modal: Ajouter un Chapitre -->
  <div id="add-chapter-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
   <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90%] overflow-y-auto">
    <div class="p-6 border-b">
     <div class="flex justify-between items-center">
      <h2 class="text-2xl font-bold">Ajouter un Chapitre</h2><button id="close-chapter-modal" class="text-gray-400 hover:text-gray-600">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
       </svg></button>
     </div>
    </div>
    <form id="add-chapter-form" class="p-6">
     <div class="mb-4"><label for="chapter-number" class="block text-sm font-medium mb-2">NumÃ©ro du Chapitre</label> <input type="number" id="chapter-number" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="1" required>
     </div>
     <div class="mb-4"><label for="chapter-title" class="block text-sm font-medium mb-2">Titre du Chapitre</label> <input type="text" id="chapter-title" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Le RÃ©veil" required>
     </div>
     <div class="mb-4"><label for="chapter-description" class="block text-sm font-medium mb-2">Description (optionnel)</label> <textarea id="chapter-description" rows="2" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Courte description du chapitre..."></textarea>
     </div>
     <div class="mb-4"><label for="chapter-season-add" class="block text-sm font-medium mb-2">Saison (optionnel)</label> <input type="text" id="chapter-season-add" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Saison 1, Saison 2...">
     </div>
     <div class="mb-4"><label for="chapter-cover-add" class="block text-sm font-medium mb-2">ðŸ“· Image de couverture (optionnel)</label> <input type="text" id="chapter-cover-add" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Image/chapitre-special.jpg">
      <p class="text-xs text-gray-500 mt-1">ðŸ’¡ Laissez vide pour utiliser l'image de couverture du manhwa par dÃ©faut. Sinon, entrez le chemin (ex: Image/chapitre-special.jpg)</p>
      <div id="chapter-cover-add-preview" class="mt-2 hidden"><img id="chapter-cover-add-preview-img" class="w-32 h-40 object-cover rounded-lg shadow-md" alt="AperÃ§u">
      </div>
     </div>
     <div class="mb-6"><label for="mhtml-path" class="block text-sm font-medium mb-2">ðŸ“„ Chemin du fichier MHTML</label> <input type="text" id="mhtml-path" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="chapitres/qqq/6.mhtml" required>
      <p class="text-xs text-gray-500 mt-1">ðŸ’¡ Colle juste: chapitres/ton-dossier/fichier.mhtml</p>
      <div id="mhtml-status" class="hidden mt-4">
       <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <div class="flex items-center">
         <div class="loading-spinner w-5 h-5 mr-3"></div>
         <p class="text-blue-700 font-medium">Chargement et extraction des images...</p>
        </div>
       </div>
      </div>
      <div id="mhtml-preview" class="hidden mt-4">
       <div class="bg-green-50 border border-green-200 rounded-lg p-4 mb-3">
        <p class="text-green-700 font-bold">âœ… <span id="mhtml-count">0</span> images extraites!</p>
       </div>
       <div id="mhtml-preview-grid" class="grid grid-cols-4 gap-2"><!-- AperÃ§us des images MHTML -->
       </div>
      </div>
     </div>
     <div class="flex justify-end space-x-3"><button type="button" id="cancel-chapter" class="px-4 py-2 border rounded-lg hover:bg-gray-100">Annuler</button> <button type="submit" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700"> <span id="chapter-submit-text">Ajouter Chapitre</span> <span id="chapter-loading" class="hidden"> <span class="inline-block loading-spinner w-5 h-5"></span> </span> </button>
     </div>
    </form>
   </div>
  </div><!-- Modal: Modifier un Manhwa -->
  <div id="edit-manhwa-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
   <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90%] overflow-y-auto">
    <div class="p-6 border-b">
     <div class="flex justify-between items-center">
      <h2 class="text-2xl font-bold">Modifier le Manhwa</h2><button id="close-edit-manhwa-modal" class="text-gray-400 hover:text-gray-600">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
       </svg></button>
     </div>
    </div>
    <form id="edit-manhwa-form" class="p-6">
     <div class="mb-4"><label for="edit-manhwa-title" class="block text-sm font-medium mb-2">Titre du Manhwa</label> <input type="text" id="edit-manhwa-title" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" required>
     </div>
     <div class="mb-4"><label for="edit-manhwa-cover-url" class="block text-sm font-medium mb-2">ðŸ“· Chemin de l'image de couverture</label> <input type="text" id="edit-manhwa-cover-url" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Image/passion.jpg" required>
      <p class="text-xs text-gray-500 mt-1">ðŸ’¡ Entrez le chemin du fichier image (ex: Image/passion.jpg ou Image/mon-manhwa.png)</p>
      <div id="edit-image-preview" class="mt-2 hidden"><img id="edit-preview-img" class="w-32 h-40 object-cover rounded-lg shadow-md" alt="AperÃ§u">
      </div>
     </div>
     <div class="mb-4"><label for="edit-manhwa-season" class="block text-sm font-medium mb-2">Saison (optionnel)</label> <input type="text" id="edit-manhwa-season" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Saison 1, Saison 2...">
     </div>
     <div class="mb-6"><label for="edit-manhwa-description" class="block text-sm font-medium mb-2">Description</label> <textarea id="edit-manhwa-description" rows="3" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" required></textarea>
     </div>
     <div class="flex justify-end space-x-3"><button type="button" id="cancel-edit-manhwa" class="px-4 py-2 border rounded-lg hover:bg-gray-100">Annuler</button> <button type="submit" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700"> <span id="edit-manhwa-submit-text">Modifier</span> <span id="edit-manhwa-loading" class="hidden"> <span class="inline-block loading-spinner w-5 h-5"></span> </span> </button>
     </div>
    </form>
   </div>
  </div><!-- Modal: Modifier un Chapitre -->
  <div id="edit-chapter-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
   <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90%] overflow-y-auto">
    <div class="p-6 border-b">
     <div class="flex justify-between items-center">
      <h2 class="text-2xl font-bold">Modifier le Chapitre</h2><button id="close-edit-chapter-modal" class="text-gray-400 hover:text-gray-600">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
       </svg></button>
     </div>
    </div>
    <form id="edit-chapter-form" class="p-6">
     <div class="mb-4"><label for="edit-chapter-number" class="block text-sm font-medium mb-2">NumÃ©ro du Chapitre</label> <input type="number" id="edit-chapter-number" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" required>
     </div>
     <div class="mb-4"><label for="edit-chapter-title" class="block text-sm font-medium mb-2">Titre du Chapitre</label> <input type="text" id="edit-chapter-title" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" required>
     </div>
     <div class="mb-4"><label for="edit-chapter-description" class="block text-sm font-medium mb-2">Description (optionnel)</label> <textarea id="edit-chapter-description" rows="2" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600"></textarea>
     </div>
     <div class="mb-4"><label for="edit-chapter-season" class="block text-sm font-medium mb-2">Saison (optionnel)</label> <input type="text" id="edit-chapter-season" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Saison 1, Saison 2...">
     </div>
     <div class="mb-4"><label for="edit-chapter-cover" class="block text-sm font-medium mb-2">ðŸ“· Image de couverture (optionnel)</label> <input type="text" id="edit-chapter-cover" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Image/chapitre-special.jpg">
      <p class="text-xs text-gray-500 mt-1">ðŸ’¡ Laissez vide pour utiliser l'image de couverture du manhwa par dÃ©faut. Sinon, entrez le chemin (ex: Image/chapitre-special.jpg)</p>
      <div id="edit-chapter-cover-preview" class="mt-2 hidden"><img id="edit-chapter-preview-img" class="w-32 h-40 object-cover rounded-lg shadow-md" alt="AperÃ§u">
      </div>
     </div>
     <div id="edit-chapter-mhtml-container" class="mb-4 hidden"><label for="edit-chapter-mhtml" class="block text-sm font-medium mb-2">ðŸ“„ Chemin du fichier MHTML</label> <input type="text" id="edit-chapter-mhtml" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="chapitres/qqq/6.mhtml">
      <p class="text-xs text-gray-500 mt-1">ðŸ’¡ Modifier le chemin du fichier MHTML (mode dÃ©veloppeur uniquement)</p>
     </div>
     <div class="flex justify-end space-x-3"><button type="button" id="cancel-edit-chapter" class="px-4 py-2 border rounded-lg hover:bg-gray-100">Annuler</button> <button type="submit" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700"> <span id="edit-chapter-submit-text">Modifier</span> <span id="edit-chapter-loading" class="hidden"> <span class="inline-block loading-spinner w-5 h-5"></span> </span> </button>
     </div>
    </form>
   </div>
  </div><!-- Modal: Ajouter/Modifier un Suivi -->
  <div id="tracking-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
   <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90%] overflow-y-auto">
    <div class="p-6 border-b">
     <div class="flex justify-between items-center">
      <h2 class="text-2xl font-bold" id="tracking-modal-title">Ajouter un Suivi</h2><button id="close-tracking-modal" class="text-gray-400 hover:text-gray-600">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
       </svg></button>
     </div>
    </div>
    <form id="tracking-form" class="p-6">
     <div class="mb-4"><label for="tracking-title" class="block text-sm font-medium mb-2">Titre du Manhwa</label> <input type="text" id="tracking-title" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Solo Leveling" required>
     </div>
     <div class="mb-4"><label for="tracking-chapter" class="block text-sm font-medium mb-2">Chapitre actuel</label> <input type="number" id="tracking-chapter" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="1" min="0" required>
     </div>
     <div class="mb-4"><label for="tracking-status" class="block text-sm font-medium mb-2">Statut</label> <select id="tracking-status" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600">
      <option value="en-cours">En cours</option>
      <option value="fini">Fini</option>
      <option value="en-pause">En pause</option>
     </select>
     </div>
     <div class="mb-4"><label for="tracking-season" class="block text-sm font-medium mb-2">Saison (optionnel)</label> <input type="text" id="tracking-season" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Saison 1, Saison 2...">
     </div>
     <div class="mb-6"><label for="tracking-notes" class="block text-sm font-medium mb-2">Notes (optionnel)</label> <textarea id="tracking-notes" rows="3" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Notes personnelles..."></textarea>
     </div>
     <div class="flex justify-end space-x-3"><button type="button" id="cancel-tracking" class="px-4 py-2 border rounded-lg hover:bg-gray-100">Annuler</button> <button type="submit" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700"> <span id="tracking-submit-text">Ajouter</span> <span id="tracking-loading" class="hidden"> <span class="inline-block loading-spinner w-5 h-5"></span> </span> </button>
     </div>
    </form>
   </div>
  </div><!-- Settings Panel -->
  <div id="settings-panel" class="fixed top-16 right-0 h-full w-80 bg-white shadow-lg transform translate-x-full transition-transform duration-300 z-40">
   <div class="p-6">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-xl font-bold">ParamÃ¨tres</h2><button id="close-settings" class="p-1 hover:bg-gray-100 rounded">
      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
      </svg></button>
    </div><!-- Mode sombre -->
    <div class="mb-6">
     <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
      <div class="flex items-center">
       <svg id="theme-icon" class="w-5 h-5 mr-3 text-indigo-600" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>
       </svg>
       <div>
        <h3 class="font-semibold">Mode sombre</h3>
        <p class="text-xs text-gray-500">ThÃ¨me de l'interface</p>
       </div>
      </div><button id="theme-toggle" class="relative inline-flex items-center h-6 rounded-full w-11 bg-gray-300 transition-colors"> <span id="toggle-circle" class="inline-block w-4 h-4 transform translate-x-1 bg-white rounded-full transition-transform"></span> </button>
     </div>
    </div><!-- Ajouter manhwa -->
    <div id="add-manhwa-settings-container" class="mb-6"><button id="add-manhwa-settings" class="w-full flex items-center justify-between p-4 bg-indigo-50 hover:bg-indigo-100 rounded-lg transition-colors">
      <div class="flex items-center">
       <svg class="w-5 h-5 mr-3 text-indigo-600" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
       </svg>
       <div class="text-left">
        <h3 class="font-semibold text-indigo-900">Ajouter un Manhwa</h3>
        <p class="text-xs text-indigo-600">Nouveau manhwa Ã  lire</p>
       </div>
      </div>
      <svg class="w-5 h-5 text-indigo-600" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
      </svg></button>
    </div><!-- Statistiques -->
    <div class="mt-8 p-4 bg-gray-50 rounded-lg">
     <h3 class="font-semibold mb-3 text-sm text-gray-500 uppercase">Statistiques</h3>
     <div class="space-y-2">
      <div class="flex justify-between"><span class="text-sm">Manhwas</span> <span id="stats-manhwas" class="font-bold text-indigo-600">0</span>
      </div>
      <div class="flex justify-between"><span class="text-sm">Chapitres</span> <span id="stats-chapters" class="font-bold text-indigo-600">0</span>
      </div>
     </div>
    </div>
   </div>
  </div><!-- Loading Overlay -->
  <div id="loading-overlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
   <div class="bg-white rounded-lg p-8 flex flex-col items-center">
    <div class="loading-spinner mb-4"></div>
    <p class="text-gray-700 font-medium">Chargement...</p>
   </div>
  </div>
 

  <script type="module">
        // Configuration et Ã©tat global
        let galleryImages = [];
        let currentManhwaId = null;
        let currentChapterNumber = null;
        let allManhwas = [];
        let allChapters = [];
        let isDarkMode = false;
        let isLocalMode = false;
        
        // DÃ©tection du mode dÃ©veloppeur (localhost)
        function isDeveloperMode() {
            const hostname = window.location.hostname;
            return hostname === 'localhost' || 
                   hostname === '127.0.0.1' || 
                   hostname === '' ||
                   hostname.startsWith('192.168.') ||
                   hostname.startsWith('10.') ||
                   hostname.startsWith('172.');
        }
        
        // Fonction pour afficher le popup "vous n'Ãªtes pas en mode dÃ©veloppeur"
        function showDeveloperModeRequired() {
            const dialog = document.createElement('div');
            dialog.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            dialog.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl max-w-md mx-4 p-6">
                    <div class="flex items-center mb-4">
                        <svg class="w-8 h-8 text-orange-500 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                        </svg>
                        <h3 class="text-xl font-bold">Mode dÃ©veloppeur requis</h3>
                    </div>
                    <p class="text-gray-600 mb-6">
                        Vous n'Ãªtes pas en mode dÃ©veloppeur. La crÃ©ation, modification et suppression de manhwas et chapitres est uniquement disponible en localhost.
                    </p>
                    <p class="text-sm text-gray-500 mb-6">
                        Pour ajouter, modifier ou supprimer des manhwas/chapitres, ouvrez le site en localhost. Utilisez la section "Suivi" pour suivre votre progression en ligne.
                    </p>
                    <div class="flex justify-end">
                        <button id="close-dev-mode-dialog" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700">
                            Compris
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
            
            dialog.querySelector('#close-dev-mode-dialog').onclick = () => {
                dialog.remove();
            };
            
            // Fermer en cliquant en dehors
            dialog.onclick = (e) => {
                if (e.target === dialog) {
                    dialog.remove();
                }
            };
        }

        // Ã‰lÃ©ments DOM
        const menuBtn = document.getElementById('menu-btn');
        const sidebar = document.getElementById('sidebar');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsPanel = document.getElementById('settings-panel');
        const closeSettings = document.getElementById('close-settings');
        const themeToggle = document.getElementById('theme-toggle');
        const themeIcon = document.getElementById('theme-icon');
        const toggleCircle = document.getElementById('toggle-circle');
        const addManhwaSettings = document.getElementById('add-manhwa-settings');
        const addManhwaModal = document.getElementById('add-manhwa-modal');
        const closeManhwaModal = document.getElementById('close-manhwa-modal');
        const addManhwaForm = document.getElementById('add-manhwa-form');
        const addChapterModal = document.getElementById('add-chapter-modal');
        const closeChapterModal = document.getElementById('close-chapter-modal');
        const addChapterForm = document.getElementById('add-chapter-form');
        const navItems = document.querySelectorAll('.nav-item');

        // Variable globale pour stocker les donnÃ©es
        let globalData = [];
        let saveTimeout = null; // Timeout pour debounce de la sauvegarde
        
        // Fonction pour sauvegarder automatiquement dans data.php (avec debounce)
        function scheduleAutoSave(data) {
            if (!isDeveloperMode()) {
                return;
            }
            
            // Annuler la sauvegarde prÃ©cÃ©dente si elle n'a pas encore Ã©tÃ© exÃ©cutÃ©e
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            
            // Programmer la sauvegarde aprÃ¨s 300ms d'inactivitÃ© (rÃ©duit pour plus de rÃ©activitÃ©)
            saveTimeout = setTimeout(async () => {
                await saveDataToFileAuto(data);
            }, 300);
        }
        
        // Fonction pour sauvegarder automatiquement dans data.php via PHP
        async function saveDataToFileAuto(data) {
            if (!isDeveloperMode()) {
                return;
            }
            
            try {
                const response = await fetch('save-data.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                if (result.success) {
                    console.log('âœ… data.php sauvegardÃ© automatiquement');
                } else {
                    console.error('Erreur lors de la sauvegarde:', result.message);
                }
            } catch (error) {
                console.error('Erreur lors de la sauvegarde automatique:', error);
            }
        }

        // SDK MySQL - Utilise la base de donnÃ©es MySQL via PHP
        function createMySQLSDK() {
            let localData = [];
            let dataHandler = null;

            return {
                init: async (handler) => {
                    dataHandler = handler;
                    
                    // Charger TOUTES les donnÃ©es depuis MySQL
                    try {
                        const response = await fetch('./api-all-data.php?t=' + Date.now(), {
                            cache: 'no-cache',
                            headers: {
                                'Cache-Control': 'no-cache'
                            }
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            if (result.success && Array.isArray(result.data)) {
                                localData = result.data;
                                console.log('âœ… DonnÃ©es chargÃ©es depuis MySQL:', localData.length, 'Ã©lÃ©ments');
                            } else {
                                console.warn('âš ï¸ RÃ©ponse MySQL invalide');
                                localData = [];
                            }
                        } else {
                            console.error('âš ï¸ Erreur HTTP lors du chargement MySQL:', response.status);
                            // En cas d'erreur, essayer de charger depuis data.php comme fallback
                            try {
                                const jsonResponse = await fetch('./data.php?t=' + Date.now());
                                if (jsonResponse.ok) {
                                    const jsonData = await jsonResponse.json();
                                    localData = Array.isArray(jsonData) ? jsonData : [];
                                    console.log('âš ï¸ Fallback: donnÃ©es chargÃ©es depuis data.php:', localData.length, 'Ã©lÃ©ments');
                                }
                            } catch (e) {
                                console.error('âš ï¸ Erreur fallback data.php:', e);
                                localData = [];
                            }
                        }
                    } catch (error) {
                        console.error('âš ï¸ Erreur lors du chargement MySQL:', error);
                        // Fallback vers data.php
                        try {
                            const jsonResponse = await fetch('./data.php?t=' + Date.now());
                            if (jsonResponse.ok) {
                                const jsonData = await jsonResponse.json();
                                localData = Array.isArray(jsonData) ? jsonData : [];
                                console.log('âš ï¸ Fallback: donnÃ©es chargÃ©es depuis data.php');
                            }
                        } catch (e) {
                            localData = [];
                        }
                    }
                    
                    // Toujours synchroniser globalData avec localData
                    globalData = JSON.parse(JSON.stringify(localData));
                    console.log('âœ… DonnÃ©es chargÃ©es et synchronisÃ©es:', globalData.length, 'Ã©lÃ©ments');
                    
                    // Notifier le handler avec les donnÃ©es chargÃ©es IMMÃ‰DIATEMENT
                        if (dataHandler) {
                        requestAnimationFrame(() => {
                            dataHandler.onDataChanged(localData);
                        });
                        }
                    
                    return { isOk: true };
                },
                create: async (data) => {
                    if (!isDeveloperMode()) {
                        return { isOk: false, error: 'Mode dÃ©veloppeur requis' };
                    }
                    
                    data.__backendId = 'local_' + Date.now() + '_' + Math.random();
                    
                    // DÃ©terminer le type et sauvegarder dans MySQL
                    let apiUrl = '';
                    if (data.manhwa_title && !data.chapter_number) {
                        // C'est un manhwa
                        apiUrl = './api-manhwas.php';
                    } else if (data.chapter_number !== undefined) {
                        // C'est un chapitre
                        apiUrl = './api-chapters.php';
                    } else {
                        // Autre type (tracking, trash) - utiliser l'ancien systÃ¨me pour l'instant
                    localData.push(data);
                        globalData = JSON.parse(JSON.stringify(localData));
                        if (dataHandler) {
                            dataHandler.onDataChanged(localData);
                        }
                        saveDataToFileAuto(globalData).catch(err => {
                            console.error('Erreur sauvegarde:', err);
                        });
                        return { isOk: true };
                    }
                    
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(data)
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            // Recharger toutes les donnÃ©es depuis MySQL
                            const allDataResponse = await fetch('./api-all-data.php?t=' + Date.now());
                            if (allDataResponse.ok) {
                                const allDataResult = await allDataResponse.json();
                                if (allDataResult.success) {
                                    localData = allDataResult.data;
                                    globalData = JSON.parse(JSON.stringify(localData));
                                    
                                    // Mettre Ã  jour immÃ©diatement
                    if (dataHandler) {
                                        dataHandler.onDataChanged(localData);
                                    }
                                    
                                    console.log('âœ… Ã‰lÃ©ment crÃ©Ã© et synchronisÃ© avec MySQL');
                                    return { isOk: true };
                                }
                            }
                        } else {
                            console.error('âŒ Erreur crÃ©ation MySQL:', result.error);
                            return { isOk: false, error: result.error };
                        }
                    } catch (error) {
                        console.error('âŒ Erreur lors de la crÃ©ation:', error);
                        return { isOk: false, error: error.message };
                    }
                    
                    return { isOk: true };
                },
                update: async (record) => {
                    // MODIFICATIONS AUTORISÃ‰ES UNIQUEMENT EN MODE DÃ‰VELOPPEUR (sauf pour le suivi qui utilise localStorage)
                    if (!isDeveloperMode()) {
                        return { isOk: false, error: 'Mode dÃ©veloppeur requis pour les modifications' };
                    }
                    
                    // DÃ©terminer le type et mettre Ã  jour dans MySQL
                    let apiUrl = '';
                    if (record.manhwa_title && !record.chapter_number) {
                        // C'est un manhwa
                        apiUrl = './api-manhwas.php';
                    } else if (record.chapter_number !== undefined) {
                        // C'est un chapitre
                        apiUrl = './api-chapters.php';
                    } else {
                        // Autre type - utiliser l'ancien systÃ¨me
                    const index = localData.findIndex(item => item.__backendId === record.__backendId);
                    if (index !== -1) {
                        localData[index] = record;
                            globalData = JSON.parse(JSON.stringify(localData));
                        if (dataHandler) {
                                dataHandler.onDataChanged(localData);
                            }
                            saveDataToFileAuto(globalData).catch(err => {
                                console.error('Erreur sauvegarde:', err);
                            });
                        }
                        return { isOk: true };
                    }
                    
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(record)
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            // Recharger toutes les donnÃ©es depuis MySQL
                            const allDataResponse = await fetch('./api-all-data.php?t=' + Date.now());
                            if (allDataResponse.ok) {
                                const allDataResult = await allDataResponse.json();
                                if (allDataResult.success) {
                                    localData = allDataResult.data;
                                    globalData = JSON.parse(JSON.stringify(localData));
                                    
                                    // Mettre Ã  jour immÃ©diatement
                                    if (dataHandler) {
                                        dataHandler.onDataChanged(localData);
                                    }
                                    
                                    console.log('âœ… Ã‰lÃ©ment mis Ã  jour dans MySQL');
                                    return { isOk: true };
                                }
                            }
                        } else {
                            console.error('âŒ Erreur mise Ã  jour MySQL:', result.error);
                            return { isOk: false, error: result.error };
                        }
                    } catch (error) {
                        console.error('âŒ Erreur lors de la mise Ã  jour:', error);
                        return { isOk: false, error: error.message };
                    }
                    
                    return { isOk: true };
                },
                delete: async (record) => {
                    if (!isDeveloperMode()) {
                        return { isOk: false, error: 'Mode dÃ©veloppeur requis' };
                    }
                    
                    // DÃ©terminer le type et supprimer dans MySQL
                    let apiUrl = '';
                    if (record.manhwa_title && !record.chapter_number) {
                        // C'est un manhwa
                        apiUrl = './api-manhwas.php';
                    } else if (record.chapter_number !== undefined) {
                        // C'est un chapitre
                        apiUrl = './api-chapters.php';
                    } else {
                        // Autre type - utiliser l'ancien systÃ¨me
                    localData = localData.filter(item => item.__backendId !== record.__backendId);
                        globalData = JSON.parse(JSON.stringify(localData));
                    if (dataHandler) {
                            dataHandler.onDataChanged(localData);
                        }
                        saveDataToFileAuto(globalData).catch(err => {
                            console.error('Erreur sauvegarde:', err);
                        });
                        return { isOk: true };
                    }
                    
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'DELETE',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(record)
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            // Recharger toutes les donnÃ©es depuis MySQL
                            const allDataResponse = await fetch('./api-all-data.php?t=' + Date.now());
                            if (allDataResponse.ok) {
                                const allDataResult = await allDataResponse.json();
                                if (allDataResult.success) {
                                    localData = allDataResult.data;
                                    globalData = JSON.parse(JSON.stringify(localData));
                                    
                                    // Mettre Ã  jour immÃ©diatement
                                    if (dataHandler) {
                                        dataHandler.onDataChanged(localData);
                                    }
                                    
                                    console.log('âœ… Ã‰lÃ©ment supprimÃ© de MySQL');
                                    return { isOk: true };
                                }
                            }
                        } else {
                            console.error('âŒ Erreur suppression MySQL:', result.error);
                            return { isOk: false, error: result.error };
                        }
                    } catch (error) {
                        console.error('âŒ Erreur lors de la suppression:', error);
                        return { isOk: false, error: error.message };
                    }
                    
                    return { isOk: true };
                }
            };
        }

        // Initialisation du Data SDK
        const dataHandler = {
            onDataChanged(data) {
                console.log('ðŸ“Š onDataChanged appelÃ© avec', data.length, 'Ã©lÃ©ments');
                
                // Filtrer les manhwas (ont manhwa_id ET manhwa_title MAIS PAS chapter_number)
                const manhwas = data.filter(item => {
                    // Un manhwa a manhwa_id, manhwa_title, mais PAS chapter_number
                    return item.manhwa_id && 
                           item.manhwa_title && 
                           (item.chapter_number === undefined || item.chapter_number === null) &&
                           item.type !== 'tracking' && 
                           item.type !== 'trash';
                });
                
                // Filtrer les chapitres (ont chapter_number MAIS PAS manhwa_title)
                const chapters = data.filter(item => {
                    // Un chapitre a chapter_number mais PAS manhwa_title
                    return (item.chapter_number !== undefined && item.chapter_number !== null) &&
                           !item.manhwa_title &&
                           item.type !== 'tracking' && 
                           item.type !== 'trash';
                });
                
                console.log('ðŸ“š Manhwas trouvÃ©s:', manhwas.length);
                console.log('ðŸ“– Chapitres trouvÃ©s:', chapters.length);
                
                allManhwas = manhwas;
                allChapters = chapters;
                
                // Charger les suivis depuis data.php
                loadTrackingList();
                
                // Mettre Ã  jour TOUTES les pages IMMÃ‰DIATEMENT
                updateAllPages();
            }
        };

        // Protection contre F12 et inspecteur (uniquement en ligne)
        document.addEventListener('keydown', (e) => {
            if (!isDeveloperMode()) {
                // Bloquer F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
                if (e.key === 'F12' || 
                    (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) ||
                    (e.ctrlKey && e.key === 'U')) {
                    e.preventDefault();
                    return false;
                }
            }
        });
        
        // Protection contre le clic droit (uniquement en ligne)
        document.addEventListener('contextmenu', (e) => {
            if (!isDeveloperMode()) {
                e.preventDefault();
                return false;
            }
        });
        
        // Protection contre les iframes (empÃªcher le site d'Ãªtre intÃ©grÃ©)
        if (window.top !== window.self && !isDeveloperMode()) {
            window.top.location = window.self.location;
        }
        
        // Authentification Google Drive (uniquement en ligne)
        let isGoogleDriveAuthenticated = false;
        let googleDriveAccessToken = null;
        
        async function initGoogleDriveAuth() {
            if (isDeveloperMode()) {
                // En localhost, pas besoin d'authentification
                isGoogleDriveAuthenticated = true;
                return;
            }
            
            // VÃ©rifier si l'utilisateur est dÃ©jÃ  authentifiÃ©
            const savedToken = localStorage.getItem('googleDriveToken');
            if (savedToken) {
                googleDriveAccessToken = savedToken;
                isGoogleDriveAuthenticated = true;
                return;
            }
            
            // Afficher le modal d'authentification
            showGoogleDriveAuthModal();
        }
        
        function showGoogleDriveAuthModal() {
            const modal = document.createElement('div');
            modal.id = 'google-drive-auth-modal';
            modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark-mode:bg-gray-800 rounded-xl shadow-2xl max-w-md w-full mx-4 p-6">
                    <h2 class="text-2xl font-bold mb-4 text-gray-900 dark-mode:text-gray-100">Authentification requise</h2>
                    <p class="text-gray-600 dark-mode:text-gray-300 mb-6">
                        Vous devez vous connecter avec votre compte Google Drive pour accÃ©der Ã  ce site.
                        Vos donnÃ©es personnelles seront synchronisÃ©es avec votre Drive.
                    </p>
                    <div id="g_id_onload"
                         data-client_id="YOUR_GOOGLE_CLIENT_ID"
                         data-callback="handleGoogleDriveAuth"
                         data-auto_prompt="false">
                    </div>
                    <div class="g_id_signin" 
                         data-type="standard"
                         data-size="large"
                         data-theme="outline"
                         data-text="sign_in_with"
                         data-shape="rectangular"
                         data-logo_alignment="left">
                    </div>
                    <p class="text-xs text-gray-500 dark-mode:text-gray-400 mt-4">
                        En vous connectant, vous acceptez que vos donnÃ©es soient synchronisÃ©es avec Google Drive.
                    </p>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        window.handleGoogleDriveAuth = function(response) {
            if (response.credential) {
                // DÃ©coder le token JWT (simplifiÃ© - en production, vÃ©rifiez cÃ´tÃ© serveur)
                googleDriveAccessToken = response.credential;
                localStorage.setItem('googleDriveToken', googleDriveAccessToken);
                isGoogleDriveAuthenticated = true;
                
                const modal = document.getElementById('google-drive-auth-modal');
                if (modal) modal.remove();
                
                showNotification('Authentification rÃ©ussie!', 'success');
                initializeApp();
            }
        };
        
        // Sauvegarder la page actuelle
        function saveCurrentPage() {
            const currentPage = document.querySelector('.page-content:not(.hidden)')?.id;
            if (currentPage) {
                const pageName = currentPage.replace('-page', '').replace('page-', '');
                localStorage.setItem('currentPage', pageName);
            }
        }
        
        // Restaurer la page actuelle
        function restoreCurrentPage() {
            const savedPage = localStorage.getItem('currentPage');
            console.log('ðŸ”„ Tentative de restauration de la page:', savedPage);
            if (savedPage && savedPage !== 'home' && savedPage !== '' && savedPage !== null) {
                // Attendre que les pages soient chargÃ©es
                setTimeout(() => {
                    const pageElement = document.getElementById(`${savedPage}-page`);
                    if (pageElement) {
                        console.log('âœ… Restauration de la page:', savedPage);
                        // Ne pas sauvegarder Ã  nouveau lors de la restauration
                        document.querySelectorAll('.page-content').forEach(page => {
                            page.classList.add('hidden');
                        });
                        pageElement.classList.remove('hidden');
                    } else {
                        console.log('âš ï¸ Page non trouvÃ©e:', savedPage);
                    }
                }, 500);
            } else {
                console.log('â„¹ï¸ Pas de page Ã  restaurer ou page d\'accueil');
            }
        }

        async function initializeApp() {
            // CACHER TOUTES LES PAGES IMMÃ‰DIATEMENT pour Ã©viter de voir l'accueil
            document.querySelectorAll('.page-content').forEach(page => {
                page.classList.add('hidden');
            });
            
            // Masquer les boutons d'ajout si on n'est pas en mode dÃ©veloppeur
            if (!isDeveloperMode()) {
                const addManhwaContainer = document.getElementById('add-manhwa-settings-container');
                if (addManhwaContainer) {
                    addManhwaContainer.style.display = 'none';
                }
            }
            
            // DÃ©tection automatique: MySQL (recommandÃ©) ou fallback JSON
            if (!window.dataSdk) {
                console.log('ðŸ”§ Mode LOCAL dÃ©tectÃ© - Utilisation de MySQL');
                isLocalMode = true;
                window.dataSdk = createMySQLSDK();
                if (isDeveloperMode()) {
                    showNotification('Mode dÃ©veloppeur activÃ© ðŸ”§ (MySQL)', 'info');
                }
            } else {
                console.log('â˜ï¸ Mode CANVA dÃ©tectÃ© - Utilisation du Data SDK');
                isLocalMode = false;
            }

            const result = await window.dataSdk.init(dataHandler);
            
            // Charger la galerie
            loadGalleryImages();
            
            // Restaurer la page IMMÃ‰DIATEMENT aprÃ¨s chargement
            const savedPage = localStorage.getItem('currentPage');
            if (savedPage && savedPage !== 'home' && savedPage !== '' && savedPage !== null) {
                const pageElement = document.getElementById(`${savedPage}-page`);
                if (pageElement) {
                    // Restaurer immÃ©diatement sans dÃ©lai
                    document.querySelectorAll('.page-content').forEach(page => {
                        page.classList.add('hidden');
                    });
                    pageElement.classList.remove('hidden');
                    console.log('âœ… Page restaurÃ©e immÃ©diatement:', savedPage);
                } else {
                    // Si la page n'existe pas, montrer home
                    document.getElementById('home-page')?.classList.remove('hidden');
                }
            } else {
                // Pas de page sauvegardÃ©e, montrer home
                document.getElementById('home-page')?.classList.remove('hidden');
            }
            if (!result.isOk) {
                showNotification('Erreur lors de l\'initialisation', 'error');
                console.error('Erreur SDK:', result.error);
            } else {
                console.log('âœ… Application initialisÃ©e avec succÃ¨s');
                console.log(`ðŸ“Š ${allManhwas.length} manhwas et ${allChapters.length} chapitres chargÃ©s`);
            }
        }

        // Gestion du thÃ¨me
        function toggleTheme() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode');
            document.getElementById('navbar').classList.toggle('dark-mode');
            document.getElementById('sidebar').classList.toggle('dark-mode');
            settingsPanel.classList.toggle('dark-mode');
            
            // Mettre Ã  jour tous les Ã©lÃ©ments avec la classe card
            document.querySelectorAll('.card').forEach(card => {
                card.classList.toggle('dark-mode');
            });
            
            // Mettre Ã  jour tous les modals
            document.querySelectorAll('#add-manhwa-modal > div, #add-chapter-modal > div, #edit-manhwa-modal > div, #edit-chapter-modal > div, #tracking-modal > div').forEach(modal => {
                modal.classList.toggle('dark-mode');
            });
            
            // Mettre Ã  jour le toggle switch
            if (isDarkMode) {
                themeToggle.classList.remove('bg-gray-300');
                themeToggle.classList.add('bg-indigo-600');
                toggleCircle.classList.remove('translate-x-1');
                toggleCircle.classList.add('translate-x-6');
                themeIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>';
            } else {
                themeToggle.classList.remove('bg-indigo-600');
                themeToggle.classList.add('bg-gray-300');
                toggleCircle.classList.remove('translate-x-6');
                toggleCircle.classList.add('translate-x-1');
                themeIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>';
            }
            
            localStorage.setItem('darkMode', isDarkMode);
            
            // RafraÃ®chir la page de suivi pour appliquer les nouvelles couleurs
            if (document.getElementById('tracking-page') && !document.getElementById('tracking-page').classList.contains('hidden')) {
                updateTrackingPage();
            }
        }

        themeToggle.addEventListener('click', toggleTheme);

        // Charger le thÃ¨me sauvegardÃ© au dÃ©marrage
        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('darkMode');
            if (savedTheme === 'true') {
                isDarkMode = false; // On met false pour que toggleTheme() le passe Ã  true
                toggleTheme();
            }
        }

        // Appeler loadSavedTheme() au dÃ©marrage
        loadSavedTheme();

        // Gestion du menu sidebar
        menuBtn.addEventListener('click', () => {
            sidebar.classList.toggle('-translate-x-full');
            settingsPanel.classList.add('translate-x-full');
        });

        // Gestion du panneau paramÃ¨tres
        settingsBtn.addEventListener('click', () => {
            settingsPanel.classList.toggle('translate-x-full');
            sidebar.classList.add('-translate-x-full');
        });

        closeSettings.addEventListener('click', () => {
            settingsPanel.classList.add('translate-x-full');
        });

        // Bouton ajouter manhwa depuis paramÃ¨tres
        addManhwaSettings.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // VÃ©rifier le mode dÃ©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }
            
            addManhwaModal.classList.remove('hidden');
            settingsPanel.classList.add('translate-x-full');
        });

        // Fermer sidebar et settings en cliquant en dehors
        document.addEventListener('click', (e) => {
            if (!sidebar.contains(e.target) && !menuBtn.contains(e.target)) {
                sidebar.classList.add('-translate-x-full');
            }
            if (!settingsPanel.contains(e.target) && !settingsBtn.contains(e.target)) {
                settingsPanel.classList.add('translate-x-full');
            }
        });

        // Navigation entre les pages
        navItems.forEach(item => {
            item.addEventListener('click', () => {
                const page = item.getAttribute('data-page');
                showPage(page);
                sidebar.classList.add('-translate-x-full');
            });
        });

        function showPage(pageName) {
            console.log('ðŸ“„ Affichage de la page:', pageName);
            document.querySelectorAll('.page-content').forEach(page => {
                page.classList.add('hidden');
            });
            
            const pageElement = document.getElementById(`${pageName}-page`);
            if (pageElement) {
                pageElement.classList.remove('hidden');
                // Sauvegarder la page actuelle immÃ©diatement (SAUF home)
                if (pageName !== 'home') {
                    localStorage.setItem('currentPage', pageName);
                    console.log('ðŸ’¾ Page sauvegardÃ©e:', pageName);
                } else {
                    // Si on va sur home, ne pas sauvegarder (ou supprimer la sauvegarde)
                    localStorage.removeItem('currentPage');
                    console.log('ðŸ  Page home - sauvegarde supprimÃ©e');
                }
            } else {
                console.error('âŒ Page non trouvÃ©e:', pageName);
            }
        }

        // Modal Manhwa - Gestion des images
        const coverUrl = document.getElementById('manhwa-cover-url');
        const imagePreview = document.getElementById('image-preview');
        const previewImg = document.getElementById('preview-img');

        // PrÃ©visualisation de l'image depuis le chemin local
        coverUrl.addEventListener('input', (e) => {
            let path = e.target.value.trim();
            if (path) {
                // Nettoyer le chemin comme pour les chapitres MHTML
                path = path.replace(/\\/g, '/');
                if (path.includes('Site/')) {
                    path = path.split('Site/')[1];
                }
                if (path.includes('Image/') && !path.startsWith('Image/')) {
                    path = path.substring(path.indexOf('Image/'));
                }
                if (!path.startsWith('./') && !path.startsWith('/') && !path.startsWith('http')) {
                    path = './' + path;
                }
                
                previewImg.src = path;
                imagePreview.classList.remove('hidden');
                previewImg.onerror = () => {
                    imagePreview.classList.add('hidden');
                };
            } else {
                imagePreview.classList.add('hidden');
            }
        });

        closeManhwaModal.addEventListener('click', () => {
            addManhwaModal.classList.add('hidden');
            addManhwaForm.reset();
            imagePreview.classList.add('hidden');
        });

        document.getElementById('cancel-manhwa').addEventListener('click', () => {
            addManhwaModal.classList.add('hidden');
            addManhwaForm.reset();
            imagePreview.classList.add('hidden');
        });

        addManhwaForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // VÃ©rifier le mode dÃ©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }

            const submitBtn = e.target.querySelector('button[type="submit"]');
            const submitText = document.getElementById('manhwa-submit-text');
            const loading = document.getElementById('manhwa-loading');
            
            submitText.classList.add('hidden');
            loading.classList.remove('hidden');
            submitBtn.disabled = true;

            const title = document.getElementById('manhwa-title').value.trim();
            let coverImagePath = document.getElementById('manhwa-cover-url').value.trim();
            const description = document.getElementById('manhwa-description').value.trim();
            const season = document.getElementById('manhwa-season').value.trim();

            // Nettoyer le chemin pour le stockage (comme pour les chapitres MHTML)
            coverImagePath = coverImagePath.replace(/\\/g, '/');
            if (coverImagePath.includes('Site/')) {
                coverImagePath = coverImagePath.split('Site/')[1];
            }
            if (coverImagePath.includes('Image/') && !coverImagePath.startsWith('Image/')) {
                coverImagePath = coverImagePath.substring(coverImagePath.indexOf('Image/'));
            }
            if (!coverImagePath.startsWith('./') && !coverImagePath.startsWith('/') && !coverImagePath.startsWith('http')) {
                coverImagePath = './' + coverImagePath;
            }

            const manhwaId = 'manhwa_' + Date.now();

            const result = await window.dataSdk.create({
                manhwa_id: manhwaId,
                manhwa_title: title,
                manhwa_cover: coverImagePath,
                manhwa_description: description,
                manhwa_season: season || null,
                date_added: new Date().toISOString()
            });

            if (result.isOk) {
                showNotification('Manhwa ajoutÃ© avec succÃ¨s!', 'success');
                addManhwaModal.classList.add('hidden');
                addManhwaForm.reset();
                imagePreview.classList.add('hidden');
            } else {
                showNotification('Erreur lors de l\'ajout du manhwa', 'error');
                console.error('Erreur:', result.error);
            }

            submitText.classList.remove('hidden');
            loading.classList.add('hidden');
            submitBtn.disabled = false;
        });

        // PrÃ©visualisation de l'image de couverture lors de la crÃ©ation
        const chapterCoverAdd = document.getElementById('chapter-cover-add');
        const chapterCoverAddPreview = document.getElementById('chapter-cover-add-preview');
        const chapterCoverAddPreviewImg = document.getElementById('chapter-cover-add-preview-img');
        
        if (chapterCoverAdd) {
            chapterCoverAdd.addEventListener('input', (e) => {
                let path = e.target.value.trim();
                if (path) {
                    path = path.replace(/\\/g, '/');
                    if (path.includes('Site/')) {
                        path = path.split('Site/')[1];
                    }
                    if (path.includes('Image/') && !path.startsWith('Image/')) {
                        path = path.substring(path.indexOf('Image/'));
                    }
                    if (!path.startsWith('./') && !path.startsWith('/') && !path.startsWith('http')) {
                        path = './' + path;
                    }
                    chapterCoverAddPreviewImg.src = path;
                    chapterCoverAddPreview.classList.remove('hidden');
                    chapterCoverAddPreviewImg.onerror = () => {
                        chapterCoverAddPreview.classList.add('hidden');
                    };
                } else {
                    chapterCoverAddPreview.classList.add('hidden');
                }
            });
        }

        // Modal Chapitre
        closeChapterModal.addEventListener('click', () => {
            addChapterModal.classList.add('hidden');
            addChapterForm.reset();
            document.getElementById('mhtml-preview').classList.add('hidden');
            document.getElementById('mhtml-status').classList.add('hidden');
            if (chapterCoverAddPreview) chapterCoverAddPreview.classList.add('hidden');
        });

        document.getElementById('cancel-chapter').addEventListener('click', () => {
            addChapterModal.classList.add('hidden');
            addChapterForm.reset();
            document.getElementById('mhtml-preview').classList.add('hidden');
            document.getElementById('mhtml-status').classList.add('hidden');
            if (chapterCoverAddPreview) chapterCoverAddPreview.classList.add('hidden');
        });

        // VÃ©rifier rapidement que le fichier MHTML existe quand l'utilisateur entre le chemin
        const mhtmlPathInput = document.getElementById('mhtml-path');
        let checkTimeout = null;
        mhtmlPathInput.addEventListener('input', async (e) => {
            const path = e.target.value.trim();
            const statusDiv = document.getElementById('mhtml-status');
            const previewDiv = document.getElementById('mhtml-preview');
            
            if (!path || !path.endsWith('.mhtml')) {
                statusDiv.classList.add('hidden');
                previewDiv.classList.add('hidden');
                return;
            }
            
            // Attendre 1 seconde aprÃ¨s que l'utilisateur arrÃªte de taper
            clearTimeout(checkTimeout);
            statusDiv.classList.remove('hidden');
            statusDiv.innerHTML = `
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                    <div class="flex items-center">
                        <div class="loading-spinner w-5 h-5 mr-3"></div>
                        <p class="text-blue-700 font-medium">VÃ©rification du fichier...</p>
                    </div>
                </div>
            `;
            previewDiv.classList.add('hidden');
            
            checkTimeout = setTimeout(async () => {
                try {
                    // Nettoyer le chemin
                    let cleanPath = path.replace(/\\/g, '/');
                if (cleanPath.includes('Site/')) {
                    cleanPath = cleanPath.split('Site/')[1];
                }
                if (cleanPath.includes('chapitres/') && !cleanPath.startsWith('chapitres/')) {
                    cleanPath = cleanPath.substring(cleanPath.indexOf('chapitres/'));
                }
                    if (!cleanPath.startsWith('./') && !cleanPath.startsWith('/') && !cleanPath.startsWith('http')) {
                        cleanPath = './' + cleanPath;
                    }
                    
                    const response = await fetch(cleanPath, { method: 'HEAD' });
                    if (response.ok) {
                        statusDiv.innerHTML = `
                            <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                                <p class="text-green-700 font-bold">âœ… Fichier MHTML trouvÃ© et valide!</p>
                                <p class="text-green-600 text-sm mt-1">Le fichier sera chargÃ© lors de l'ouverture du chapitre</p>
                            </div>
                        `;
                    } else {
                        throw new Error(`Fichier non trouvÃ© (Status: ${response.status})`);
                    }
                } catch (error) {
                    statusDiv.innerHTML = `
                        <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                            <p class="text-red-700 font-bold">âŒ Fichier non trouvÃ©</p>
                            <p class="text-red-600 text-sm mt-1">${error.message}</p>
                        </div>
                    `;
                }
            }, 1000);
        });




        addChapterForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // VÃ©rifier le mode dÃ©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }
            
            if (!currentManhwaId) {
                showNotification('Erreur: Aucun manhwa sÃ©lectionnÃ©', 'error');
                return;
            }

            const submitBtn = e.target.querySelector('button[type="submit"]');
            const submitText = document.getElementById('chapter-submit-text');
            const loading = document.getElementById('chapter-loading');
            
            submitText.classList.add('hidden');
            loading.classList.remove('hidden');
            submitBtn.disabled = true;

            const chapterNumber = parseInt(document.getElementById('chapter-number').value);
            const chapterTitle = document.getElementById('chapter-title').value.trim();
            const chapterDescription = document.getElementById('chapter-description').value.trim();
            const chapterSeason = document.getElementById('chapter-season-add').value.trim();
            let chapterCover = document.getElementById('chapter-cover-add').value.trim();

            // Nettoyer le chemin de l'image de couverture (vide = utiliser celle du manhwa)
            if (chapterCover) {
                chapterCover = chapterCover.replace(/\\/g, '/');
                if (chapterCover.includes('Site/')) {
                    chapterCover = chapterCover.split('Site/')[1];
                }
                if (chapterCover.includes('Image/') && !chapterCover.startsWith('Image/')) {
                    chapterCover = chapterCover.substring(chapterCover.indexOf('Image/'));
                }
                if (!chapterCover.startsWith('./') && !chapterCover.startsWith('/') && !chapterCover.startsWith('http')) {
                    chapterCover = './' + chapterCover;
                }
            } else {
                chapterCover = null; // null = utiliser l'image du manhwa par dÃ©faut
            }

            // VÃ©rifier si le chapitre existe dÃ©jÃ 
            const existingChapter = allChapters.find(ch => 
                ch.manhwa_id === currentManhwaId && ch.chapter_number === chapterNumber
            );

            if (existingChapter) {
                showNotification(`Le chapitre ${chapterNumber} existe dÃ©jÃ `, 'error');
                submitText.classList.remove('hidden');
                loading.classList.add('hidden');
                submitBtn.disabled = false;
                return;
            }

            // RÃ©cupÃ©rer le chemin MHTML entrÃ© par l'utilisateur
            let mhtmlPath = document.getElementById('mhtml-path').value.trim();
            if (!mhtmlPath) {
                showNotification('Veuillez entrer le chemin du fichier MHTML', 'error');
                submitText.classList.remove('hidden');
                loading.classList.add('hidden');
                submitBtn.disabled = false;
                return;
            }

            // Nettoyer le chemin pour le stockage
            mhtmlPath = mhtmlPath.replace(/\\/g, '/');
            if (mhtmlPath.includes('Site/')) {
                mhtmlPath = mhtmlPath.split('Site/')[1];
            }
            if (mhtmlPath.includes('chapitres/') && !mhtmlPath.startsWith('chapitres/')) {
                mhtmlPath = mhtmlPath.substring(mhtmlPath.indexOf('chapitres/'));
            }
            if (!mhtmlPath.startsWith('./') && !mhtmlPath.startsWith('/') && !mhtmlPath.startsWith('http')) {
                mhtmlPath = './' + mhtmlPath;
            }

            // VÃ©rifier rapidement que le fichier existe (sans extraire les images)
            try {
                const testPath = mhtmlPath.startsWith('./') ? mhtmlPath : './' + mhtmlPath;
                const response = await fetch(testPath, { method: 'HEAD' });
                if (!response.ok) {
                    throw new Error(`Fichier non trouvÃ©: ${testPath}`);
                }
            } catch (error) {
                showNotification(`Fichier MHTML non trouvÃ©: ${mhtmlPath}`, 'error');
                submitText.classList.remove('hidden');
                loading.classList.add('hidden');
                submitBtn.disabled = false;
                return;
            }
            
            // Stocker seulement le chemin du fichier MHTML (pas les images)
            const result = await window.dataSdk.create({
                manhwa_id: currentManhwaId,
                chapter_number: chapterNumber,
                chapter_title: chapterTitle,
                chapter_description: chapterDescription,
                chapter_season: chapterSeason || null,
                chapter_pages: mhtmlPath, // Stocker le chemin au lieu des images
                chapter_cover: chapterCover, // null = utiliser l'image de couverture du manhwa par dÃ©faut
                date_added: new Date().toISOString()
            });

            if (result.isOk) {
                showNotification('Chapitre ajoutÃ© avec succÃ¨s! ðŸŽ‰', 'success');
                addChapterModal.classList.add('hidden');
                addChapterForm.reset();
                document.getElementById('mhtml-preview').classList.add('hidden');
                document.getElementById('mhtml-status').classList.add('hidden');
                
                // La mise Ã  jour a dÃ©jÃ  Ã©tÃ© faite par onDataChanged, mais on force le refresh de la page dÃ©tail
                setTimeout(() => {
                    if (currentManhwaId) {
                        showManhwaDetail(currentManhwaId);
                    }
                }, 300);
            } else {
                showNotification('Erreur lors de l\'ajout du chapitre', 'error');
            }

            submitText.classList.remove('hidden');
            loading.classList.add('hidden');
            submitBtn.disabled = false;
        });

        // Modal Modifier Manhwa
        const editManhwaModal = document.getElementById('edit-manhwa-modal');
        const closeEditManhwaModal = document.getElementById('close-edit-manhwa-modal');
        const editManhwaForm = document.getElementById('edit-manhwa-form');
        const editCoverUrl = document.getElementById('edit-manhwa-cover-url');
        const editImagePreview = document.getElementById('edit-image-preview');
        const editPreviewImg = document.getElementById('edit-preview-img');
        let currentEditManhwaId = null;

        // PrÃ©visualisation pour le modal d'Ã©dition
        editCoverUrl.addEventListener('input', (e) => {
            let path = e.target.value.trim();
            if (path) {
                path = path.replace(/\\/g, '/');
                if (path.includes('Site/')) {
                    path = path.split('Site/')[1];
                }
                if (path.includes('Image/') && !path.startsWith('Image/')) {
                    path = path.substring(path.indexOf('Image/'));
                }
                if (!path.startsWith('./') && !path.startsWith('/') && !path.startsWith('http')) {
                    path = './' + path;
                }
                editPreviewImg.src = path;
                editImagePreview.classList.remove('hidden');
                editPreviewImg.onerror = () => {
                    editImagePreview.classList.add('hidden');
                };
            } else {
                editImagePreview.classList.add('hidden');
            }
        });

        closeEditManhwaModal.addEventListener('click', () => {
            editManhwaModal.classList.add('hidden');
            editManhwaForm.reset();
            editImagePreview.classList.add('hidden');
            currentEditManhwaId = null;
        });

        document.getElementById('cancel-edit-manhwa').addEventListener('click', () => {
            editManhwaModal.classList.add('hidden');
            editManhwaForm.reset();
            editImagePreview.classList.add('hidden');
            currentEditManhwaId = null;
        });

        editManhwaForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const submitBtn = e.target.querySelector('button[type="submit"]');
            const submitText = document.getElementById('edit-manhwa-submit-text');
            const loading = document.getElementById('edit-manhwa-loading');
            
            submitText.classList.add('hidden');
            loading.classList.remove('hidden');
            submitBtn.disabled = true;

            const manhwa = allManhwas.find(m => m.__backendId === currentEditManhwaId);
            if (!manhwa) {
                showNotification('Erreur: Manhwa introuvable', 'error');
                submitText.classList.remove('hidden');
                loading.classList.add('hidden');
                submitBtn.disabled = false;
                return;
            }

            const title = document.getElementById('edit-manhwa-title').value.trim();
            let coverImagePath = document.getElementById('edit-manhwa-cover-url').value.trim();
            const description = document.getElementById('edit-manhwa-description').value.trim();
            const season = document.getElementById('edit-manhwa-season').value.trim();

            // Nettoyer le chemin
            coverImagePath = coverImagePath.replace(/\\/g, '/');
            if (coverImagePath.includes('Site/')) {
                coverImagePath = coverImagePath.split('Site/')[1];
            }
            if (coverImagePath.includes('Image/') && !coverImagePath.startsWith('Image/')) {
                coverImagePath = coverImagePath.substring(coverImagePath.indexOf('Image/'));
            }
            if (!coverImagePath.startsWith('./') && !coverImagePath.startsWith('/') && !coverImagePath.startsWith('http')) {
                coverImagePath = './' + coverImagePath;
            }

            // Mettre Ã  jour le manhwa
            const updatedManhwa = {
                ...manhwa,
                manhwa_title: title,
                manhwa_cover: coverImagePath,
                manhwa_description: description,
                manhwa_season: season || null
            };

            const result = await window.dataSdk.update(updatedManhwa);

            if (result.isOk) {
                showNotification('Manhwa modifiÃ© avec succÃ¨s!', 'success');
                editManhwaModal.classList.add('hidden');
                editManhwaForm.reset();
                editImagePreview.classList.add('hidden');
                currentEditManhwaId = null;
            } else {
                showNotification('Erreur lors de la modification', 'error');
            }

            submitText.classList.remove('hidden');
            loading.classList.add('hidden');
            submitBtn.disabled = false;
        });

        // Fonction pour ouvrir le modal de modification de manhwa
        function openEditManhwaModal(manhwaId) {
            const manhwa = allManhwas.find(m => m.__backendId === manhwaId);
            if (!manhwa) return;

            currentEditManhwaId = manhwaId;
            document.getElementById('edit-manhwa-title').value = manhwa.manhwa_title;
            document.getElementById('edit-manhwa-cover-url').value = manhwa.manhwa_cover.replace('./', '');
            document.getElementById('edit-manhwa-description').value = manhwa.manhwa_description;
            document.getElementById('edit-manhwa-season').value = manhwa.manhwa_season || '';
            
            // Afficher la prÃ©visualisation
            let previewPath = manhwa.manhwa_cover;
            if (!previewPath.startsWith('./') && !previewPath.startsWith('/') && !previewPath.startsWith('http')) {
                previewPath = './' + previewPath;
            }
            editPreviewImg.src = previewPath;
            editImagePreview.classList.remove('hidden');
            
            editManhwaModal.classList.remove('hidden');
        }

        // Modal Modifier Chapitre
        const editChapterModal = document.getElementById('edit-chapter-modal');
        const closeEditChapterModal = document.getElementById('close-edit-chapter-modal');
        const editChapterForm = document.getElementById('edit-chapter-form');
        const editChapterCover = document.getElementById('edit-chapter-cover');
        const editChapterCoverPreview = document.getElementById('edit-chapter-cover-preview');
        const editChapterPreviewImg = document.getElementById('edit-chapter-preview-img');
        let currentEditChapterId = null;

        // PrÃ©visualisation pour l'image de couverture du chapitre
        editChapterCover.addEventListener('input', (e) => {
            let path = e.target.value.trim();
            if (path) {
                path = path.replace(/\\/g, '/');
                if (path.includes('Site/')) {
                    path = path.split('Site/')[1];
                }
                if (path.includes('Image/') && !path.startsWith('Image/')) {
                    path = path.substring(path.indexOf('Image/'));
                }
                if (!path.startsWith('./') && !path.startsWith('/') && !path.startsWith('http')) {
                    path = './' + path;
                }
                editChapterPreviewImg.src = path;
                editChapterCoverPreview.classList.remove('hidden');
                editChapterPreviewImg.onerror = () => {
                    editChapterCoverPreview.classList.add('hidden');
                };
            } else {
                editChapterCoverPreview.classList.add('hidden');
            }
        });

        closeEditChapterModal.addEventListener('click', () => {
            editChapterModal.classList.add('hidden');
            editChapterForm.reset();
            editChapterCoverPreview.classList.add('hidden');
            currentEditChapterId = null;
        });

        document.getElementById('cancel-edit-chapter').addEventListener('click', () => {
            editChapterModal.classList.add('hidden');
            editChapterForm.reset();
            editChapterCoverPreview.classList.add('hidden');
            currentEditChapterId = null;
        });

        editChapterForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const submitBtn = e.target.querySelector('button[type="submit"]');
            const submitText = document.getElementById('edit-chapter-submit-text');
            const loading = document.getElementById('edit-chapter-loading');
            
            submitText.classList.add('hidden');
            loading.classList.remove('hidden');
            submitBtn.disabled = true;

            const chapter = allChapters.find(ch => ch.__backendId === currentEditChapterId);
            if (!chapter) {
                showNotification('Erreur: Chapitre introuvable', 'error');
                submitText.classList.remove('hidden');
                loading.classList.add('hidden');
                submitBtn.disabled = false;
                return;
            }

            const chapterNumber = parseInt(document.getElementById('edit-chapter-number').value);
            const chapterTitle = document.getElementById('edit-chapter-title').value.trim();
            const chapterDescription = document.getElementById('edit-chapter-description').value.trim();
            const chapterSeason = document.getElementById('edit-chapter-season').value.trim();
            let chapterCover = document.getElementById('edit-chapter-cover').value.trim();

            // Nettoyer le chemin de l'image de couverture (vide = utiliser celle du manhwa)
            if (chapterCover) {
                chapterCover = chapterCover.replace(/\\/g, '/');
                if (chapterCover.includes('Site/')) {
                    chapterCover = chapterCover.split('Site/')[1];
                }
                if (chapterCover.includes('Image/') && !chapterCover.startsWith('Image/')) {
                    chapterCover = chapterCover.substring(chapterCover.indexOf('Image/'));
                }
                if (!chapterCover.startsWith('./') && !chapterCover.startsWith('/') && !chapterCover.startsWith('http')) {
                    chapterCover = './' + chapterCover;
                }
            } else {
                chapterCover = null; // null = utiliser l'image du manhwa par dÃ©faut
            }

            // Nettoyer le chemin MHTML si on est en mode dÃ©veloppeur
            let mhtmlPath = chapter.chapter_pages; // Garder l'ancien par dÃ©faut
            if (isDeveloperMode()) {
                const mhtmlInput = document.getElementById('edit-chapter-mhtml').value.trim();
                if (mhtmlInput) {
                    mhtmlPath = mhtmlInput.replace(/\\/g, '/');
                    if (mhtmlPath.includes('Site/')) {
                        mhtmlPath = mhtmlPath.split('Site/')[1];
                    }
                    if (mhtmlPath.includes('chapitres/') && !mhtmlPath.startsWith('chapitres/')) {
                        mhtmlPath = mhtmlPath.substring(mhtmlPath.indexOf('chapitres/'));
                    }
                    if (!mhtmlPath.startsWith('./') && !mhtmlPath.startsWith('/') && !mhtmlPath.startsWith('http')) {
                        mhtmlPath = './' + mhtmlPath;
                    }
                }
            }

            // Mettre Ã  jour le chapitre
            const updatedChapter = {
                ...chapter,
                chapter_number: chapterNumber,
                chapter_title: chapterTitle,
                chapter_description: chapterDescription,
                chapter_season: chapterSeason || null,
                chapter_cover: chapterCover, // null ou chemin personnalisÃ©
                chapter_pages: mhtmlPath // Chemin MHTML (modifiable seulement en mode dÃ©veloppeur)
            };

            const result = await window.dataSdk.update(updatedChapter);

            if (result.isOk) {
                showNotification('Chapitre modifiÃ© avec succÃ¨s!', 'success');
                editChapterModal.classList.add('hidden');
                editChapterForm.reset();
                editChapterCoverPreview.classList.add('hidden');
                currentEditChapterId = null;
            } else {
                showNotification('Erreur lors de la modification', 'error');
            }

            submitText.classList.remove('hidden');
            loading.classList.add('hidden');
            submitBtn.disabled = false;
        });

        // Fonction pour ouvrir le modal de modification de chapitre
        function openEditChapterModal(chapterId) {
            const chapter = allChapters.find(ch => ch.__backendId === chapterId);
            if (!chapter) return;

            currentEditChapterId = chapterId;
            document.getElementById('edit-chapter-number').value = chapter.chapter_number;
            document.getElementById('edit-chapter-title').value = chapter.chapter_title;
            document.getElementById('edit-chapter-description').value = chapter.chapter_description || '';
            document.getElementById('edit-chapter-season').value = chapter.chapter_season || '';
            document.getElementById('edit-chapter-cover').value = chapter.chapter_cover ? chapter.chapter_cover.replace('./', '') : '';
            
            // Afficher le champ MHTML seulement en mode dÃ©veloppeur
            const mhtmlContainer = document.getElementById('edit-chapter-mhtml-container');
            if (isDeveloperMode()) {
                mhtmlContainer.classList.remove('hidden');
                document.getElementById('edit-chapter-mhtml').value = chapter.chapter_pages ? chapter.chapter_pages.replace('./', '') : '';
            } else {
                mhtmlContainer.classList.add('hidden');
            }
            
            // Afficher la prÃ©visualisation si une image personnalisÃ©e existe
            if (chapter.chapter_cover) {
                let previewPath = chapter.chapter_cover;
                if (!previewPath.startsWith('./') && !previewPath.startsWith('/') && !previewPath.startsWith('http')) {
                    previewPath = './' + previewPath;
                }
                editChapterPreviewImg.src = previewPath;
                editChapterCoverPreview.classList.remove('hidden');
            } else {
                editChapterCoverPreview.classList.add('hidden');
            }
            
            editChapterModal.classList.remove('hidden');
        }

        // ========== SYSTÃˆME DE SUIVI ==========
        let trackingList = [];
        
        // Charger les suivis depuis data.php (via globalData)
        function loadTrackingList() {
            try {
                trackingList = globalData.filter(item => item.type === 'tracking');
            } catch (error) {
                console.error('Erreur lors du chargement des suivis:', error);
                trackingList = [];
            }
        }
        
      // Sauvegarder les suivis via PHP
async function saveTrackingList() {
    for(const t of trackingList){
        await fetch(`save-tracking.php?action=save&id=${t.id}`, { // <-- changer update -> save
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify(t)
        });
    }
}

        
       async function addTracking(title, chapter, status, notes, season) {
    const id = 'tracking_' + Date.now() + '_' + Math.random(); // <-- gÃ©nÃ©rer un id unique
    const response = await fetch('save-tracking.php?action=save', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({id, title, chapter, status, notes, season})
    });
    const result = await response.json();

    if (result.success) {
        // Ajouter localement pour mise Ã  jour visuelle
        const tracking = {
            type: 'tracking',
            id,
            title,
            chapter: parseInt(chapter) || 0,
            status: status || 'en-cours',
            notes: notes || '',
            season: season || null,
            date_added: new Date().toISOString(),
            date_updated: new Date().toISOString()
        };
        trackingList.push(tracking);
        updateTrackingPage();
        return tracking;
    } else {
        showNotification(`Erreur : ${result.message}`, 'error');
        return null;
    }
}

        
        // Modifier un suivi
        async function updateTracking(id, title, chapter, status, notes, season) {
            const index = trackingList.findIndex(t => t.id === id);
            if (index !== -1) {
                trackingList[index] = {
                    ...trackingList[index],
                    title: title,
                    chapter: parseInt(chapter) || 0,
                    status: status || 'en-cours',
                    notes: notes || '',
                    season: season || null,
                    date_updated: new Date().toISOString()
                };
                await saveTrackingList();
                return true;
            }
            return false;
        }
        
     // Fonction qui supprime un suivi via PHP/MySQL
async function deleteTracking(id) {
    try {
        const response = await fetch(`save-tracking.php?action=delete&id=${id}`);
        const result = await response.json();

        if (result.success) {
            // Retirer localement pour mise Ã  jour visuelle
            trackingList = trackingList.filter(t => t.id !== id);
            updateTrackingPage(); // rafraÃ®chir la page suivi
            showNotification('Suivi dÃ©placÃ© dans la corbeille', 'success');
        } else {
            showNotification(`Erreur : ${result.message}`, 'error');
        }
    } catch (error) {
        console.error('Erreur lors de la suppression du suivi :', error);
        showNotification('Erreur rÃ©seau ou serveur', 'error');
    }
}

// Fonction appelÃ©e par le bouton
window.deleteTrackingItem = async function(id) {
    const tracking = trackingList.find(t => t.id === id);
    if (!tracking) return;
        
    await deleteTracking(id);
    updateTrackingPage();
    showNotification('Suivi dÃ©placÃ© dans la corbeille', 'success');
};



        
        // Augmenter le chapitre
        async function incrementChapter(id) {
            const tracking = trackingList.find(t => t.id === id);
            if (tracking) {
                tracking.chapter = (tracking.chapter || 0) + 1;
                tracking.date_updated = new Date().toISOString();
                await saveTrackingList();
                return true;
            }
            return false;
        }
        
        // Diminuer le chapitre
        async function decrementChapter(id) {
            const tracking = trackingList.find(t => t.id === id);
            if (tracking && tracking.chapter > 0) {
                tracking.chapter = tracking.chapter - 1;
                tracking.date_updated = new Date().toISOString();
                await saveTrackingList();
                return true;
            }
            return false;
        }
        
        // Mettre Ã  jour la page de suivi
        // Fonction de recherche et filtrage pour les suivis
        function filterAndSearchTracking() {
            const searchTerm = (document.getElementById('tracking-search')?.value || '').toLowerCase();
            const filterValue = document.getElementById('tracking-filter')?.value || 'all';
            
            let filtered = [...trackingList];
            
            // Recherche
            if (searchTerm) {
                filtered = filtered.filter(tracking => 
                    tracking.title.toLowerCase().includes(searchTerm) ||
                    tracking.notes?.toLowerCase().includes(searchTerm) ||
                    tracking.season?.toLowerCase().includes(searchTerm)
                );
            }
            
            // Filtrage
            switch(filterValue) {
                case 'en-cours':
                case 'fini':
                case 'en-pause':
                    filtered = filtered.filter(t => t.status === filterValue);
                    break;
                case 'az':
                    filtered.sort((a, b) => a.title.localeCompare(b.title));
                    break;
                case 'za':
                    filtered.sort((a, b) => b.title.localeCompare(a.title));
                    break;
            }
            
            return filtered;
        }
        
        function updateTrackingPage() {
            const trackingListContainer = document.getElementById('tracking-list');
            if (!trackingListContainer) return;
            
            trackingListContainer.innerHTML = '';
            
            const filteredTracking = filterAndSearchTracking();
            
            if (filteredTracking.length === 0) {
                trackingListContainer.innerHTML = `
                    <div class="text-center py-12 bg-gray-50 dark-mode:bg-gray-800 rounded-lg">
                        <svg class="w-24 h-24 mx-auto text-gray-300 dark-mode:text-gray-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                        </svg>
                        <h3 class="text-xl font-semibold text-gray-600 dark-mode:text-gray-300 mb-2">${trackingList.length === 0 ? 'Aucun suivi' : 'Aucun rÃ©sultat trouvÃ©'}</h3>
                        <p class="text-gray-500 dark-mode:text-gray-400 mb-4">${trackingList.length === 0 ? 'Commencez par ajouter un suivi de lecture!' : 'Essayez une autre recherche'}</p>
                    </div>
                `;
                return;
            }
            
            filteredTracking.forEach((tracking, index) => {
                // Couleurs adaptÃ©es au mode sombre
                const statusColors = isDarkMode ? {
                    'en-cours': 'bg-blue-600 text-blue-100',
                    'fini': 'bg-green-600 text-green-100',
                    'en-pause': 'bg-yellow-600 text-yellow-100'
                } : {
                    'en-cours': 'bg-blue-100 text-blue-700',
                    'fini': 'bg-green-100 text-green-700',
                    'en-pause': 'bg-yellow-100 text-yellow-700'
                };
                const statusLabels = {
                    'en-cours': 'En cours',
                    'fini': 'Fini',
                    'en-pause': 'En pause'
                };
                
                const item = document.createElement('div');
                item.className = 'bg-white rounded-lg shadow-md p-4 hover:shadow-lg transition-shadow card draggable-item cursor-move';
                item.draggable = true;
                item.dataset.trackingId = tracking.id;
                item.dataset.index = index;
                
                // Drag & Drop (cliquer-dÃ©placer)
                let isDragging = false;
                
                item.addEventListener('dragstart', (e) => {
                    // Ne pas activer si on clique sur un bouton
                    if (e.target.closest('button')) {
                        e.preventDefault();
                        return;
                    }
                    isDragging = true;
                    e.dataTransfer.setData('text/plain', tracking.id);
                    e.dataTransfer.effectAllowed = 'move';
                    item.classList.add('opacity-50');
                });
                
                item.addEventListener('dragend', () => {
                    item.classList.remove('opacity-50');
                    isDragging = false;
                });
                
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    item.classList.add('border-2', 'border-indigo-500');
                });
                
                item.addEventListener('dragleave', () => {
                    item.classList.remove('border-2', 'border-indigo-500');
                });
                
                item.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    item.classList.remove('border-2', 'border-indigo-500');
                    
                    const draggedId = e.dataTransfer.getData('text/plain');
                    if (draggedId === tracking.id) return;
                    
                    await reorderTracking(draggedId, tracking.id);
                });
                
                item.innerHTML = `
                    <div class="flex items-start justify-between">
                        <div class="flex-grow">
                            <h3 class="text-lg font-bold mb-2 text-gray-900 dark-mode:text-gray-100">${tracking.title}</h3>
                            <div class="flex items-center space-x-2 mb-2">
                                <span class="badge ${statusColors[tracking.status] || statusColors['en-cours']}">${statusLabels[tracking.status] || 'En cours'}</span>
                                ${tracking.season ? `<span class="badge bg-purple-100 text-purple-700 dark-mode:bg-purple-600 dark-mode:text-purple-100">S. ${tracking.season}</span>` : ''}
                            </div>
                            ${tracking.notes ? `<p class="text-sm text-gray-600 dark-mode:text-gray-300 mt-1">${tracking.notes}</p>` : ''}
                        </div>
                        <div class="flex items-center space-x-2">
                            <button onclick="decrementChapterTracking('${tracking.id}')" class="w-8 h-8 flex items-center justify-center bg-gray-100 hover:bg-gray-200 dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 rounded transition-colors text-gray-700 dark-mode:text-gray-200" title="Diminuer">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"></path>
                                </svg>
                            </button>
                            <span class="text-sm font-bold text-indigo-600 dark-mode:text-indigo-400 px-2 min-w-[3rem] text-center">Ch. ${tracking.chapter}</span>
                            <button onclick="incrementChapterTracking('${tracking.id}')" class="w-8 h-8 flex items-center justify-center bg-indigo-600 hover:bg-indigo-700 text-white rounded transition-colors" title="Augmenter">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                                </svg>
                            </button>
                            <button onclick="openEditTrackingModal('${tracking.id}')" class="p-2 text-blue-500 hover:bg-blue-50 dark-mode:hover:bg-blue-900 rounded-lg transition-colors" title="Modifier">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                                </svg>
                            </button>
                            <button onclick="deleteTrackingItem('${tracking.id}')" class="p-2 text-red-500 hover:bg-red-50 dark-mode:hover:bg-red-900 rounded-lg transition-colors" title="Supprimer">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                `;
                trackingListContainer.appendChild(item);
            });
        }
        
        // Fonctions globales pour les boutons
        window.incrementChapterTracking = async function(id) {
            if (await incrementChapter(id)) {
                updateTrackingPage();
                showNotification('Chapitre augmentÃ©!', 'success');
            }
        };
        
        window.decrementChapterTracking = async function(id) {
            if (await decrementChapter(id)) {
                updateTrackingPage();
                showNotification('Chapitre diminuÃ©!', 'success');
            }
        };
        
        window.deleteTrackingItem = async function(id) {
            const tracking = trackingList.find(t => t.id === id);
            if (!tracking) return;
            
            const confirmed = await showConfirmDialog(
                'Supprimer ce suivi?',
                'Le suivi sera dÃ©placÃ© dans la corbeille.'
            );
            if (confirmed) {
                // Ajouter Ã  la corbeille
                await addToTrash(tracking, 'tracking');
                
                await deleteTracking(id);
                updateTrackingPage();
                showNotification('Suivi dÃ©placÃ© dans la corbeille', 'success');
            }
        };
        
        window.openEditTrackingModal = function(id) {
            const tracking = trackingList.find(t => t.id === id);
            if (!tracking) return;
            
            document.getElementById('tracking-modal-title').textContent = 'Modifier le Suivi';
            document.getElementById('tracking-title').value = tracking.title;
            document.getElementById('tracking-chapter').value = tracking.chapter;
            document.getElementById('tracking-status').value = tracking.status;
            document.getElementById('tracking-notes').value = tracking.notes || '';
            document.getElementById('tracking-season').value = tracking.season || '';
            document.getElementById('tracking-form').dataset.trackingId = id;
            
            trackingModal.classList.remove('hidden');
        };
        
        
        // Gestionnaires pour le modal de suivi
        const trackingModal = document.getElementById('tracking-modal');
        const closeTrackingModal = document.getElementById('close-tracking-modal');
        const trackingForm = document.getElementById('tracking-form');
        const addTrackingBtn = document.getElementById('add-tracking-btn');
        
        addTrackingBtn.addEventListener('click', () => {
            document.getElementById('tracking-modal-title').textContent = 'Ajouter un Suivi';
            trackingForm.reset();
            trackingForm.dataset.trackingId = '';
            trackingModal.classList.remove('hidden');
        });
        
        closeTrackingModal.addEventListener('click', () => {
            trackingModal.classList.add('hidden');
            trackingForm.reset();
        });
        
        document.getElementById('cancel-tracking').addEventListener('click', () => {
            trackingModal.classList.add('hidden');
            trackingForm.reset();
        });
        
        trackingForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const title = document.getElementById('tracking-title').value.trim();
            const chapter = document.getElementById('tracking-chapter').value;
            const status = document.getElementById('tracking-status').value;
            const notes = document.getElementById('tracking-notes').value.trim();
            const season = document.getElementById('tracking-season').value.trim();
            const trackingId = trackingForm.dataset.trackingId;
            
            if (trackingId) {
                // Modifier
                if (await updateTracking(trackingId, title, chapter, status, notes, season)) {
                    showNotification('Suivi modifiÃ© avec succÃ¨s!', 'success');
                    trackingModal.classList.add('hidden');
                    trackingForm.reset();
                    updateTrackingPage();
                }
            } else {
                // Ajouter
                await addTracking(title, chapter, status, notes, season);
                showNotification('Suivi ajoutÃ© avec succÃ¨s!', 'success');
                trackingModal.classList.add('hidden');
                trackingForm.reset();
                updateTrackingPage();
            }
        });
        
        // Charger les suivis au dÃ©marrage
        loadTrackingList();
        
        // Event listeners pour la recherche et le filtrage
        const librarySearch = document.getElementById('library-search');
        const libraryFilter = document.getElementById('library-filter');
        const recentSearch = document.getElementById('recent-search');
        const recentFilter = document.getElementById('recent-filter');
        const favoritesSearch = document.getElementById('favorites-search');
        const favoritesFilter = document.getElementById('favorites-filter');
        const trackingSearch = document.getElementById('tracking-search');
        const trackingFilter = document.getElementById('tracking-filter');
        
        if (librarySearch) {
            librarySearch.addEventListener('input', () => updateLibraryPage());
            librarySearch.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') updateLibraryPage();
            });
        }
        if (libraryFilter) {
            libraryFilter.addEventListener('change', () => updateLibraryPage());
        }
        
        if (recentSearch) {
            recentSearch.addEventListener('input', () => updateRecentPage());
            recentSearch.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') updateRecentPage();
            });
        }
        if (recentFilter) {
            recentFilter.addEventListener('change', () => updateRecentPage());
        }
        
        if (favoritesSearch) {
            favoritesSearch.addEventListener('input', () => updateFavoritesPage());
            favoritesSearch.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') updateFavoritesPage();
            });
        }
        if (favoritesFilter) {
            favoritesFilter.addEventListener('change', () => updateFavoritesPage());
        }
        
        if (trackingSearch) {
            trackingSearch.addEventListener('input', () => updateTrackingPage());
            trackingSearch.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') updateTrackingPage();
            });
        }
        if (trackingFilter) {
            trackingFilter.addEventListener('change', () => updateTrackingPage());
        }
        
        const trashSearch = document.getElementById('trash-search');
        const trashFilter = document.getElementById('trash-filter');
        
        if (trashSearch) {
            trashSearch.addEventListener('input', () => updateTrashPage());
            trashSearch.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') updateTrashPage();
            });
        }
        if (trashFilter) {
            trashFilter.addEventListener('change', () => updateTrashPage());
        }
        
        // Fonction de recherche et filtrage pour les favoris
        function filterAndSearchFavorites() {
            const searchTerm = (document.getElementById('favorites-search')?.value || '').toLowerCase();
            const filterValue = document.getElementById('favorites-filter')?.value || 'recent';
            
            let filtered = allChapters.filter(ch => ch.is_favorite === true);
            
            // Recherche (inclut les descriptions)
            if (searchTerm) {
                filtered = filtered.filter(chapter => {
                    const manhwa = allManhwas.find(m => m.manhwa_id === chapter.manhwa_id);
                    return manhwa && (
                        manhwa.manhwa_title.toLowerCase().includes(searchTerm) ||
                        manhwa.manhwa_description?.toLowerCase().includes(searchTerm) ||
                        chapter.chapter_title?.toLowerCase().includes(searchTerm) ||
                        chapter.chapter_description?.toLowerCase().includes(searchTerm) ||
                        chapter.chapter_number.toString().includes(searchTerm)
                    );
                });
            }
            
            // Filtrage
            switch(filterValue) {
                case 'recent':
                    filtered.sort((a, b) => new Date(b.date_added) - new Date(a.date_added));
                    break;
                case 'oldest':
                    filtered.sort((a, b) => new Date(a.date_added) - new Date(b.date_added));
                    break;
                case 'az':
                    filtered.sort((a, b) => {
                        const manhwaA = allManhwas.find(m => m.manhwa_id === a.manhwa_id);
                        const manhwaB = allManhwas.find(m => m.manhwa_id === b.manhwa_id);
                        return (manhwaA?.manhwa_title || '').localeCompare(manhwaB?.manhwa_title || '');
                    });
                    break;
                case 'za':
                    filtered.sort((a, b) => {
                        const manhwaA = allManhwas.find(m => m.manhwa_id === a.manhwa_id);
                        const manhwaB = allManhwas.find(m => m.manhwa_id === b.manhwa_id);
                        return (manhwaB?.manhwa_title || '').localeCompare(manhwaA?.manhwa_title || '');
                    });
                    break;
            }
            
            return filtered;
        }
        
        // Page favoris
        function updateFavoritesPage() {
            const favoritesList = document.getElementById('favorites-list');
            if (!favoritesList) return;
            
            favoritesList.innerHTML = '';
            
            const favoriteChapters = filterAndSearchFavorites();
            
            if (favoriteChapters.length === 0) {
                favoritesList.innerHTML = `
                    <div class="text-center py-12">
                        <svg class="w-24 h-24 mx-auto text-gray-300 dark-mode:text-gray-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
                        </svg>
                        <h3 class="text-xl font-semibold text-gray-600 dark-mode:text-gray-300 mb-2">${allChapters.filter(ch => ch.is_favorite === true).length === 0 ? 'Aucun favori' : 'Aucun rÃ©sultat trouvÃ©'}</h3>
                        <p class="text-gray-500 dark-mode:text-gray-400 mb-4">${allChapters.filter(ch => ch.is_favorite === true).length === 0 ? 'Ajoutez des chapitres en favoris pour les retrouver facilement!' : 'Essayez une autre recherche'}</p>
                    </div>
                `;
                return;
            }
            
            favoriteChapters.forEach(chapter => {
                const manhwa = allManhwas.find(m => m.manhwa_id === chapter.manhwa_id);
                if (!manhwa) return;
                
                const chapterCover = chapter.chapter_cover || manhwa.manhwa_cover;
                
                const item = document.createElement('div');
                item.className = 'bg-white rounded-lg shadow-md p-4 flex items-center cursor-pointer hover:bg-gray-50 card chapter-item';
                item.onclick = () => readChapter(chapter.manhwa_id, chapter.chapter_number);
                item.innerHTML = `
                    <img src="${chapterCover}" alt="${manhwa.manhwa_title}" class="w-16 h-20 object-cover rounded mr-4">
                    <div class="flex-grow">
                        <h4 class="font-semibold text-gray-900 dark-mode:text-gray-100">${manhwa.manhwa_title}</h4>
                        <p class="text-sm text-gray-600 dark-mode:text-gray-300">Chapitre ${chapter.chapter_number}: ${chapter.chapter_title}</p>
                        ${chapter.chapter_season ? `<span class="inline-block mt-1 px-2 py-1 text-xs bg-purple-100 text-purple-700 dark-mode:bg-purple-600 dark-mode:text-purple-100 rounded">S. ${chapter.chapter_season}</span>` : ''}
                        <p class="text-xs text-gray-500 dark-mode:text-gray-400 mt-1">${formatDate(chapter.date_added)}</p>
                    </div>
                    <div class="flex items-center space-x-2 ml-4">
                        ${isDeveloperMode() ? `
                        <button onclick="event.stopPropagation(); openEditChapterModal('${chapter.__backendId}')" class="p-2 text-blue-500 hover:bg-blue-50 dark-mode:hover:bg-blue-900 rounded-lg transition-colors" title="Modifier ce chapitre">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                            </svg>
                        </button>
                        <button onclick="event.stopPropagation(); deleteChapter('${chapter.__backendId}')" class="p-2 text-red-500 hover:bg-red-50 dark-mode:hover:bg-red-900 rounded-lg transition-colors" title="Supprimer ce chapitre">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                            </svg>
                        </button>
                        ` : ''}
                        <button onclick="event.stopPropagation(); toggleFavorite('${chapter.__backendId}')" class="p-2 ${chapter.is_favorite ? 'text-red-500' : 'text-gray-400'} hover:bg-gray-50 dark-mode:hover:bg-gray-700 rounded-lg transition-colors" title="${chapter.is_favorite ? 'Retirer des favoris' : 'Ajouter aux favoris'}">
                            <svg class="w-5 h-5" fill="${chapter.is_favorite ? '#ef4444' : 'none'}" stroke="${chapter.is_favorite ? 'none' : 'currentColor'}" stroke-width="${chapter.is_favorite ? '0' : '2'}" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
                            </svg>
                        </button>
                    </div>
                `;
                favoritesList.appendChild(item);
            });
        }
        
        // Fonction pour ajouter/retirer un chapitre des favoris (FONCTIONNE EN LIGNE ET LOCAL)
        async function toggleFavorite(chapterId) {
            console.log('â¤ï¸ Toggle favorite pour chapitre:', chapterId);
            const chapter = allChapters.find(ch => ch.__backendId === chapterId);
            if (!chapter) {
                console.error('âŒ Chapitre non trouvÃ©:', chapterId);
                return;
            }
            
            // Mettre Ã  jour immÃ©diatement dans la liste locale
            const newFavoriteStatus = !chapter.is_favorite;
            chapter.is_favorite = newFavoriteStatus;
            
            // Mettre Ã  jour aussi dans allChapters
            const chapterIndex = allChapters.findIndex(ch => ch.__backendId === chapterId);
            if (chapterIndex !== -1) {
                allChapters[chapterIndex].is_favorite = newFavoriteStatus;
            }
            
            // Mettre Ã  jour l'UI immÃ©diatement
            updateAllPages();
            
            // Sauvegarder (en ligne: localStorage, en local: data.php)
            if (isDeveloperMode()) {
                // En mode dÃ©veloppeur, sauvegarder dans data.php
                const updatedChapter = {
                    ...chapter,
                    is_favorite: newFavoriteStatus
                };
                const result = await window.dataSdk.update(updatedChapter);
                if (result.isOk) {
                    showNotification(newFavoriteStatus ? 'AjoutÃ© aux favoris â¤ï¸' : 'RetirÃ© des favoris', 'success');
                } else {
                    console.error('âŒ Erreur lors de la mise Ã  jour:', result.error);
                }
            } else {
                // En ligne, sauvegarder dans localStorage pour la synchronisation
                const favorites = JSON.parse(localStorage.getItem('favorites') || '[]');
                if (newFavoriteStatus) {
                    if (!favorites.includes(chapterId)) {
                        favorites.push(chapterId);
                    }
                } else {
                    const index = favorites.indexOf(chapterId);
                    if (index > -1) {
                        favorites.splice(index, 1);
                    }
                }
                localStorage.setItem('favorites', JSON.stringify(favorites));
                showNotification(newFavoriteStatus ? 'AjoutÃ© aux favoris â¤ï¸' : 'RetirÃ© des favoris', 'success');
            }
        }
        
        window.toggleFavorite = toggleFavorite;

        // Fonction de recherche et filtrage pour la corbeille
        function filterAndSearchTrash() {
            const searchTerm = (document.getElementById('trash-search')?.value || '').toLowerCase();
            const filterValue = document.getElementById('trash-filter')?.value || 'all';
            
            let filtered = globalData.filter(item => item.type === 'trash');
            
            // Recherche
            if (searchTerm) {
                filtered = filtered.filter(trashItem => {
                    if (trashItem.trash_type === 'manhwa') {
                        return trashItem.original_data.manhwa_title?.toLowerCase().includes(searchTerm);
                    } else if (trashItem.trash_type === 'chapter') {
                        return trashItem.original_data.chapter_title?.toLowerCase().includes(searchTerm) ||
                               trashItem.original_data.chapter_number?.toString().includes(searchTerm);
                    } else if (trashItem.trash_type === 'tracking') {
                        return trashItem.original_data.title?.toLowerCase().includes(searchTerm);
                    }
                    return false;
                });
            }
            
            // Filtrage
            switch(filterValue) {
                case 'manhwa':
                case 'chapter':
                case 'tracking':
                    filtered = filtered.filter(item => item.trash_type === filterValue);
                    break;
                case 'recent':
                    filtered.sort((a, b) => new Date(b.deleted_at) - new Date(a.deleted_at));
                    break;
                case 'oldest':
                    filtered.sort((a, b) => new Date(a.deleted_at) - new Date(b.deleted_at));
                    break;
            }
            
            return filtered;
        }
        
        // Page corbeille
        function updateTrashPage() {
            const trashList = document.getElementById('trash-list');
            if (!trashList) return;
            
            trashList.innerHTML = '';
            
            const trashItems = filterAndSearchTrash();
            const allTrashItems = globalData.filter(item => item.type === 'trash');
            
            if (trashItems.length === 0) {
                trashList.innerHTML = `
                    <div class="text-center py-12">
                        <svg class="w-24 h-24 mx-auto text-gray-300 dark-mode:text-gray-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                        <h3 class="text-xl font-semibold text-gray-600 dark-mode:text-gray-300 mb-2">${allTrashItems.length === 0 ? 'Corbeille vide' : 'Aucun rÃ©sultat trouvÃ©'}</h3>
                        <p class="text-gray-500 dark-mode:text-gray-400 mb-4">${allTrashItems.length === 0 ? 'Les Ã©lÃ©ments supprimÃ©s apparaÃ®tront ici' : 'Essayez une autre recherche'}</p>
                    </div>
                `;
                return;
            }
            
            trashItems.forEach(trashItem => {
                const item = document.createElement('div');
                item.className = 'bg-white rounded-lg shadow-md p-4 flex items-center justify-between card';
                
                let title = '';
                let subtitle = '';
                let icon = '';
                
                if (trashItem.trash_type === 'manhwa') {
                    title = trashItem.original_data.manhwa_title;
                    subtitle = 'Manhwa';
                    icon = 'ðŸ“š';
                } else if (trashItem.trash_type === 'chapter') {
                    const manhwa = allManhwas.find(m => m.manhwa_id === trashItem.original_data.manhwa_id);
                    title = `Chapitre ${trashItem.original_data.chapter_number}: ${trashItem.original_data.chapter_title}`;
                    subtitle = manhwa ? `de ${manhwa.manhwa_title}` : 'Chapitre';
                    icon = 'ðŸ“–';
                } else if (trashItem.trash_type === 'tracking') {
                    title = trashItem.original_data.title;
                    subtitle = 'Suivi de lecture';
                    icon = 'ðŸ“Š';
                }
                
                item.innerHTML = `
                    <div class="flex items-center flex-grow">
                        <span class="text-2xl mr-4">${icon}</span>
                        <div>
                            <h4 class="font-semibold text-gray-900 dark-mode:text-gray-100">${title}</h4>
                            <p class="text-sm text-gray-600 dark-mode:text-gray-300">${subtitle}</p>
                            <p class="text-xs text-gray-500 dark-mode:text-gray-400 mt-1">SupprimÃ© le ${formatDate(trashItem.deleted_at)}</p>
                        </div>
                    </div>
                    <div class="flex space-x-2">
                        <button onclick="restoreFromTrash('${trashItem.id}')" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors" title="Restaurer">
                            Restaurer
                        </button>
                        <button onclick="deletePermanentlyFromTrash('${trashItem.id}')" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors" title="Supprimer dÃ©finitivement">
                            Supprimer dÃ©finitivement
                        </button>
                    </div>
                `;
                trashList.appendChild(item);
            });
        }
        
 // ...existing code...
window.restoreFromTrash = async function(trashId) {
    const confirmed = await showConfirmDialog(
        'Restaurer cet Ã©lÃ©ment ?',
        'L\'Ã©lÃ©ment sera remis dans vos suivis.'
    );
    if (!confirmed) return;

    if (!trashId) {
        showNotification('Erreur : ID manquant pour la restauration', 'error');
        return;
    }

    try {
        const response = await fetch('save-data.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'restore',
                item: { id: trashId, trash_type: 'tracking' }
            })
        });

        // Parser la rÃ©ponse JSON en toute sÃ©curitÃ©
        const result = await response.json();

        if (result.success) {
            showNotification('Ã‰lÃ©ment restaurÃ© avec succÃ¨s !', 'success');

            // Retirer de la corbeille localement et ajouter aux suivis
            const restoredItemIndex = globalData.findIndex(item => item.id === trashId);
            if (restoredItemIndex !== -1) {
                const restored = globalData[restoredItemIndex];
                restored.type = 'tracking';
                trackingList.push(restored);
                globalData.splice(restoredItemIndex, 1);
            }

            updateAllPages();
            updateTrashPage();

            if (isDeveloperMode()) {
                scheduleAutoSave(globalData);
            } else {
                await saveDataToFileAuto(globalData);
            }
        } else {
            showNotification(`Erreur : ${result.message}`, 'error');
        }
    } catch (err) {
        console.error(err);
        showNotification('Erreur rÃ©seau ou serveur', 'error');
    }
};
// ...existing code...


      window.deletePermanentlyFromTrash = async function(trashId) {
    const confirmed = await showConfirmDialog(
        'Supprimer dÃ©finitivement ?',
        'Cette action est irrÃ©versible.'
    );
    if (!confirmed) return;

    try {
        const response = await fetch(`save-tracking.php?action=delete_permanent&id=${trashId}`);
        const result = await response.json();
        if (result.success) {
            showNotification('Ã‰lÃ©ment supprimÃ© dÃ©finitivement', 'success');

            // Retirer localement pour mettre Ã  jour l'affichage
            globalData = globalData.filter(item => item.id !== trashId);

            // Mettre Ã  jour l'affichage
            updateAllPages();

        } else {
            showNotification(`Erreur : ${result.message}`, 'error');
        }
    } catch (err) {
        console.error(err);
        showNotification('Erreur rÃ©seau ou serveur', 'error');
    }
};

        // Mise Ã  jour de toutes les pages
        function updateAllPages() {
            updateHomePage();
            updateLibraryPage();
            updateRecentPage();
            updateFavoritesPage();
            updateTrackingPage();
            updateTrashPage();
            updateGalleryPage();
            updateStatistics();
            
            // Si on est sur la page de dÃ©tail d'un manhwa, la mettre Ã  jour aussi
            const manhwaDetailPage = document.getElementById('manhwa-detail-page');
            if (manhwaDetailPage && !manhwaDetailPage.classList.contains('hidden') && currentManhwaId) {
                showManhwaDetail(currentManhwaId);
            }
            
            // Sauvegarder la page actuelle (sauf si c'est home)
            const currentPage = document.querySelector('.page-content:not(.hidden)')?.id;
            if (currentPage) {
                const pageName = currentPage.replace('-page', '').replace('page-', '');
                if (pageName !== 'home') {
                    localStorage.setItem('currentPage', pageName);
                }
            }
        }
        
        // Page Galerie
       
        
        async function loadGalleryImages() {
            try {
                if (isDeveloperMode()) {
                    // En mode dÃ©veloppeur, scanner le dossier gallery via PHP
                    const response = await fetch('./scan-gallery.php?t=' + Date.now());
                    if (response.ok) {
                        const data = await response.json();
                        galleryImages = data.images || [];
                    } else {
                        console.error('Erreur scan gallery:', response.status);
                        galleryImages = [];
                    }
                } else {
                    // En ligne, charger depuis un fichier JSON statique (Ã  crÃ©er manuellement ou via GitHub Actions)
                    // Pour l'instant, essayer de charger gallery-list.json
                    try {
                        const response = await fetch('./gallery-list.json?t=' + Date.now());
                        if (response.ok) {
                            const data = await response.json();
                            galleryImages = data.images || [];
                        } else {
                            // Si le fichier n'existe pas, essayer de scanner via une API alternative
                            // Pour l'instant, on laisse vide
                            galleryImages = [];
                            console.warn('âš ï¸ gallery-list.json non trouvÃ©. CrÃ©ez ce fichier avec la liste des images.');
                        }
                    } catch (err) {
                        console.error('Erreur chargement gallery:', err);
                        galleryImages = [];
                    }
                }
                
                // Shuffle automatique Ã  chaque chargement
                if (galleryImages.length > 0) {
                    for (let i = galleryImages.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [galleryImages[i], galleryImages[j]] = [galleryImages[j], galleryImages[i]];
                    }
                }
            } catch (error) {
                console.error('Erreur lors du chargement de la galerie:', error);
                galleryImages = [];
            }
            updateGalleryPage();
        }
        
        function updateGalleryPage() {
            const galleryGrid = document.getElementById('gallery-grid');
            if (!galleryGrid) return;
            
            galleryGrid.innerHTML = '';
            
            if (galleryImages.length === 0) {
                galleryGrid.innerHTML = `
                    <div class="col-span-full text-center py-12">
                        <p class="text-gray-500 dark-mode:text-gray-300">Aucune image dans la galerie</p>
                        <p class="text-sm text-gray-400 dark-mode:text-gray-500 mt-2">Ajoutez des images dans le dossier gallery/</p>
                    </div>
                `;
                return;
            }
            
            galleryImages.forEach((image, index) => {
                const item = document.createElement('div');
                item.className = 'break-inside-avoid mb-4 bg-white rounded-lg shadow-md overflow-hidden cursor-move draggable-gallery-item';
                item.draggable = true;
                item.dataset.imageIndex = index;
                
                // Drag & Drop
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', index.toString());
                    item.classList.add('opacity-50');
                });
                
                item.addEventListener('dragend', () => {
                    item.classList.remove('opacity-50');
                });
                
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    item.classList.add('border-2', 'border-indigo-500');
                });
                
                item.addEventListener('dragleave', () => {
                    item.classList.remove('border-2', 'border-indigo-500');
                });
                
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    item.classList.remove('border-2', 'border-indigo-500');
                    
                    const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    if (draggedIndex === index) return;
                    
                    // RÃ©organiser
                    const temp = galleryImages[draggedIndex];
                    galleryImages[draggedIndex] = galleryImages[index];
                    galleryImages[index] = temp;
                    
                    updateGalleryPage();
                });
                
                item.innerHTML = `
                    <img src="${image.path}" alt="${image.name}" class="w-full h-auto object-cover rounded-lg cursor-pointer hover:opacity-90 transition-opacity" loading="lazy" onclick="window.open('${image.path}', '_blank')">
                `;
                
                galleryGrid.appendChild(item);
            });
        }
        
        function shuffleGallery() {
            // MÃ©langer alÃ©atoirement
            for (let i = galleryImages.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [galleryImages[i], galleryImages[j]] = [galleryImages[j], galleryImages[i]];
            }
            updateGalleryPage();
        }
        
        window.shuffleGallery = shuffleGallery;

        // Mise Ã  jour des statistiques
        function updateStatistics() {
            document.getElementById('stats-manhwas').textContent = allManhwas.length;
            document.getElementById('stats-chapters').textContent = allChapters.length;
        }

        // Page d'accueil
        function updateHomePage() {
            const continueReadingContainer = document.getElementById('continue-reading');
            const latestChaptersContainer = document.getElementById('latest-chapters');

            continueReadingContainer.innerHTML = '';
            latestChaptersContainer.innerHTML = '';

            if (allManhwas.length === 0) {
                continueReadingContainer.innerHTML = `
                    <div class="col-span-full text-center py-12">
                        <svg class="w-24 h-24 mx-auto text-gray-300 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
                        </svg>
                        <h3 class="text-xl font-semibold text-gray-600 dark-mode:text-gray-200 mb-2">Aucun manhwa dans votre bibliothÃ¨que</h3>
                        <p class="text-gray-500 dark-mode:text-gray-300 mb-4">${isDeveloperMode() ? 'Commencez par ajouter votre premier manhwa!' : 'La bibliothÃ¨que est vide. Les manhwas doivent Ãªtre ajoutÃ©s en mode dÃ©veloppeur (localhost).'}</p>
                        ${isDeveloperMode() ? `
                        <button onclick="openAddManhwaModal()" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700">
                            Ajouter un Manhwa
                        </button>
                        ` : ''}
                    </div>
                `;
                return;
            }

            // Afficher les manhwas avec progression
            allManhwas.forEach(manhwa => {
                const chapters = allChapters.filter(ch => ch.manhwa_id === manhwa.manhwa_id);
                const totalChapters = chapters.length;
                const lastChapter = chapters.sort((a, b) => b.chapter_number - a.chapter_number)[0];

                const card = document.createElement('div');
                card.className = 'card bg-white rounded-lg shadow-md overflow-hidden cursor-pointer';
                card.onclick = () => showManhwaDetail(manhwa.manhwa_id);
                card.innerHTML = `
                    <img src="${manhwa.manhwa_cover}" alt="${manhwa.manhwa_title}" class="manhwa-cover">
                    <div class="p-4">
                        <h3 class="font-bold text-lg mb-2">${manhwa.manhwa_title}</h3>
                        ${lastChapter ? `
                            <p class="text-sm text-gray-600 mb-2">Dernier chapitre: ${lastChapter.chapter_number}</p>
                            <span class="badge bg-indigo-100 text-indigo-600">${totalChapters} chapitres</span>
                        ` : `
                            <p class="text-sm text-gray-600 dark-mode:text-blue-200">Aucun chapitre disponible</p>
                        `}
                    </div>
                `;
                continueReadingContainer.appendChild(card);
            });

            // Afficher les derniers chapitres
            const sortedChapters = [...allChapters].sort((a, b) => 
                new Date(b.date_added) - new Date(a.date_added)
            ).slice(0, 10);

            sortedChapters.forEach(chapter => {
                const manhwa = allManhwas.find(m => m.manhwa_id === chapter.manhwa_id);
                if (!manhwa) return;

                const chapterItem = document.createElement('div');
                chapterItem.className = 'chapter-item bg-white rounded-lg shadow-md p-4 flex items-center cursor-pointer';
                chapterItem.onclick = () => readChapter(chapter.manhwa_id, chapter.chapter_number);
                // Utiliser l'image de couverture du chapitre si elle existe, sinon celle du manhwa
                const chapterCover = chapter.chapter_cover || manhwa.manhwa_cover;
                chapterItem.innerHTML = `
                    <img src="${chapterCover}" alt="${manhwa.manhwa_title}" class="w-16 h-20 object-cover rounded mr-4">
                    <div class="flex-grow">
                        <h4 class="font-semibold">${manhwa.manhwa_title}</h4>
                        <p class="text-sm text-gray-600">Chapitre ${chapter.chapter_number}: ${chapter.chapter_title}</p>
                        <p class="text-xs text-gray-500 mt-1">${formatDate(chapter.date_added)}</p>
                    </div>
                    <svg class="w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                `;
                latestChaptersContainer.appendChild(chapterItem);
            });
        }

        // Fonction pour ouvrir le modal d'ajout de manhwa
        function openAddManhwaModal() {
            // VÃ©rifier le mode dÃ©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }
            
            addManhwaModal.classList.remove('hidden');
        }

        // Fonction de recherche et filtrage pour la bibliothÃ¨que
        function filterAndSearchLibrary() {
            const searchTerm = (document.getElementById('library-search')?.value || '').toLowerCase();
            const filterValue = document.getElementById('library-filter')?.value || 'all';
            
            let filtered = [...allManhwas];
            
            // Recherche (inclut les descriptions)
            if (searchTerm) {
                filtered = filtered.filter(manhwa => {
                    const manhwaMatch = manhwa.manhwa_title.toLowerCase().includes(searchTerm) ||
                                       manhwa.manhwa_description?.toLowerCase().includes(searchTerm);
                    // Chercher aussi dans les chapitres de ce manhwa
                    const chapters = allChapters.filter(ch => ch.manhwa_id === manhwa.manhwa_id);
                    const chapterMatch = chapters.some(ch => 
                        ch.chapter_title?.toLowerCase().includes(searchTerm) ||
                        ch.chapter_description?.toLowerCase().includes(searchTerm) ||
                        ch.chapter_number.toString().includes(searchTerm)
                    );
                    return manhwaMatch || chapterMatch;
                });
            }
            
            // Filtrage
            switch(filterValue) {
                case 'az':
                    filtered.sort((a, b) => a.manhwa_title.localeCompare(b.manhwa_title));
                    break;
                case 'za':
                    filtered.sort((a, b) => b.manhwa_title.localeCompare(a.manhwa_title));
                    break;
                case 'recent':
                    filtered.sort((a, b) => new Date(b.date_added) - new Date(a.date_added));
                    break;
                case 'oldest':
                    filtered.sort((a, b) => new Date(a.date_added) - new Date(b.date_added));
                    break;
            }
            
            return filtered;
        }

        // Page bibliothÃ¨que
        function updateLibraryPage() {
            const libraryGrid = document.getElementById('library-grid');
            libraryGrid.innerHTML = '';

            if (allManhwas.length === 0) {
                libraryGrid.innerHTML = `
                    <div class="col-span-full text-center py-12">
                        <p class="text-gray-500 dark-mode:text-gray-400">Votre bibliothÃ¨que est vide</p>
                    </div>
                `;
                return;
            }

            const filteredManhwas = filterAndSearchLibrary();
            
            if (filteredManhwas.length === 0) {
                libraryGrid.innerHTML = `
                    <div class="col-span-full text-center py-12">
                        <p class="text-gray-500 dark-mode:text-gray-400">Aucun rÃ©sultat trouvÃ©</p>
                    </div>
                `;
                return;
            }

            filteredManhwas.forEach((manhwa, index) => {
                const chapters = allChapters.filter(ch => ch.manhwa_id === manhwa.manhwa_id);
                const card = document.createElement('div');
                card.className = 'card bg-white rounded-lg shadow-md overflow-hidden cursor-move draggable-item';
                card.draggable = true;
                card.dataset.manhwaId = manhwa.__backendId;
                card.dataset.index = index;
                // Toujours activer le drag & drop, mÃªme en ligne
                
                // Drag & Drop (cliquer-dÃ©placer)
                let clickTimeout = null;
                
                card.addEventListener('mousedown', (e) => {
                    // Ne pas activer le drag si on clique sur un bouton
                    if (e.target.closest('button')) {
                        return;
                    }
                    // Si on clique sur le contenu (img, h3, p, span), ouvrir le dÃ©tail aprÃ¨s un court dÃ©lai
                    if (e.target.tagName === 'IMG' || e.target.tagName === 'H3' || e.target.tagName === 'P' || e.target.tagName === 'SPAN') {
                        clickTimeout = setTimeout(() => {
                            showManhwaDetail(manhwa.manhwa_id);
                        }, 200);
                        return;
                    }
                });
                
                card.addEventListener('dragstart', (e) => {
                    // Annuler le clic si on commence Ã  drag
                    if (clickTimeout) {
                        clearTimeout(clickTimeout);
                        clickTimeout = null;
                    }
                    e.dataTransfer.setData('text/plain', manhwa.__backendId);
                    e.dataTransfer.effectAllowed = 'move';
                    card.classList.add('opacity-50');
                });
                
                card.addEventListener('dragend', () => {
                    card.classList.remove('opacity-50');
                });
                
                card.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    card.classList.add('border-2', 'border-indigo-500');
                });
                
                card.addEventListener('dragleave', () => {
                    card.classList.remove('border-2', 'border-indigo-500');
                });
                
                card.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    card.classList.remove('border-2', 'border-indigo-500');
                    
                    const draggedId = e.dataTransfer.getData('text/plain');
                    if (draggedId === manhwa.__backendId) return;
                    
                    await reorderManhwas(draggedId, manhwa.__backendId);
                });
                
                card.innerHTML = `
                    <img src="${manhwa.manhwa_cover}" alt="${manhwa.manhwa_title}" class="manhwa-cover">
                    <div class="p-4">
                        <h3 class="font-bold text-lg mb-2">${manhwa.manhwa_title}</h3>
                        <p class="text-sm text-gray-600 mb-2 line-clamp-2">${manhwa.manhwa_description}</p>
                        <span class="badge bg-indigo-100 text-indigo-600">${chapters.length} chapitres</span>
                    </div>
                `;
                libraryGrid.appendChild(card);
            });
        }

        // Fonction de recherche et filtrage pour les rÃ©cents
        function filterAndSearchRecent() {
            const searchTerm = (document.getElementById('recent-search')?.value || '').toLowerCase();
            const filterValue = document.getElementById('recent-filter')?.value || 'recent';
            
            let filtered = [...allChapters];
            
            // Recherche (inclut les descriptions)
            if (searchTerm) {
                filtered = filtered.filter(chapter => {
                    const manhwa = allManhwas.find(m => m.manhwa_id === chapter.manhwa_id);
                    return manhwa && (
                        manhwa.manhwa_title.toLowerCase().includes(searchTerm) ||
                        manhwa.manhwa_description?.toLowerCase().includes(searchTerm) ||
                        chapter.chapter_title?.toLowerCase().includes(searchTerm) ||
                        chapter.chapter_description?.toLowerCase().includes(searchTerm) ||
                        chapter.chapter_number.toString().includes(searchTerm)
                    );
                });
            }
            
            // Filtrage
            switch(filterValue) {
                case 'recent':
                    filtered.sort((a, b) => new Date(b.date_added) - new Date(a.date_added));
                    break;
                case 'oldest':
                    filtered.sort((a, b) => new Date(a.date_added) - new Date(b.date_added));
                    break;
                case 'az':
                    filtered.sort((a, b) => {
                        const manhwaA = allManhwas.find(m => m.manhwa_id === a.manhwa_id);
                        const manhwaB = allManhwas.find(m => m.manhwa_id === b.manhwa_id);
                        return (manhwaA?.manhwa_title || '').localeCompare(manhwaB?.manhwa_title || '');
                    });
                    break;
                case 'za':
                    filtered.sort((a, b) => {
                        const manhwaA = allManhwas.find(m => m.manhwa_id === a.manhwa_id);
                        const manhwaB = allManhwas.find(m => m.manhwa_id === b.manhwa_id);
                        return (manhwaB?.manhwa_title || '').localeCompare(manhwaA?.manhwa_title || '');
                    });
                    break;
            }
            
            return filtered.slice(0, 50);
        }

        // Page rÃ©cents
        function updateRecentPage() {
            const recentList = document.getElementById('recent-list');
            recentList.innerHTML = '';

            const recentChapters = filterAndSearchRecent();

            if (recentChapters.length === 0) {
                recentList.innerHTML = `
                    <div class="text-center py-12">
                        <p class="text-gray-500 dark-mode:text-gray-400">${allChapters.length === 0 ? 'Aucun historique de lecture' : 'Aucun rÃ©sultat trouvÃ©'}</p>
                    </div>
                `;
                return;
            }

            recentChapters.forEach(chapter => {
                const manhwa = allManhwas.find(m => m.manhwa_id === chapter.manhwa_id);
                if (!manhwa) return;

                // Utiliser l'image de couverture du chapitre si elle existe, sinon celle du manhwa
                const chapterCover = chapter.chapter_cover || manhwa.manhwa_cover;

                const item = document.createElement('div');
                item.className = 'bg-white rounded-lg shadow-md p-4 flex items-center cursor-pointer hover:bg-gray-50 card chapter-item';
                item.onclick = () => readChapter(chapter.manhwa_id, chapter.chapter_number);
                item.innerHTML = `
                    <img src="${chapterCover}" alt="${manhwa.manhwa_title}" class="w-16 h-20 object-cover rounded mr-4">
                    <div class="flex-grow">
                        <h4 class="font-semibold text-gray-900 dark-mode:text-gray-100">${manhwa.manhwa_title}</h4>
                        <p class="text-sm text-gray-600 dark-mode:text-gray-300">Chapitre ${chapter.chapter_number}: ${chapter.chapter_title}</p>
                        <p class="text-xs text-gray-500 dark-mode:text-gray-400 mt-1">${formatDate(chapter.date_added)}</p>
                    </div>
                `;
                // Ajouter boutons (modifier, supprimer, favori) en mode dÃ©veloppeur
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'flex items-center space-x-2 ml-4';
                
                if (isDeveloperMode()) {
                    const editBtn = document.createElement('button');
                    editBtn.className = 'p-2 text-blue-500 hover:bg-blue-50 dark-mode:hover:bg-blue-900 rounded-lg transition-colors';
                    editBtn.title = 'Modifier ce chapitre';
                    editBtn.onclick = (e) => {
                        e.stopPropagation();
                        openEditChapterModal(chapter.__backendId);
                    };
                    editBtn.innerHTML = `
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                        </svg>
                    `;
                    actionsDiv.appendChild(editBtn);
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'p-2 text-red-500 hover:bg-red-50 dark-mode:hover:bg-red-900 rounded-lg transition-colors';
                    deleteBtn.title = 'Supprimer ce chapitre';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteChapter(chapter.__backendId);
                    };
                    deleteBtn.innerHTML = `
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                    `;
                    actionsDiv.appendChild(deleteBtn);
                }
                
                const favoriteBtn = document.createElement('button');
                favoriteBtn.className = `p-2 ${chapter.is_favorite ? 'text-red-500' : 'text-gray-400'} hover:bg-gray-50 dark-mode:hover:bg-gray-700 rounded-lg transition-colors`;
                favoriteBtn.title = chapter.is_favorite ? 'Retirer des favoris' : 'Ajouter aux favoris';
                favoriteBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleFavorite(chapter.__backendId);
                };
                favoriteBtn.innerHTML = `
                    <svg class="w-5 h-5" fill="${chapter.is_favorite ? '#ef4444' : 'none'}" stroke="currentColor" stroke-width="${chapter.is_favorite ? '0' : '2'}" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
                    </svg>
                `;
                actionsDiv.appendChild(favoriteBtn);
                
                item.appendChild(actionsDiv);
                
                recentList.appendChild(item);
            });
        }

        // Afficher le dÃ©tail d'un manhwa
        function showManhwaDetail(manhwaId) {
            currentManhwaId = manhwaId;
            const manhwa = allManhwas.find(m => m.manhwa_id === manhwaId);
            if (!manhwa) return;

            const chapters = allChapters
                .filter(ch => ch.manhwa_id === manhwaId)
                .sort((a, b) => a.chapter_number - b.chapter_number);

            const detailContent = document.getElementById('manhwa-detail-content');
            detailContent.innerHTML = `
                <div class="grid md:grid-cols-3 gap-8 mb-8">
                    <div>
                        <img src="${manhwa.manhwa_cover}" alt="${manhwa.manhwa_title}" class="w-full rounded-lg shadow-lg">
                    </div>
                    <div class="md:col-span-2">
                        <h1 class="text-4xl font-bold mb-4">${manhwa.manhwa_title}</h1>
                        <p class="text-gray-600 mb-6">${manhwa.manhwa_description}</p>
                        <div class="flex items-center space-x-4 mb-6">
                            <span class="badge bg-indigo-100 text-indigo-600">${chapters.length} chapitres</span>
                            <span class="badge bg-green-100 text-green-600">En cours</span>
                        </div>
                        <div class="flex space-x-3">
                            ${isDeveloperMode() ? `
                            <button type="button" onclick="event.stopPropagation(); openEditManhwaModal('${manhwa.__backendId}')" class="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 flex items-center">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                                </svg>
                                Modifier
                            </button>
                            ` : ''}
                            ${isDeveloperMode() ? `
                            <button type="button" onclick="event.stopPropagation(); openAddChapterModal()" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 flex items-center">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                                </svg>
                                Ajouter un Chapitre
                            </button>
                            <button type="button" onclick="event.stopPropagation(); deleteManhwa('${manhwa.__backendId}')" class="bg-red-600 text-white px-6 py-3 rounded-lg hover:bg-red-700 flex items-center">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                </svg>
                                Supprimer ce Manhwa
                            </button>
                            ` : ''}
                        </div>
                    </div>
                </div>

                <h2 class="text-2xl font-bold mb-4">Liste des Chapitres</h2>
                <div class="space-y-3">
                    ${chapters.length === 0 ? `
                        <div class="bg-gray-100 dark-mode:bg-gray-900 rounded-lg p-8 text-center border border-gray-300 dark-mode:border-gray-700">
                            <p class="text-gray-800 dark-mode:text-blue-200 text-lg font-medium">Aucun chapitre disponible. Ajoutez-en un!</p>
                        </div>
                    ` : chapters.map(chapter => {
                        // Utiliser l'image de couverture du chapitre si elle existe, sinon celle du manhwa
                        const chapterCover = chapter.chapter_cover || manhwa.manhwa_cover;
                        return `
                        <div class="chapter-item bg-white rounded-lg shadow-md p-4 flex items-center">
                            <img src="${chapterCover}" alt="${manhwa.manhwa_title}" class="w-12 h-16 object-cover rounded mr-4">
                            <div class="flex-shrink-0 w-12 h-12 bg-indigo-100 rounded-lg flex items-center justify-center mr-4">
                                <span class="font-bold text-indigo-600">${chapter.chapter_number}</span>
                            </div>
                            <div class="flex-grow cursor-pointer" onclick="readChapter('${manhwaId}', ${chapter.chapter_number})">
                                <h3 class="font-semibold">Chapitre ${chapter.chapter_number}: ${chapter.chapter_title}</h3>
                                ${chapter.chapter_description ? `<p class="text-sm text-gray-600 dark-mode:text-gray-300">${chapter.chapter_description}</p>` : ''}
                                ${chapter.chapter_season ? `<span class="inline-block mt-1 px-2 py-1 text-xs bg-purple-100 text-purple-700 dark-mode:bg-purple-600 dark-mode:text-purple-100 rounded">S. ${chapter.chapter_season}</span>` : ''}
                                <p class="text-xs text-gray-500 dark-mode:text-gray-400 mt-1">${formatDate(chapter.date_added)}</p>
                            </div>
                            ${isDeveloperMode() ? `
                            <button onclick="event.stopPropagation(); openEditChapterModal('${chapter.__backendId}')" class="ml-4 p-2 text-blue-500 hover:bg-blue-50 rounded-lg transition-colors" title="Modifier ce chapitre">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                                </svg>
                            </button>
                            ` : ''}
                            ${isDeveloperMode() ? `
                            <button onclick="event.stopPropagation(); deleteChapter('${chapter.__backendId}')" class="ml-2 p-2 text-red-500 hover:bg-red-50 rounded-lg transition-colors" title="Supprimer ce chapitre">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                </svg>
                            </button>
                            ` : ''}
                            <button onclick="event.stopPropagation(); toggleFavorite('${chapter.__backendId}')" class="ml-2 p-2 ${chapter.is_favorite ? 'text-red-500' : 'text-gray-400'} hover:bg-gray-50 dark-mode:hover:bg-gray-700 rounded-lg transition-colors" title="${chapter.is_favorite ? 'Retirer des favoris' : 'Ajouter aux favoris'}">
                                <svg class="w-5 h-5" fill="${chapter.is_favorite ? '#ef4444' : 'none'}" stroke="${chapter.is_favorite ? 'none' : 'currentColor'}" stroke-width="${chapter.is_favorite ? '0' : '2'}" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
                                </svg>
                            </button>
                            <svg class="w-6 h-6 text-gray-400 cursor-pointer ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" onclick="readChapter('${manhwaId}', ${chapter.chapter_number})">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
                            </svg>
                        </div>
                    `;
                    }).join('')}
                </div>
            `;

            showPage('manhwa-detail');
        }

        // Ouvrir le modal d'ajout de chapitre
        function openAddChapterModal() {
            // VÃ©rifier le mode dÃ©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }
            
            addChapterModal.classList.remove('hidden');
        }

        // Retour Ã  la bibliothÃ¨que
        document.getElementById('back-to-library').addEventListener('click', () => {
            showPage('library');
        });

        // Lire un chapitre
        async function readChapter(manhwaId, chapterNumber) {
            currentManhwaId = manhwaId;
            currentChapterNumber = chapterNumber;

            const chapter = allChapters.find(ch => 
                ch.manhwa_id === manhwaId && ch.chapter_number === chapterNumber
            );

            if (!chapter) {
                showNotification('Chapitre introuvable', 'error');
                return;
            }

            const manhwa = allManhwas.find(m => m.manhwa_id === manhwaId);
            
            // Mettre Ã  jour l'info du chapitre
            document.getElementById('chapter-info').textContent = 
                `${manhwa.manhwa_title} - Chapitre ${chapterNumber}`;

            const readerContent = document.getElementById('reader-content');
            
            // Afficher un loader
            readerContent.innerHTML = `
                <div class="flex flex-col items-center justify-center py-12">
                    <div class="loading-spinner mb-4"></div>
                    <p class="text-gray-600">Chargement du chapitre...</p>
                </div>
            `;

            showPage('reader');
            window.scrollTo(0, 0);
            
            // Charger les commentaires
            loadComments(manhwaId, chapterNumber);

            // Le chapter_pages contient maintenant le chemin du fichier MHTML
            const mhtmlPath = chapter.chapter_pages.trim();
            
            // Nettoyer le chemin
            let cleanPath = mhtmlPath.replace(/\\/g, '/');
            if (cleanPath.includes('Site/')) {
                cleanPath = cleanPath.split('Site/')[1];
            }
            if (cleanPath.includes('chapitres/') && !cleanPath.startsWith('chapitres/')) {
                cleanPath = cleanPath.substring(cleanPath.indexOf('chapitres/'));
            }
            if (!cleanPath.startsWith('./') && !cleanPath.startsWith('/') && !cleanPath.startsWith('http')) {
                cleanPath = './' + cleanPath;
            }
            
            // Charger le fichier MHTML et extraire le contenu HTML pour l'afficher
            try {
                const response = await fetch(cleanPath);
                if (!response.ok) {
                    throw new Error(`Fichier non trouvÃ©: ${cleanPath}`);
                }
                
                const text = await response.text();
                
                // Trouver le boundary
                const boundaryMatch = text.match(/boundary="?([^"\r\n]+)"?/i);
                let boundary = '------MultipartBoundary';
                if (boundaryMatch) {
                    boundary = boundaryMatch[1].trim();
                    if (!boundary.startsWith('----')) {
                        boundary = '----' + boundary;
                    }
                }
                
                // Parser le MHTML pour trouver la partie HTML principale
                const parts = text.split(new RegExp(boundary.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')));
                let htmlContent = '';
                
                for (const part of parts) {
                    // Chercher la partie avec Content-Type: text/html
                    if (part.includes('Content-Type: text/html') || part.includes('content-type: text/html')) {
                        // Trouver la fin des headers (double saut de ligne)
                        const headerEndMatch = part.match(/\r?\n\r?\n/);
                        if (headerEndMatch) {
                            const headerEndIndex = headerEndMatch.index + headerEndMatch[0].length;
                            htmlContent = part.substring(headerEndIndex);
                            // Nettoyer le HTML (enlever les boundaries restants)
                            htmlContent = htmlContent.split(boundary)[0].trim();
                            break;
                        }
                    }
                }
                
                if (htmlContent) {
                    // CrÃ©er un iframe sandbox pour afficher le HTML
                    const iframe = document.createElement('iframe');
                    iframe.style.cssText = 'width: 100%; min-height: 100vh; border: none; background: white;';
                    iframe.sandbox = 'allow-same-origin allow-scripts';
                    iframe.onload = () => {
                        updateProgress();
                        console.log('MHTML HTML chargÃ© avec succÃ¨s');
                    };
                    
                    // Ã‰crire le HTML dans l'iframe
                    readerContent.innerHTML = '';
                    readerContent.appendChild(iframe);
                    
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    iframeDoc.open();
                    iframeDoc.write(htmlContent);
                    iframeDoc.close();
                } else {
                    throw new Error('Aucun contenu HTML trouvÃ© dans le fichier MHTML');
                }
                
            } catch (error) {
                console.error('Erreur lors du chargement du MHTML:', error);
                readerContent.innerHTML = `
                    <div class="text-center py-12">
                        <p class="text-red-600">Erreur lors du chargement du chapitre</p>
                        <p class="text-gray-500 text-sm mt-2">${error.message}</p>
                        <p class="text-gray-500 text-xs mt-1">Chemin: ${cleanPath}</p>
                    </div>
                `;
            }

            // GÃ©rer les boutons de navigation
            updateChapterNavigation(manhwaId, chapterNumber);
        }

        // Fonction optimisÃ©e pour extraire les images d'un MHTML (sans stockage)
        async function extractImagesFromMhtml(mhtmlPath) {
            // Nettoyer le chemin
            let cleanPath = mhtmlPath.replace(/\\/g, '/');
            if (cleanPath.includes('Site/')) {
                cleanPath = cleanPath.split('Site/')[1];
            }
            if (cleanPath.includes('chapitres/') && !cleanPath.startsWith('chapitres/')) {
                cleanPath = cleanPath.substring(cleanPath.indexOf('chapitres/'));
            }
            if (!cleanPath.startsWith('./') && !cleanPath.startsWith('/') && !cleanPath.startsWith('http')) {
                cleanPath = './' + cleanPath;
            }

            // Charger le fichier
            const response = await fetch(cleanPath);
            if (!response.ok) {
                throw new Error(`Fichier non trouvÃ©: ${cleanPath}`);
            }

            const arrayBuffer = await response.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            // Convertir en texte pour trouver le boundary et parser les headers
            const decoder = new TextDecoder('utf-8', { fatal: false });
            const text = decoder.decode(arrayBuffer);

            // Trouver le boundary dans l'en-tÃªte
            const boundaryMatch = text.match(/boundary="?([^"\r\n]+)"?/i);
            let boundary = '------MultipartBoundary';
            if (boundaryMatch) {
                boundary = boundaryMatch[1].trim();
                if (!boundary.startsWith('----')) {
                    boundary = '----' + boundary;
                }
            }

            // Parser le texte pour trouver les sections d'images
            const parts = text.split(new RegExp(boundary.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')));
            const images = [];
            
            // Calculer les offsets de texte pour chaque partie
            let textOffset = 0;
            const partOffsets = [];
            for (let i = 0; i < parts.length; i++) {
                partOffsets.push(textOffset);
                textOffset += parts[i].length;
                if (i > 0) textOffset += boundary.length;
            }

            for (let partIndex = 0; partIndex < parts.length; partIndex++) {
                const part = parts[partIndex];
                const textOffset = partOffsets[partIndex];
                
                // VÃ©rifier si c'est une image
                const contentTypeMatch = part.match(/[Cc]ontent-[Tt]ype:\s*image\/(jpeg|jpg|png|gif|webp|bmp)/i);
                if (!contentTypeMatch) continue;

                const imageType = contentTypeMatch[1].toLowerCase() === 'jpg' ? 'jpeg' : contentTypeMatch[1].toLowerCase();
                const isBase64 = /[Cc]ontent-[Tt]ransfer-[Ee]ncoding:\s*base64/i.test(part);
                const isBinary = /[Cc]ontent-[Tt]ransfer-[Ee]ncoding:\s*binary/i.test(part);

                // Trouver la fin des headers (double saut de ligne)
                const headerEndMatch = part.match(/\r?\n\r?\n/);
                if (!headerEndMatch) continue;
                
                const headerEndIndex = headerEndMatch.index + headerEndMatch[0].length;
                const dataText = part.substring(headerEndIndex);

                if (isBase64) {
                    // Extraire les donnÃ©es base64
                    const lines = dataText.split(/\r?\n/);
                    let base64Data = '';
                    for (const line of lines) {
                        const trimmed = line.trim();
                        if (trimmed.startsWith('----')) break;
                        if (trimmed && /^[A-Za-z0-9+/=\s]+$/.test(trimmed)) {
                            base64Data += trimmed.replace(/\s/g, '');
                        }
                    }
                    if (base64Data && base64Data.length > 100) {
                        // Valider que c'est du base64 valide
                        const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
                        if (!base64Regex.test(base64Data)) {
                            console.warn(`Image base64 ${images.length + 1}: donnÃ©es base64 invalides`);
                            continue;
                        }
                        const dataUrl = `data:image/${imageType};base64,${base64Data}`;
                        console.log(`Image base64 extraite: type=${imageType}, taille=${base64Data.length} chars`);
                        images.push(dataUrl);
                    }
                } else {
                    // Pour les donnÃ©es binaires, utiliser une mÃ©thode plus prÃ©cise
                    // Trouver le boundary suivant dans le texte pour dÃ©terminer la fin
                    const nextBoundaryIndex = text.indexOf(boundary, textOffset + part.length);
                    
                    // Calculer les positions dans le fichier binaire
                    // Trouver la position du dÃ©but de cette partie dans le binaire
                    const partStartInText = textOffset;
                    const partHeaderText = part.substring(0, headerEndIndex);
                    
                    // Chercher le dÃ©but de cette partie dans le binaire
                    // Utiliser Content-Location ou Content-ID comme marqueur unique
                    const contentLocationMatch = part.match(/[Cc]ontent-[Ll]ocation:\s*([^\r\n]+)/i);
                    const contentIdMatch = part.match(/[Cc]ontent-[Ii][Dd]:\s*<([^>]+)>/i);
                    
                    let binaryPartStart = -1;
                    let headerBytesLength = 0;
                    let searchStart = Math.max(0, Math.floor(textOffset * 0.9)); // Commencer prÃ¨s de la position attendue
                    
                    if (contentLocationMatch || contentIdMatch) {
                        // Utiliser un header unique pour la recherche
                        const uniqueHeader = contentLocationMatch ? contentLocationMatch[1] : contentIdMatch[1];
                        const headerBytes = new TextEncoder().encode(uniqueHeader);
                        headerBytesLength = headerBytes.length;
                        
                        // Chercher Ã  partir d'une position approximative
                        for (let pos = searchStart; pos < Math.min(searchStart + 100000, uint8Array.length - headerBytes.length); pos++) {
                            let match = true;
                            for (let k = 0; k < headerBytes.length; k++) {
                                if (uint8Array[pos + k] !== headerBytes[k]) {
                                    match = false;
                                    break;
                                }
                            }
                            if (match) {
                                // Remonter pour trouver le dÃ©but du boundary
                                for (let back = pos; back >= Math.max(0, pos - 200); back--) {
                                    const testBoundary = decoder.decode(uint8Array.slice(back, back + Math.min(50, uint8Array.length - back)));
                                    if (testBoundary.includes(boundary.substring(0, 20))) {
                                        binaryPartStart = back;
                                        break;
                                    }
                                }
                                if (binaryPartStart !== -1) break;
                            }
                        }
                    }
                    
                    // Fallback: utiliser la position approximative basÃ©e sur le texte
                    if (binaryPartStart === -1) {
                        // Estimer la position en supposant que texte et binaire sont alignÃ©s au dÃ©but
                        binaryPartStart = Math.floor(textOffset);
                        // Calculer la longueur du header en bytes
                        const headerBytes = new TextEncoder().encode(partHeaderText);
                        headerBytesLength = headerBytes.length;
                    }
                    
                    // Trouver la fin des headers (chercher \r\n\r\n ou \n\n)
                    let binaryDataStart = binaryPartStart + headerBytesLength;
                    for (let pos = binaryDataStart - 20; pos < binaryDataStart + 20 && pos < uint8Array.length; pos++) {
                        if (pos >= 0 && uint8Array[pos] === 0x0A && pos + 1 < uint8Array.length && uint8Array[pos + 1] === 0x0A) {
                            binaryDataStart = pos + 2;
                            break;
                        }
                        if (pos >= 1 && uint8Array[pos - 1] === 0x0D && uint8Array[pos] === 0x0A && 
                            pos + 1 < uint8Array.length && uint8Array[pos + 1] === 0x0D && pos + 2 < uint8Array.length && uint8Array[pos + 2] === 0x0A) {
                            binaryDataStart = pos + 3;
                            break;
                        }
                    }
                    
                    // Trouver la fin des donnÃ©es (chercher le boundary suivant)
                    const boundaryBytes = new TextEncoder().encode(boundary);
                    let binaryDataEnd = uint8Array.length;
                    
                    // Chercher le boundary avec diffÃ©rents prÃ©fixes possibles
                    const prefixes = [
                        new TextEncoder().encode('\r\n' + boundary),
                        new TextEncoder().encode('\n' + boundary),
                        boundaryBytes
                    ];
                    
                    for (const prefixBytes of prefixes) {
                        for (let pos = binaryDataStart; pos < uint8Array.length - prefixBytes.length; pos++) {
                            let match = true;
                            for (let k = 0; k < prefixBytes.length; k++) {
                                if (uint8Array[pos + k] !== prefixBytes[k]) {
                                    match = false;
                                    break;
                                }
                            }
                            if (match) {
                                binaryDataEnd = pos;
                                break;
                            }
                        }
                        if (binaryDataEnd < uint8Array.length) break;
                    }
                    
                    // Extraire les donnÃ©es binaires
                    if (binaryDataEnd > binaryDataStart && binaryDataEnd <= uint8Array.length) {
                        const binaryData = uint8Array.slice(binaryDataStart, binaryDataEnd);
                        
                        if (binaryData.length >= 100) {
                            // VÃ©rifier la signature du fichier image
                            let isValidImage = false;
                            if (imageType === 'jpeg' && binaryData[0] === 0xFF && binaryData[1] === 0xD8) {
                                isValidImage = true;
                            } else if (imageType === 'png' && binaryData[0] === 0x89 && binaryData[1] === 0x50 && binaryData[2] === 0x4E && binaryData[3] === 0x47) {
                                isValidImage = true;
                            } else if (imageType === 'gif' && binaryData[0] === 0x47 && binaryData[1] === 0x49 && binaryData[2] === 0x46) {
                                isValidImage = true;
                            } else if (imageType === 'webp' && binaryData[0] === 0x52 && binaryData[1] === 0x49 && binaryData[2] === 0x46 && binaryData[3] === 0x46) {
                                isValidImage = true;
                            } else {
                                // Si la signature ne correspond pas, essayer quand mÃªme (peut Ãªtre un format diffÃ©rent)
                                isValidImage = true;
                            }
                            
                            if (isValidImage) {
                                // Convertir en base64 par chunks
                                let base64String = '';
                                const chunkSize = 8192;
                                try {
                                    for (let j = 0; j < binaryData.length; j += chunkSize) {
                                        const chunk = binaryData.slice(j, Math.min(j + chunkSize, binaryData.length));
                                        const binaryString = Array.from(chunk, byte => String.fromCharCode(byte)).join('');
                                        base64String += btoa(binaryString);
                                    }
                                    
                            if (base64String && base64String.length > 100) {
                                // Valider que c'est du base64 valide
                                const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
                                if (!base64Regex.test(base64String)) {
                                    console.warn(`Image binaire ${images.length + 1}: base64 invalide aprÃ¨s conversion`);
                                    continue;
                                }
                                const dataUrl = `data:image/${imageType};base64,${base64String}`;
                                console.log(`Image binaire extraite: type=${imageType}, taille=${binaryData.length} bytes, base64 length=${base64String.length}`);
                                images.push(dataUrl);
                            } else {
                                console.warn(`Image ${images.length + 1}: base64 trop court (${base64String ? base64String.length : 0})`);
                            }
                                } catch (error) {
                                    console.error(`Erreur lors de la conversion base64 pour image ${images.length + 1}:`, error);
                                }
                            } else {
                                console.warn(`Image ${images.length + 1} ignorÃ©e: signature invalide pour type ${imageType} (premiers bytes: ${Array.from(binaryData.slice(0, 4)).map(b => '0x' + b.toString(16)).join(' ')})`);
                            }
                        }
                    }
                }
            }

            console.log(`Total d'images extraites: ${images.length}`);
            return images;
        }

        // Mise Ã  jour de la navigation des chapitres
        function updateChapterNavigation(manhwaId, chapterNumber) {
            const chapters = allChapters
                .filter(ch => ch.manhwa_id === manhwaId)
                .sort((a, b) => a.chapter_number - b.chapter_number);

            const currentIndex = chapters.findIndex(ch => ch.chapter_number === chapterNumber);
            const prevChapter = chapters[currentIndex - 1];
            const nextChapter = chapters[currentIndex + 1];

            const prevBtn = document.getElementById('prev-chapter');
            const nextBtn = document.getElementById('next-chapter');

            if (prevChapter) {
                prevBtn.disabled = false;
                prevBtn.onclick = () => readChapter(manhwaId, prevChapter.chapter_number);
                prevBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                prevBtn.disabled = true;
                prevBtn.onclick = null;
                prevBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }

            if (nextChapter) {
                nextBtn.disabled = false;
                nextBtn.onclick = () => readChapter(manhwaId, nextChapter.chapter_number);
                nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                nextBtn.disabled = true;
                nextBtn.onclick = null;
                nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        // Gestion des commentaires
        let currentChapterComments = [];
        let commentImagesSelected = [];
        
        function loadComments(manhwaId, chapterNumber) {
            const commentKey = `comments_${manhwaId}_${chapterNumber}`;
            const saved = localStorage.getItem(commentKey);
            if (saved) {
                currentChapterComments = JSON.parse(saved);
            } else {
                currentChapterComments = [];
            }
            updateCommentsDisplay();
        }
        
        function saveComments(manhwaId, chapterNumber) {
            const commentKey = `comments_${manhwaId}_${chapterNumber}`;
            localStorage.setItem(commentKey, JSON.stringify(currentChapterComments));
            // TODO: Synchroniser avec Drive
        }
        
        function updateCommentsDisplay() {
            const commentsList = document.getElementById('comments-list');
            if (!commentsList) return;
            
            commentsList.innerHTML = '';
            
            const searchTerm = (document.getElementById('comment-search')?.value || '').toLowerCase();
            const filterValue = document.getElementById('comment-filter')?.value || 'all';
            
            let filtered = [...currentChapterComments];
            
            // Recherche
            if (searchTerm) {
                filtered = filtered.filter(comment => 
                    comment.text.toLowerCase().includes(searchTerm) ||
                    comment.author?.toLowerCase().includes(searchTerm)
                );
            }
            
            // Filtrage
            if (filterValue === 'recent') {
                filtered.sort((a, b) => new Date(b.date) - new Date(a.date));
            } else if (filterValue === 'oldest') {
                filtered.sort((a, b) => new Date(a.date) - new Date(b.date));
            }
            
            if (filtered.length === 0) {
                commentsList.innerHTML = `
                    <div class="text-center py-8 text-gray-600 dark-mode:text-gray-300">
                        ${currentChapterComments.length === 0 ? 'Aucun commentaire pour le moment' : 'Aucun rÃ©sultat trouvÃ©'}
                    </div>
                `;
                return;
            }
            
            filtered.forEach(comment => {
                const item = document.createElement('div');
                item.className = 'bg-white dark-mode:bg-gray-900 rounded-lg p-4 shadow-md border border-gray-200 dark-mode:border-gray-700';
                item.innerHTML = `
                    <div class="flex items-start justify-between mb-2">
                        <div>
                            <p class="font-semibold text-gray-900 dark-mode:text-gray-100">${comment.author || 'Anonyme'}</p>
                            <p class="text-xs text-gray-500 dark-mode:text-gray-400">${formatDate(comment.date)}</p>
                        </div>
                        <button onclick="deleteComment('${comment.id}')" class="text-red-500 hover:text-red-700 text-sm">Supprimer</button>
                    </div>
                    <p class="text-gray-800 dark-mode:text-gray-100 mb-3 whitespace-pre-wrap">${comment.text}</p>
                    ${comment.images && comment.images.length > 0 ? `
                        <div class="flex flex-wrap gap-2 mb-2">
                            ${comment.images.map(img => `
                                <img src="${img}" alt="Comment image" class="w-24 h-24 object-cover rounded-lg cursor-pointer" onclick="window.open('${img}', '_blank')">
                            `).join('')}
                        </div>
                    ` : ''}
                `;
                commentsList.appendChild(item);
            });
        }
        
        window.openGalleryForComment = function() {
            // Ouvrir un modal pour sÃ©lectionner des images de la galerie
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark-mode:bg-gray-800 rounded-xl shadow-2xl max-w-4xl w-full mx-4 max-h-[80vh] overflow-y-auto p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-gray-900 dark-mode:text-gray-100">SÃ©lectionner des images</h3>
                        <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600">âœ•</button>
                    </div>
                    <div class="grid grid-cols-4 gap-4" id="gallery-select-grid"></div>
                    <div class="mt-4 flex justify-end">
                        <button onclick="confirmGallerySelection()" class="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">Confirmer</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            const grid = modal.querySelector('#gallery-select-grid');
            galleryImages.forEach((img, index) => {
                const item = document.createElement('div');
                item.className = 'relative cursor-pointer';
                item.innerHTML = `
                    <img src="${img.path}" alt="${img.name}" class="w-full h-32 object-cover rounded-lg">
                    <input type="checkbox" class="absolute top-2 right-2" data-image-path="${img.path}">
                `;
                grid.appendChild(item);
            });
        };
        
        window.confirmGallerySelection = function() {
            const checkboxes = document.querySelectorAll('#gallery-select-grid input[type="checkbox"]:checked');
            commentImagesSelected = Array.from(checkboxes).map(cb => cb.dataset.imagePath);
            
            // Afficher les images sÃ©lectionnÃ©es
            const preview = document.getElementById('comment-images-preview');
            preview.innerHTML = commentImagesSelected.map(img => `
                <img src="${img}" alt="Selected" class="w-16 h-16 object-cover rounded-lg">
            `).join('');
            
            document.querySelector('.fixed').remove();
        };
        
        window.addComment = function() {
            const text = document.getElementById('comment-text').value.trim();
            if (!text && commentImagesSelected.length === 0) {
                showNotification('Veuillez entrer un commentaire ou ajouter une image', 'error');
                return;
            }
            
            const comment = {
                id: 'comment_' + Date.now() + '_' + Math.random(),
                text: text,
                images: [...commentImagesSelected],
                author: 'Vous', // TODO: RÃ©cupÃ©rer depuis Drive
                date: new Date().toISOString()
            };
            
            currentChapterComments.push(comment);
            saveComments(currentManhwaId, currentChapterNumber);
            updateCommentsDisplay();
            
            // RÃ©initialiser
            document.getElementById('comment-text').value = '';
            commentImagesSelected = [];
            document.getElementById('comment-images-preview').innerHTML = '';
            
            showNotification('Commentaire ajoutÃ©!', 'success');
        };
        
        window.deleteComment = function(commentId) {
            currentChapterComments = currentChapterComments.filter(c => c.id !== commentId);
            saveComments(currentManhwaId, currentChapterNumber);
            updateCommentsDisplay();
            showNotification('Commentaire supprimÃ©', 'success');
        };
        
        window.openEmojiPicker = function() {
            const emojis = ['ðŸ˜€', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜†', 'ðŸ˜…', 'ðŸ¤£', 'ðŸ˜‚', 'ðŸ™‚', 'ðŸ™ƒ', 'ðŸ˜‰', 'ðŸ˜Š', 'ðŸ˜‡', 'ðŸ¥°', 'ðŸ˜', 'ðŸ¤©', 'ðŸ˜˜', 'ðŸ˜—', 'ðŸ˜š', 'ðŸ˜™', 'ðŸ˜‹', 'ðŸ˜›', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ˜', 'ðŸ¤‘', 'ðŸ¤—', 'ðŸ¤­', 'ðŸ¤«', 'ðŸ¤”', 'ðŸ¤', 'ðŸ¤¨', 'ðŸ˜', 'ðŸ˜‘', 'ðŸ˜¶', 'ðŸ˜', 'ðŸ˜’', 'ðŸ™„', 'ðŸ˜¬', 'ðŸ¤¥', 'ðŸ˜Œ', 'ðŸ˜”', 'ðŸ˜ª', 'ðŸ¤¤', 'ðŸ˜´', 'ðŸ˜·', 'ðŸ¤’', 'ðŸ¤•', 'ðŸ¤¢', 'ðŸ¤®', 'ðŸ¤§', 'ðŸ¥µ', 'ðŸ¥¶', 'ðŸ˜¶â€ðŸŒ«ï¸', 'ðŸ˜µ', 'ðŸ¤¯', 'ðŸ¤ ', 'ðŸ¥³', 'ðŸ˜Ž', 'ðŸ¤“', 'ðŸ§', 'ðŸ˜•', 'ðŸ˜Ÿ', 'ðŸ™', 'â˜¹ï¸', 'ðŸ˜®', 'ðŸ˜¯', 'ðŸ˜²', 'ðŸ˜³', 'ðŸ¥º', 'ðŸ˜¦', 'ðŸ˜§', 'ðŸ˜¨', 'ðŸ˜°', 'ðŸ˜¥', 'ðŸ˜¢', 'ðŸ˜­', 'ðŸ˜±', 'ðŸ˜–', 'ðŸ˜£', 'ðŸ˜ž', 'ðŸ˜“', 'ðŸ˜©', 'ðŸ˜«', 'ðŸ¥±', 'ðŸ˜¤', 'ðŸ˜¡', 'ðŸ˜ ', 'ðŸ¤¬', 'ðŸ˜ˆ', 'ðŸ‘¿', 'ðŸ’€', 'â˜ ï¸', 'ðŸ’©', 'ðŸ¤¡', 'ðŸ‘¹', 'ðŸ‘º', 'ðŸ‘»', 'ðŸ‘½', 'ðŸ‘¾', 'ðŸ¤–', 'ðŸ˜º', 'ðŸ˜¸', 'ðŸ˜¹', 'ðŸ˜»', 'ðŸ˜¼', 'ðŸ˜½', 'ðŸ™€', 'ðŸ˜¿', 'ðŸ˜¾'];
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark-mode:bg-gray-800 rounded-xl shadow-2xl max-w-md w-full mx-4 p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-gray-900 dark-mode:text-gray-100">Choisir un emoji</h3>
                        <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600">âœ•</button>
                    </div>
                    <div class="grid grid-cols-8 gap-2 max-h-64 overflow-y-auto">
                        ${emojis.map(emoji => `
                            <button onclick="insertEmoji('${emoji}')" class="text-2xl hover:bg-gray-100 dark-mode:hover:bg-gray-700 rounded p-2">${emoji}</button>
                        `).join('')}
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        };
        
        window.insertEmoji = function(emoji) {
            const textarea = document.getElementById('comment-text');
            const cursorPos = textarea.selectionStart;
            const textBefore = textarea.value.substring(0, cursorPos);
            const textAfter = textarea.value.substring(cursorPos);
            textarea.value = textBefore + emoji + textAfter;
            textarea.selectionStart = textarea.selectionEnd = cursorPos + emoji.length;
            textarea.focus();
            document.querySelector('.fixed').remove();
        };
        
        // Event listeners pour la recherche et le filtrage des commentaires
        const commentSearch = document.getElementById('comment-search');
        const commentFilter = document.getElementById('comment-filter');
        
        if (commentSearch) {
            commentSearch.addEventListener('input', () => updateCommentsDisplay());
        }
        if (commentFilter) {
            commentFilter.addEventListener('change', () => updateCommentsDisplay());
        }

        // Mise Ã  jour de la progression de lecture
        function updateProgress() {
            const readerContent = document.getElementById('reader-content');
            const images = readerContent.querySelectorAll('img');
            let loadedImages = 0;

            images.forEach(img => {
                if (img.complete && img.naturalHeight !== 0) {
                    loadedImages++;
                }
            });

            const progress = (loadedImages / images.length) * 100;
            document.getElementById('reading-progress').style.width = progress + '%';
        }

        // Supprimer un chapitre
        // Fonction pour rÃ©organiser les manhwas (drag & drop)
        async function reorderManhwas(draggedId, targetId) {
            // Permettre le rÃ©ordonnancement mÃªme en ligne (pour l'affichage seulement)
            
            const draggedIndex = allManhwas.findIndex(m => m.__backendId === draggedId);
            const targetIndex = allManhwas.findIndex(m => m.__backendId === targetId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            // RÃ©organiser dans le tableau
            const [draggedItem] = allManhwas.splice(draggedIndex, 1);
            allManhwas.splice(targetIndex, 0, draggedItem);
            
            // Mettre Ã  jour l'ordre dans globalData seulement en mode dÃ©veloppeur
            if (isDeveloperMode()) {
                globalData = globalData.filter(item => 
                    !item.manhwa_id || item.chapter_number || item.type === 'tracking' || item.type === 'trash'
                );
                
                allManhwas.forEach(manhwa => {
                    const existing = globalData.find(item => item.__backendId === manhwa.__backendId);
                    if (existing) {
                        globalData.push(existing);
                    }
                });
                
                // Sauvegarder
                scheduleAutoSave(globalData);
            }
            updateLibraryPage();
            showNotification('Ordre mis Ã  jour', 'success');
        }
        
        // Fonction pour rÃ©organiser les suivis (drag & drop)
        async function reorderTracking(draggedId, targetId) {
            const draggedIndex = trackingList.findIndex(t => t.id === draggedId);
            const targetIndex = trackingList.findIndex(t => t.id === targetId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            // RÃ©organiser dans le tableau
            const [draggedItem] = trackingList.splice(draggedIndex, 1);
            trackingList.splice(targetIndex, 0, draggedItem);
            
            // Sauvegarder
            await saveTrackingList();
            updateTrackingPage();
            showNotification('Ordre mis Ã  jour', 'success');
        }
        
        // Fonction pour ajouter Ã  la corbeille
        async function addToTrash(item, itemType) {
            const trashItem = {
                type: 'trash',
                trash_type: itemType, // 'manhwa', 'chapter', 'tracking'
                original_data: item,
                deleted_at: new Date().toISOString(),
                id: 'trash_' + Date.now() + '_' + Math.random()
            };
            
            globalData.push(trashItem);
            
            if (isDeveloperMode()) {
                scheduleAutoSave(globalData);
            } else {
                await saveDataToFileAuto(globalData);
            }
        }
        
        async function deleteChapter(chapterId) {
            // VÃ©rifier le mode dÃ©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }
            
            const chapter = allChapters.find(ch => ch.__backendId === chapterId);
            if (!chapter) return;

            const confirmed = await showConfirmDialog(
                `Supprimer le chapitre ${chapter.chapter_number}?`,
                'Le chapitre sera dÃ©placÃ© dans la corbeille.'
            );

            if (!confirmed) return;

            // Ajouter Ã  la corbeille AVANT de supprimer
            await addToTrash(chapter, 'chapter');

            // Supprimer immÃ©diatement de la liste locale pour mise Ã  jour instantanÃ©e
            allChapters = allChapters.filter(ch => ch.__backendId !== chapterId);
            
            // Mettre Ã  jour IMMÃ‰DIATEMENT toutes les pages AVANT la sauvegarde
            updateAllPages();
            
            // Supprimer via SDK (sauvegarde en arriÃ¨re-plan)
            const result = await window.dataSdk.delete(chapter);
            
            if (result.isOk) {
                showNotification('Chapitre dÃ©placÃ© dans la corbeille', 'success');
            } else {
                // Restaurer si erreur
                allChapters.push(chapter);
                showNotification('Erreur lors de la suppression', 'error');
                updateAllPages();
            }
        }

        // Supprimer un manhwa
        async function deleteManhwa(manhwaId) {
            // VÃ©rifier le mode dÃ©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }
            
            const manhwa = allManhwas.find(m => m.__backendId === manhwaId);
            if (!manhwa) return;

            const chapters = allChapters.filter(ch => ch.manhwa_id === manhwa.manhwa_id);
            
            const confirmed = await showConfirmDialog(
                `Supprimer "${manhwa.manhwa_title}"?`,
                `Cette action dÃ©placera aussi les ${chapters.length} chapitres associÃ©s dans la corbeille.`
            );

            if (!confirmed) return;

            // Ajouter Ã  la corbeille
            await addToTrash(manhwa, 'manhwa');
            for (const chapter of chapters) {
                await addToTrash(chapter, 'chapter');
            }

            // Supprimer d'abord tous les chapitres
            for (const chapter of chapters) {
                await window.dataSdk.delete(chapter);
            }

            // Puis supprimer le manhwa
            const result = await window.dataSdk.delete(manhwa);
            
            if (result.isOk) {
                showNotification('Manhwa dÃ©placÃ© dans la corbeille', 'success');
                updateAllPages();
                showPage('library');
            } else {
                showNotification('Erreur lors de la suppression', 'error');
            }
        }

        // Exposer certaines fonctions au scope global pour les handlers inline (script type="module")
        window.openEditManhwaModal = openEditManhwaModal;
        window.openEditChapterModal = openEditChapterModal;
        window.openAddManhwaModal = openAddManhwaModal;
        window.openAddChapterModal = openAddChapterModal;
        window.deleteManhwa = deleteManhwa;
        window.deleteChapter = deleteChapter;

        // Dialog de confirmation (sans alert!)
        function showConfirmDialog(title, message) {
            return new Promise((resolve) => {
                const dialog = document.createElement('div');
                dialog.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                dialog.innerHTML = `
                    <div class="bg-white rounded-xl shadow-2xl max-w-md mx-4 p-6">
                        <h3 class="text-xl font-bold mb-2">${title}</h3>
                        <p class="text-gray-600 mb-6">${message}</p>
                        <div class="flex justify-end space-x-3">
                            <button id="cancel-confirm" class="px-4 py-2 border rounded-lg hover:bg-gray-100">
                                Annuler
                            </button>
                            <button id="ok-confirm" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700">
                                Supprimer
                            </button>
                        </div>
                    </div>
                `;
                document.body.appendChild(dialog);

                dialog.querySelector('#cancel-confirm').onclick = () => {
                    dialog.remove();
                    resolve(false);
                };

                dialog.querySelector('#ok-confirm').onclick = () => {
                    dialog.remove();
                    resolve(true);
                };
            });
        }

        // Retour au dÃ©tail depuis le lecteur
        document.getElementById('back-to-detail').addEventListener('click', () => {
            if (currentManhwaId) {
                showManhwaDetail(currentManhwaId);
            } else {
                showPage('home');
            }
        });

        // Fonction utilitaire pour formater les dates
        function formatDate(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffTime = Math.abs(now - date);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            if (diffDays === 0 || diffDays === 1) return "Aujourd'hui";
            if (diffDays === 2) return "Hier";
            if (diffDays < 7) return `Il y a ${diffDays} jours`;
            if (diffDays < 30) return `Il y a ${Math.floor(diffDays / 7)} semaines`;
            return date.toLocaleDateString('fr-FR');
        }

        // SystÃ¨me de notification
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `fixed top-20 right-4 px-6 py-3 rounded-lg shadow-lg z-50 ${
                type === 'success' ? 'bg-green-500' : 
                type === 'error' ? 'bg-red-500' : 
                'bg-blue-500'
            } text-white font-medium`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Initialiser l'application
        window.addEventListener('DOMContentLoaded', () => {
            initializeApp();
        });
    </script>
</body>
</html>