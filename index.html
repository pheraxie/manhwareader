<!doctype html>
<html lang="fr">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ManhwaReader Pro</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&amp;display=swap" rel="stylesheet">
  <!-- Google Drive API -->
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
        body {
            font-family: 'Poppins', sans-serif;
            box-sizing: border-box;
        }
        
        .dark-mode {
            background-color: #1a1a1a !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode .card {
            background-color: #2d2d2d !important;
            border-color: #404040 !important;
            color: #e2e8f0 !important;
        }
        
        /* Galerie masonry */
        #gallery-grid {
            column-gap: 1rem;
        }
        
        #gallery-grid .break-inside-avoid {
            break-inside: avoid;
            page-break-inside: avoid;
            margin-bottom: 1rem;
        }
        
        @media (min-width: 640px) {
            #gallery-grid {
                columns: 2;
            }
        }
        
        @media (min-width: 768px) {
            #gallery-grid {
                columns: 3;
            }
        }
        
        @media (min-width: 1024px) {
            #gallery-grid {
                columns: 4;
            }
        }
        
        .dark-mode .input-field {
            background-color: #2d2d2d !important;
            border-color: #404040 !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode .nav-item:hover {
            background-color: #404040 !important;
        }
        
        .dark-mode .chapter-item {
            background-color: #2d2d2d !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode .chapter-item:hover {
            background-color: #404040 !important;
        }
        
        .dark-mode .badge {
            background-color: #404040 !important;
            color: #a5b4fc !important;
        }
        
        .dark-mode button:not(.bg-indigo-600) {
            background-color: #2d2d2d !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode h1, .dark-mode h2, .dark-mode h3, .dark-mode h4 {
            color: #e2e8f0 !important;
        }
        
        /* Am√©lioration de la visibilit√© des textes en mode sombre */
        .dark-mode .text-gray-500 {
            color: #cbd5e1 !important;
        }
        
        .dark-mode .text-gray-600 {
            color: #e2e8f0 !important;
        }
        
        .dark-mode .text-gray-700 {
            color: #f1f5f9 !important;
        }
        
        .dark-mode .text-gray-400 {
            color: #94a3b8 !important;
        }
        
        .dark-mode .text-gray-300 {
            color: #cbd5e1 !important;
        }
        
        /* Panneau de param√®tres en mode sombre */
        .dark-mode #settings-panel {
            background-color: #2d2d2d !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode #settings-panel h2,
        .dark-mode #settings-panel h3 {
            color: #f1f5f9 !important;
        }
        
        .dark-mode #settings-panel .text-indigo-900 {
            color: #c7d2fe !important;
        }
        
        .dark-mode #settings-panel .text-indigo-600 {
            color: #818cf8 !important;
        }
        
        .dark-mode #settings-panel .bg-indigo-50 {
            background-color: #312e81 !important;
        }
        
        .dark-mode #settings-panel .bg-indigo-100 {
            background-color: #3730a3 !important;
        }
        
        .dark-mode #settings-panel .bg-gray-50 {
            background-color: #374151 !important;
        }
        
        /* Section Suivi en mode sombre */
        .dark-mode #tracking-page .bg-white {
            background-color: #2d2d2d !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode #tracking-page .text-gray-600 {
            color: #cbd5e1 !important;
        }
        
        .dark-mode #tracking-page .bg-gray-50 {
            background-color: #374151 !important;
        }
        
        .dark-mode #tracking-page .bg-gray-100 {
            background-color: #4b5563 !important;
        }
        
        .dark-mode #tracking-page .bg-gray-200 {
            background-color: #6b7280 !important;
        }
        
        .dark-mode #tracking-page .border-t {
            border-color: #404040 !important;
        }
        
        .dark-mode #tracking-page .text-gray-900 {
            color: #f1f5f9 !important;
        }
        
        .dark-mode #tracking-page .text-indigo-600 {
            color: #818cf8 !important;
        }
        
        .dark-mode #tracking-page .text-gray-700 {
            color: #cbd5e1 !important;
        }
        
        .dark-mode #tracking-page .border-gray-200 {
            border-color: #404040 !important;
        }
        
        .dark-mode #tracking-page .bg-gray-100 {
            background-color: #4b5563 !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode #tracking-page .bg-gray-100:hover {
            background-color: #6b7280 !important;
        }
        
        .dark-mode #tracking-page .hover\:bg-blue-50:hover {
            background-color: #1e3a8a !important;
        }
        
        .dark-mode #tracking-page .hover\:bg-red-50:hover {
            background-color: #7f1d1d !important;
        }
        
        /* Modals en mode sombre */
        .dark-mode .fixed.inset-0 > div.bg-white,
        .dark-mode #add-manhwa-modal > div,
        .dark-mode #add-chapter-modal > div,
        .dark-mode #edit-manhwa-modal > div,
        .dark-mode #edit-chapter-modal > div,
        .dark-mode #tracking-modal > div {
            background-color: #2d2d2d !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode .fixed.inset-0 > div.bg-white h2,
        .dark-mode #add-manhwa-modal h2,
        .dark-mode #add-chapter-modal h2,
        .dark-mode #edit-manhwa-modal h2,
        .dark-mode #edit-chapter-modal h2,
        .dark-mode #tracking-modal h2 {
            color: #f1f5f9 !important;
        }
        
        .dark-mode .fixed.inset-0 > div.bg-white label,
        .dark-mode #add-manhwa-modal label,
        .dark-mode #add-chapter-modal label,
        .dark-mode #edit-manhwa-modal label,
        .dark-mode #edit-chapter-modal label,
        .dark-mode #tracking-modal label {
            color: #e2e8f0 !important;
        }
        
        .dark-mode .fixed.inset-0 > div.bg-white .border-b,
        .dark-mode #add-manhwa-modal .border-b,
        .dark-mode #add-chapter-modal .border-b,
        .dark-mode #edit-manhwa-modal .border-b,
        .dark-mode #edit-chapter-modal .border-b,
        .dark-mode #tracking-modal .border-b {
            border-color: #404040 !important;
        }
        
        /* Sidebar en mode sombre */
        .dark-mode #sidebar {
            background-color: #2d2d2d !important;
            color: #e2e8f0 !important;
        }
        
        .dark-mode #sidebar .nav-item {
            color: #e2e8f0 !important;
        }
        
        .dark-mode #sidebar h2 {
            color: #f1f5f9 !important;
        }
        
        .card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        
        .manhwa-cover {
            width: 100%;
            height: 300px;
            object-fit: cover;
            border-radius: 12px;
        }
        
        .chapter-item {
            transition: all 0.2s ease;
        }
        
        .chapter-item:hover {
            background-color: rgba(99, 102, 241, 0.1);
            transform: translateX(5px);
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .reading-page img {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            display: block;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .loading-spinner {
            border: 3px solid rgba(99, 102, 241, 0.1);
            border-top: 3px solid #6366f1;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .progress-bar {
            height: 4px;
            background-color: #6366f1;
            transition: width 0.3s ease;
        }

        /* Comment card styling aligned with settings panel */
        .comment-card {
            background-color: #ffffff;
            border: 1px solid #e5e7eb;
            color: #111827;
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: 0 6px 12px rgba(15, 23, 42, 0.04);
        }

        .dark-mode .comment-card {
            /* Use the same palette as the settings panel for consistency */
            background-color: #2d2d2d !important;
            border-color: #404040 !important;
            color: #e2e8f0 !important;
            box-shadow: none;
        }
    </style>
  <style>@view-transition { navigation: auto; }</style>
 </head>
 <body class="bg-gray-50 min-h-screen"><!-- Navigation -->
  <nav id="navbar" class="bg-white shadow-md sticky top-0 z-50">
   <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <div class="flex justify-between items-center h-16">
     <div class="flex items-center"><button id="menu-btn" class="mr-4 p-2 rounded-lg hover:bg-gray-100">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
       </svg></button>
      <h1 class="text-2xl font-bold text-indigo-600">ManhwaReader</h1>
     </div>
     <div class="flex items-center space-x-4"><button id="settings-btn" class="p-2 rounded-lg hover:bg-gray-100">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
       </svg></button>
     </div>
    </div>
   </div>
  </nav><!-- Sidebar -->
  <aside id="sidebar" class="fixed top-16 left-0 h-full w-64 bg-white shadow-lg transform -translate-x-full transition-transform duration-300 z-40">
   <div class="p-4">
    <h2 class="text-lg font-semibold mb-4">Navigation</h2>
    <ul class="space-y-2">
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="home">
       <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path>
       </svg> Accueil </button></li>
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="library">
       <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 14v3m4-3v3m4-3v3M3 21h18M3 10h18M3 7l9-4 9 4M4 10h16v11H4V10z"></path>
       </svg> Ma Biblioth√®que </button></li>
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="recent">
       <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
       </svg> R√©cents </button></li>
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="favorites">
       <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
       </svg> Favoris </button></li>
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="tracking">
      <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
      </svg> Suivi </button></li>
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="gallery">
      <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
      </svg> Galerie </button></li>
     <li><button class="nav-item w-full text-left px-4 py-3 rounded-lg hover:bg-gray-100 flex items-center" data-page="trash">
      <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
      </svg> Corbeille </button></li>
    </ul>
   </div>
  </aside><!-- Main Content -->
  <main id="main-content" class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><!-- Home Page -->
   <div id="home-page" class="page-content hidden fade-in">
    <h2 class="text-3xl font-bold mb-8">Continuer la lecture</h2>
    <div id="continue-reading" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 mb-12"><!-- Les manhwas en cours seront ajout√©s ici -->
    </div>
    <h2 class="text-3xl font-bold mb-8">Derniers chapitres ajout√©s</h2>
    <div id="latest-chapters" class="space-y-4"><!-- Les derniers chapitres seront ajout√©s ici -->
    </div>
   </div><!-- Library Page -->
   <div id="library-page" class="page-content hidden fade-in">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-3xl font-bold">Ma Biblioth√®que</h2>
     <div class="flex items-center space-x-3">
      <input type="text" id="library-search" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field" placeholder="üîç Rechercher...">
      <select id="library-filter" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field">
       <option value="all">Tous</option>
       <option value="az">A-Z</option>
       <option value="za">Z-A</option>
       <option value="recent">R√©cent</option>
       <option value="oldest">Plus ancien</option>
      </select>
     </div>
    </div>
    <div id="library-grid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6"><!-- Les manhwas seront ajout√©s ici -->
    </div>
   </div><!-- Recent Page -->
   <div id="recent-page" class="page-content hidden fade-in">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-3xl font-bold">Chapitres r√©cemment lus</h2>
     <div class="flex items-center space-x-3">
      <input type="text" id="recent-search" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field" placeholder="üîç Rechercher...">
      <select id="recent-filter" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field">
       <option value="recent">Plus r√©cent</option>
       <option value="oldest">Plus ancien</option>
       <option value="az">A-Z</option>
       <option value="za">Z-A</option>
      </select>
     </div>
    </div>
    <div id="recent-list" class="space-y-4"><!-- L'historique de lecture sera ajout√© ici -->
    </div>
   </div><!-- Favorites Page -->
   <div id="favorites-page" class="page-content hidden fade-in">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-3xl font-bold">Favoris</h2>
     <div class="flex items-center space-x-3">
      <input type="text" id="favorites-search" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field" placeholder="üîç Rechercher...">
      <select id="favorites-filter" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field">
       <option value="recent">Plus r√©cent</option>
       <option value="oldest">Plus ancien</option>
       <option value="az">A-Z</option>
       <option value="za">Z-A</option>
      </select>
     </div>
    </div>
    <div id="favorites-list" class="space-y-4"><!-- Les chapitres favoris seront ajout√©s ici -->
    </div>
   </div><!-- Trash Page -->
   <div id="gallery-page" class="page-content hidden fade-in">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-3xl font-bold">Galerie</h2>
     <div class="flex items-center space-x-3">
      <button onclick="shuffleGallery()" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors">
       üîÄ M√©langer
      </button>
     </div>
    </div>
    <div id="gallery-grid" class="columns-1 sm:columns-2 md:columns-3 lg:columns-4 gap-4 space-y-4"><!-- Les images seront ajout√©es ici -->
    </div>
   </div>
   <div id="trash-page" class="page-content hidden fade-in">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-3xl font-bold">Corbeille</h2>
     <div class="flex items-center space-x-3">
      <input type="text" id="trash-search" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field" placeholder="üîç Rechercher...">
      <select id="trash-filter" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field">
       <option value="all">Tous</option>
       <option value="manhwa">Manhwas</option>
       <option value="chapter">Chapitres</option>
       <option value="tracking">Suivis</option>
       <option value="recent">Plus r√©cent</option>
       <option value="oldest">Plus ancien</option>
      </select>
      <button onclick="deleteAllPermanentlyFromTrash()" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors">
       Tout supprimer d√©finitivement
      </button>
     </div>
    </div>
    <div id="trash-list" class="space-y-4"><!-- Les √©l√©ments supprim√©s seront ajout√©s ici -->
    </div>
   </div><!-- Tracking Page -->
   <div id="tracking-page" class="page-content hidden fade-in">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-3xl font-bold">Suivi de lecture</h2>
     <div class="flex items-center space-x-3">
      <input type="text" id="tracking-search" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field" placeholder="üîç Rechercher...">
      <select id="tracking-filter" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field">
       <option value="all">Tous</option>
       <option value="en-cours">En cours</option>
       <option value="fini">Fini</option>
       <option value="en-pause">En pause</option>
       <option value="az">A-Z</option>
       <option value="za">Z-A</option>
      </select>
      <button id="add-tracking-btn" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 flex items-center">
       <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
       </svg>
       Ajouter un suivi
      </button>
     </div>
    </div>
    <div id="tracking-list" class="space-y-4"><!-- Les suivis seront ajout√©s ici -->
    </div>
   </div><!-- Manhwa Detail Page -->
   <div id="manhwa-detail-page" class="page-content hidden fade-in"><button id="back-to-library" class="mb-6 flex items-center text-indigo-600 hover:text-indigo-800">
     <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
     </svg> Retour </button>
    <div id="manhwa-detail-content"><!-- Le d√©tail du manhwa sera ajout√© ici -->
    </div>
   </div><!-- Reader Page -->
   <div id="reader-page" class="page-content hidden">
    <div class="mb-4 flex justify-between items-center"><button id="back-to-detail" class="flex items-center text-indigo-600 hover:text-indigo-800">
      <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
      </svg> Retour </button>
     <div class="flex items-center space-x-4"><button id="prev-chapter" class="bg-gray-200 px-4 py-2 rounded-lg hover:bg-gray-300">
       <svg class="w-5 h-5" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
       </svg></button> <span id="chapter-info" class="font-semibold"></span> <button id="next-chapter" class="bg-gray-200 px-4 py-2 rounded-lg hover:bg-gray-300">
       <svg class="w-5 h-5" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
       </svg></button>
     </div>
    </div>
    <div class="bg-black rounded-lg overflow-hidden">
     <div id="reading-progress" class="progress-bar"></div>
     <div id="reader-content" class="reading-page py-4"><!-- Les pages du chapitre seront ajout√©es ici -->
     </div>
     <!-- Section Commentaires -->
     <div id="comments-section" class="mt-8 border-t border-gray-200 dark-mode:border-gray-700 pt-8">
      <h3 class="text-2xl font-bold mb-4 text-gray-900 dark-mode:text-gray-100">Commentaires</h3>
      <div class="mb-4 flex items-center space-x-3">
       <input type="text" id="comment-search" class="flex-1 px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field" placeholder="üîç Rechercher dans les commentaires...">
       <select id="comment-filter" class="px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600 input-field">
        <option value="all">Tous</option>
        <option value="recent">Plus r√©cent</option>
        <option value="oldest">Plus ancien</option>
       </select>
      </div>
      <div id="comments-list" class="space-y-4 mb-6"><!-- Les commentaires seront ajout√©s ici -->
      </div>
      <div class="bg-gray-50 dark-mode:bg-gray-900 rounded-lg p-4 border border-gray-300 dark-mode:border-gray-600">
       <h4 class="font-semibold mb-3 text-gray-900 dark-mode:text-gray-100">Ajouter un commentaire</h4>
       <div class="flex items-start space-x-2 mb-3">
       <textarea id="comment-text" rows="3" class="flex-1 px-4 py-2 border border-gray-300 dark-mode:border-gray-600 rounded-lg focus:ring-2 focus:ring-indigo-600 bg-white dark-mode:bg-gray-800 text-gray-900 dark-mode:text-gray-100 placeholder-gray-500 dark-mode:placeholder-gray-400" placeholder="Votre commentaire..."></textarea>
       <button onclick="openEmojiPicker()" class="px-3 py-2 bg-gray-200 dark-mode:bg-gray-700 text-gray-700 dark-mode:text-gray-200 rounded-lg hover:bg-gray-300 dark-mode:hover:bg-gray-600 transition-colors text-2xl" title="Ajouter un emoji">
        üòä
       </button>
      </div>
      <div class="mb-3">
       <button onclick="openGalleryForComment()" class="px-4 py-2 bg-gray-200 dark-mode:bg-gray-700 text-gray-700 dark-mode:text-gray-200 rounded-lg hover:bg-gray-300 dark-mode:hover:bg-gray-600 transition-colors">
        üì∑ Ajouter une image de la galerie
       </button>
        <div id="comment-images-preview" class="mt-2 flex flex-wrap gap-2"></div>
       </div>
       <div class="flex justify-end">
        <button onclick="addComment()" class="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors">
         Publier
        </button>
       </div>
      </div>
     </div>
    </div>
   </div>
  </main><!-- Modal: Ajouter un Manhwa -->
  <div id="add-manhwa-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
   <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90%] overflow-y-auto">
    <div class="p-6 border-b">
     <div class="flex justify-between items-center">
      <h2 class="text-2xl font-bold">Ajouter un Manhwa</h2><button id="close-manhwa-modal" class="text-gray-400 hover:text-gray-600">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
       </svg></button>
     </div>
    </div>
    <form id="add-manhwa-form" class="p-6">
     <div class="mb-4"><label for="manhwa-title" class="block text-sm font-medium mb-2">Titre du Manhwa</label> <input type="text" id="manhwa-title" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Solo Leveling" required>
     </div>
     <div class="mb-4"><label for="manhwa-cover-url" class="block text-sm font-medium mb-2">üì∑ Chemin de l'image de couverture</label> <input type="text" id="manhwa-cover-url" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Image/passion.jpg" required>
      <p class="text-xs text-gray-500 mt-1">üí° Entrez le chemin du fichier image (ex: Image/passion.jpg ou Image/mon-manhwa.png)</p>
      <div id="image-preview" class="mt-2 hidden"><img id="preview-img" class="w-32 h-40 object-cover rounded-lg shadow-md" alt="Aper√ßu">
      </div>
     </div>
     <div class="mb-4"><label for="manhwa-season" class="block text-sm font-medium mb-2">Saison (optionnel)</label> <input type="text" id="manhwa-season" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Saison 1, Saison 2...">
     </div>
     <div class="mb-6"><label for="manhwa-description" class="block text-sm font-medium mb-2">Description</label> <textarea id="manhwa-description" rows="3" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Description du manhwa..." required></textarea>
     </div>
         <div class="mb-4"><label for="manhwa-folder-select" class="block text-sm font-medium mb-2">Dossier de chapitres (optionnel)</label>
             <select id="manhwa-folder-select" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600">
                     <option value="">-- Aucun --</option>
             </select>
             <p class="text-xs text-gray-500 mt-1">Si vous choisissez un dossier, le site cr√©era automatiquement les chapitres pr√©sents.</p>
         </div>
     <div class="flex justify-end space-x-3"><button type="button" id="cancel-manhwa" class="px-4 py-2 border rounded-lg hover:bg-gray-100">Annuler</button> <button type="submit" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700"> <span id="manhwa-submit-text">Ajouter</span> <span id="manhwa-loading" class="hidden"> <span class="inline-block loading-spinner w-5 h-5"></span> </span> </button>
     </div>
    </form>
   </div>
  </div><!-- Modal: Ajouter un Chapitre -->
  <div id="add-chapter-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
   <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90%] overflow-y-auto">
    <div class="p-6 border-b">
     <div class="flex justify-between items-center">
      <h2 class="text-2xl font-bold">Ajouter un Chapitre</h2><button id="close-chapter-modal" class="text-gray-400 hover:text-gray-600">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
       </svg></button>
     </div>
    </div>
    <form id="add-chapter-form" class="p-6">
     <div class="mb-4"><label for="chapter-number" class="block text-sm font-medium mb-2">Num√©ro du Chapitre</label> <input type="number" id="chapter-number" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="1" required>
     </div>
     <div class="mb-4"><label for="chapter-title" class="block text-sm font-medium mb-2">Titre du Chapitre</label> <input type="text" id="chapter-title" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Le R√©veil" required>
     </div>
     <div class="mb-4"><label for="chapter-description" class="block text-sm font-medium mb-2">Description (optionnel)</label> <textarea id="chapter-description" rows="2" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Courte description du chapitre..."></textarea>
     </div>
     <div class="mb-4"><label for="chapter-season-add" class="block text-sm font-medium mb-2">Saison (optionnel)</label> <input type="text" id="chapter-season-add" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Saison 1, Saison 2...">
     </div>
     <div class="mb-4"><label for="chapter-cover-add" class="block text-sm font-medium mb-2">üì∑ Image de couverture (optionnel)</label> <input type="text" id="chapter-cover-add" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Image/chapitre-special.jpg">
      <p class="text-xs text-gray-500 mt-1">üí° Laissez vide pour utiliser l'image de couverture du manhwa par d√©faut. Sinon, entrez le chemin (ex: Image/chapitre-special.jpg)</p>
      <div id="chapter-cover-add-preview" class="mt-2 hidden"><img id="chapter-cover-add-preview-img" class="w-32 h-40 object-cover rounded-lg shadow-md" alt="Aper√ßu">
      </div>
     </div>
         <div class="mb-6">
             <label for="chapter-folder-select" class="block text-sm font-medium mb-2">üìÅ Dossier du chapitre (choisir dans `chapitres/`)</label>
             <select id="chapter-folder-select" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600">
                 <option value="">-- Choisir manhwa / chapitre --</option>
             </select>
             <p class="text-xs text-gray-500 mt-1">üí° S√©lectionnez le dossier du manhwa puis le sous-dossier du num√©ro de chapitre (ex: <code>passion/1</code>)</p>
             <div id="mhtml-legacy-container" class="mt-3">
                 <label for="mhtml-path" class="block text-sm font-medium mb-2">(Optionnel) Chemin du fichier MHTML</label>
                 <input type="text" id="mhtml-path" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="chapitres/qqq/6.mhtml">
                 <p class="text-xs text-gray-500 mt-1">üí° Si vous utilisez encore un fichier MHTML, collez le chemin. Sinon laissez vide.</p>
             </div>
      <div id="mhtml-status" class="hidden mt-4">
       <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <div class="flex items-center">
         <div class="loading-spinner w-5 h-5 mr-3"></div>
         <p class="text-blue-700 font-medium">Chargement et extraction des images...</p>
        </div>
       </div>
      </div>
      <div id="mhtml-preview" class="hidden mt-4">
       <div class="bg-green-50 border border-green-200 rounded-lg p-4 mb-3">
        <p class="text-green-700 font-bold">‚úÖ <span id="mhtml-count">0</span> images extraites!</p>
       </div>
       <div id="mhtml-preview-grid" class="grid grid-cols-4 gap-2"><!-- Aper√ßus des images MHTML -->
       </div>
      </div>
     </div>
     <div class="flex justify-end space-x-3"><button type="button" id="cancel-chapter" class="px-4 py-2 border rounded-lg hover:bg-gray-100">Annuler</button> <button type="submit" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700"> <span id="chapter-submit-text">Ajouter Chapitre</span> <span id="chapter-loading" class="hidden"> <span class="inline-block loading-spinner w-5 h-5"></span> </span> </button>
     </div>
    </form>
   </div>
  </div><!-- Modal: Modifier un Manhwa -->
  <div id="edit-manhwa-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
   <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90%] overflow-y-auto">
    <div class="p-6 border-b">
     <div class="flex justify-between items-center">
      <h2 class="text-2xl font-bold">Modifier le Manhwa</h2><button id="close-edit-manhwa-modal" class="text-gray-400 hover:text-gray-600">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
       </svg></button>
     </div>
    </div>
    <form id="edit-manhwa-form" class="p-6">
     <div class="mb-4"><label for="edit-manhwa-title" class="block text-sm font-medium mb-2">Titre du Manhwa</label> <input type="text" id="edit-manhwa-title" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" required>
     </div>
     <div class="mb-4"><label for="edit-manhwa-cover-url" class="block text-sm font-medium mb-2">üì∑ Chemin de l'image de couverture</label> <input type="text" id="edit-manhwa-cover-url" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Image/passion.jpg" required>
      <p class="text-xs text-gray-500 mt-1">üí° Entrez le chemin du fichier image (ex: Image/passion.jpg ou Image/mon-manhwa.png)</p>
      <div id="edit-image-preview" class="mt-2 hidden"><img id="edit-preview-img" class="w-32 h-40 object-cover rounded-lg shadow-md" alt="Aper√ßu">
      </div>
     </div>
     <div class="mb-4"><label for="edit-manhwa-season" class="block text-sm font-medium mb-2">Saison (optionnel)</label> <input type="text" id="edit-manhwa-season" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Saison 1, Saison 2...">
     </div>
     <div class="mb-6"><label for="edit-manhwa-description" class="block text-sm font-medium mb-2">Description</label> <textarea id="edit-manhwa-description" rows="3" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" required></textarea>
     </div>
     <div class="flex justify-end space-x-3"><button type="button" id="cancel-edit-manhwa" class="px-4 py-2 border rounded-lg hover:bg-gray-100">Annuler</button> <button type="submit" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700"> <span id="edit-manhwa-submit-text">Modifier</span> <span id="edit-manhwa-loading" class="hidden"> <span class="inline-block loading-spinner w-5 h-5"></span> </span> </button>
     </div>
    </form>
   </div>
  </div><!-- Modal: Modifier un Chapitre -->
  <div id="edit-chapter-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
   <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90%] overflow-y-auto">
    <div class="p-6 border-b">
     <div class="flex justify-between items-center">
      <h2 class="text-2xl font-bold">Modifier le Chapitre</h2><button id="close-edit-chapter-modal" class="text-gray-400 hover:text-gray-600">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
       </svg></button>
     </div>
    </div>
    <form id="edit-chapter-form" class="p-6">
     <div class="mb-4"><label for="edit-chapter-number" class="block text-sm font-medium mb-2">Num√©ro du Chapitre</label> <input type="number" id="edit-chapter-number" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" required>
     </div>
    <div class="mb-4"><label for="edit-chapter-title" class="block text-sm font-medium mb-2">Titre du Chapitre (optionnel)</label> <input type="text" id="edit-chapter-title" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600">
     </div>
     <div class="mb-4"><label for="edit-chapter-description" class="block text-sm font-medium mb-2">Description (optionnel)</label> <textarea id="edit-chapter-description" rows="2" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600"></textarea>
     </div>
     <div class="mb-4"><label for="edit-chapter-season" class="block text-sm font-medium mb-2">Saison (optionnel)</label> <input type="text" id="edit-chapter-season" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Saison 1, Saison 2...">
     </div>
     <div class="mb-4"><label for="edit-chapter-cover" class="block text-sm font-medium mb-2">üì∑ Image de couverture (optionnel)</label> <input type="text" id="edit-chapter-cover" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Image/chapitre-special.jpg">
      <p class="text-xs text-gray-500 mt-1">üí° Laissez vide pour utiliser l'image de couverture du manhwa par d√©faut. Sinon, entrez le chemin (ex: Image/chapitre-special.jpg)</p>
      <div id="edit-chapter-cover-preview" class="mt-2 hidden"><img id="edit-chapter-preview-img" class="w-32 h-40 object-cover rounded-lg shadow-md" alt="Aper√ßu">
      </div>
     </div>
    <!-- Removed option to choose MHTML / chapter selection to simplify editing -->
     <div class="flex justify-end space-x-3"><button type="button" id="cancel-edit-chapter" class="px-4 py-2 border rounded-lg hover:bg-gray-100">Annuler</button> <button type="submit" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700"> <span id="edit-chapter-submit-text">Modifier</span> <span id="edit-chapter-loading" class="hidden"> <span class="inline-block loading-spinner w-5 h-5"></span> </span> </button>
     </div>
    </form>
   </div>
  </div><!-- Modal: Ajouter/Modifier un Suivi -->
    <!-- Modal: Chapitres manquants -->
    <div id="missing-chapters-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
     <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full mx-4 p-6">
        <div class="flex justify-between items-center mb-4">
         <h2 class="text-2xl font-bold">Chapitres manquants</h2>
         <button id="close-missing-chapters" class="text-gray-400 hover:text-gray-600">‚úï</button>
        </div>
        <div class="mb-4">
         <label class="block text-sm font-medium mb-2">Dernier chapitre connu (max)</label>
         <input id="missing-max-input" type="number" min="1" class="input-field w-full px-4 py-2 border rounded-lg" placeholder="Entrez le num√©ro du dernier chapitre (ex: 20)">
        </div>
        <div class="mb-4">
         <button id="missing-check-btn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg">V√©rifier</button>
         <button id="missing-create-btn" class="bg-emerald-500 text-white px-4 py-2 rounded-lg ml-2">Cr√©er les chapitres manquants</button>
        </div>
        <div id="missing-results" class="mt-4 text-sm text-gray-700"></div>
     </div>
    </div>
  <div id="tracking-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
   <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[90%] overflow-y-auto">
    <div class="p-6 border-b">
     <div class="flex justify-between items-center">
      <h2 class="text-2xl font-bold" id="tracking-modal-title">Ajouter un Suivi</h2><button id="close-tracking-modal" class="text-gray-400 hover:text-gray-600">
       <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
       </svg></button>
     </div>
    </div>
    <form id="tracking-form" class="p-6">
     <div class="mb-4"><label for="tracking-title" class="block text-sm font-medium mb-2">Titre du Manhwa</label> <input type="text" id="tracking-title" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Solo Leveling" required>
     </div>
     <div class="mb-4"><label for="tracking-chapter" class="block text-sm font-medium mb-2">Chapitre actuel</label> <input type="number" id="tracking-chapter" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="1" min="0" required>
     </div>
     <div class="mb-4"><label for="tracking-status" class="block text-sm font-medium mb-2">Statut</label> <select id="tracking-status" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600">
      <option value="en-cours">En cours</option>
      <option value="fini">Fini</option>
      <option value="en-pause">En pause</option>
     </select>
     </div>
     <div class="mb-4"><label for="tracking-season" class="block text-sm font-medium mb-2">Saison (optionnel)</label> <input type="text" id="tracking-season" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Ex: Saison 1, Saison 2...">
     </div>
     <div class="mb-6"><label for="tracking-notes" class="block text-sm font-medium mb-2">Notes (optionnel)</label> <textarea id="tracking-notes" rows="3" class="input-field w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-600" placeholder="Notes personnelles..."></textarea>
     </div>
     <div class="flex justify-end space-x-3"><button type="button" id="cancel-tracking" class="px-4 py-2 border rounded-lg hover:bg-gray-100">Annuler</button> <button type="submit" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700"> <span id="tracking-submit-text">Ajouter</span> <span id="tracking-loading" class="hidden"> <span class="inline-block loading-spinner w-5 h-5"></span> </span> </button>
     </div>
    </form>
   </div>
  </div><!-- Settings Panel -->
  <div id="settings-panel" class="fixed top-16 right-0 h-full w-80 bg-white shadow-lg transform translate-x-full transition-transform duration-300 z-40">
   <div class="p-6">
    <div class="flex justify-between items-center mb-6">
     <h2 class="text-xl font-bold">Param√®tres</h2><button id="close-settings" class="p-1 hover:bg-gray-100 rounded">
      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
      </svg></button>
    </div><!-- Mode sombre -->
    <div class="mb-6">
     <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
      <div class="flex items-center">
       <svg id="theme-icon" class="w-5 h-5 mr-3 text-indigo-600" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>
       </svg>
       <div>
        <h3 class="font-semibold">Mode sombre</h3>
        <p class="text-xs text-gray-500">Th√®me de l'interface</p>
       </div>
      </div><button id="theme-toggle" class="relative inline-flex items-center h-6 rounded-full w-11 bg-gray-300 transition-colors"> <span id="toggle-circle" class="inline-block w-4 h-4 transform translate-x-1 bg-white rounded-full transition-transform"></span> </button>
     </div>
    </div><!-- Ajouter manhwa -->
    <div id="add-manhwa-settings-container" class="mb-6"><button id="add-manhwa-settings" class="w-full flex items-center justify-between p-4 bg-indigo-50 hover:bg-indigo-100 rounded-lg transition-colors">
      <div class="flex items-center">
       <svg class="w-5 h-5 mr-3 text-indigo-600" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
       </svg>
       <div class="text-left">
        <h3 class="font-semibold text-indigo-900">Ajouter un Manhwa</h3>
        <p class="text-xs text-indigo-600">Nouveau manhwa √† lire</p>
       </div>
      </div>
      <svg class="w-5 h-5 text-indigo-600" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
      </svg></button>
    </div><!-- Statistiques -->
    <!-- Reader options -->
    <div class="mt-6 mb-6 p-4 bg-gray-50 rounded-lg">
     <h3 class="font-semibold mb-3 text-sm text-gray-500 uppercase">Lecteur</h3>
     <div class="flex items-center justify-between">
      <div>
       <p class="text-sm font-medium">Afficher boutons Zoom</p>
       <p class="text-xs text-gray-500">Affiche des boutons Zoom In / Zoom Out dans le lecteur</p>
      </div>
      <div>
       <input type="checkbox" id="reader-zoom-buttons-toggle" class="h-4 w-4">
      </div>
     </div>
    </div>
    <!-- place where registerSyncInSettings will add the sync button -->
    <div class="mt-8 p-4 bg-gray-50 rounded-lg">
     <h3 class="font-semibold mb-3 text-sm text-gray-500 uppercase">Statistiques</h3>
     <div class="space-y-2">
      <div class="flex justify-between"><span class="text-sm">Manhwas</span> <span id="stats-manhwas" class="font-bold text-indigo-600">0</span>
      </div>
      <div class="flex justify-between"><span class="text-sm">Chapitres</span> <span id="stats-chapters" class="font-bold text-indigo-600">0</span>
      </div>
     </div>
    </div>
   </div>
  </div><!-- Loading Overlay -->
  <div id="loading-overlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
   <div class="bg-white rounded-lg p-8 flex flex-col items-center">
    <div class="loading-spinner mb-4"></div>
    <p class="text-gray-700 font-medium">Chargement...</p>
   </div>
  </div>
 

  <script type="module">
        // Importer l'abstraction API (supporte MySQL local et Supabase en ligne)
        import { CommentsAPI, ManhwasAPI, ChaptersAPI, supabase } from './api-client.js';
        import { registerSyncInSettings, autoCreateChaptersFromFolder, registerHeaderSyncButton } from './local-sync.js';
        
        // Configuration et √©tat global
        let galleryImages = [];
        let currentManhwaId = null;
        let currentChapterNumber = null;
        let allManhwas = [];
        let allChapters = [];
        let isDarkMode = false;
        let isLocalMode = false;
        let currentUserId = null; // Identifiant utilisateur pour donn√©es propres (mode en ligne)
        
        // Exposer CommentsAPI au scope global pour les autres modules
        window.CommentsAPI = CommentsAPI;
        // Initialiser le bouton de synchronisation dans Param√®tres (si local)
        try { if (typeof registerSyncInSettings === 'function') registerSyncInSettings(); } catch(e) { console.warn('registerSyncInSettings call failed', e); }
        try { if (typeof registerHeaderSyncButton === 'function') registerHeaderSyncButton(); } catch(e) { console.warn('registerHeaderSyncButton call failed', e); }

        function getCurrentUserId() {
            if (currentUserId) return currentUserId;
            try {
                let id = localStorage.getItem('user_id');
                if (!id) {
                    id = 'user_' + Date.now() + '_' + Math.random().toString(36).substring(2,10);
                    localStorage.setItem('user_id', id);
                }
                currentUserId = id;
                return currentUserId;
            } catch (e) {
                // En cas d'erreur (storage bloqu√©), g√©n√©rer un id en session
                currentUserId = 'user_session_' + Date.now();
                return currentUserId;
            }
        }
        
        // D√©tection du mode d√©veloppeur (localhost)
        function isDeveloperMode() {
            const hostname = window.location.hostname;
            return hostname === 'localhost' || 
                   hostname === '127.0.0.1' || 
                   hostname === '' ||
                   hostname.startsWith('192.168.') ||
                   hostname.startsWith('10.') ||
                   hostname.startsWith('172.');
        }
        
        // Fonction pour afficher le popup "vous n'√™tes pas en mode d√©veloppeur"
        function showDeveloperModeRequired() {
            const dialog = document.createElement('div');
            dialog.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            dialog.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl max-w-md mx-4 p-6">
                    <div class="flex items-center mb-4">
                        <svg class="w-8 h-8 text-orange-500 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                        </svg>
                        <h3 class="text-xl font-bold">Mode d√©veloppeur requis</h3>
                    </div>
                    <p class="text-gray-600 mb-6">
                        Vous n'√™tes pas en mode d√©veloppeur. La cr√©ation, modification et suppression de manhwas et chapitres est uniquement disponible en localhost.
                    </p>
                    <p class="text-sm text-gray-500 mb-6">
                        Pour ajouter, modifier ou supprimer des manhwas/chapitres, ouvrez le site en localhost. Utilisez la section "Suivi" pour suivre votre progression en ligne.
                    </p>
                    <div class="flex justify-end">
                        <button id="close-dev-mode-dialog" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700">
                            Compris
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
            
            dialog.querySelector('#close-dev-mode-dialog').onclick = () => {
                dialog.remove();
            };
            
            // Fermer en cliquant en dehors
            dialog.onclick = (e) => {
                if (e.target === dialog) {
                    dialog.remove();
                }
            };
        }

        // √âl√©ments DOM
        const menuBtn = document.getElementById('menu-btn');
        const sidebar = document.getElementById('sidebar');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsPanel = document.getElementById('settings-panel');
        const closeSettings = document.getElementById('close-settings');
        const themeToggle = document.getElementById('theme-toggle');
        const themeIcon = document.getElementById('theme-icon');
        const toggleCircle = document.getElementById('toggle-circle');
        const addManhwaSettings = document.getElementById('add-manhwa-settings');
        const addManhwaModal = document.getElementById('add-manhwa-modal');
        const closeManhwaModal = document.getElementById('close-manhwa-modal');
        const addManhwaForm = document.getElementById('add-manhwa-form');
        const addChapterModal = document.getElementById('add-chapter-modal');
        const closeChapterModal = document.getElementById('close-chapter-modal');
        const addChapterForm = document.getElementById('add-chapter-form');
        const navItems = document.querySelectorAll('.nav-item');

        // Reader zoom state
        let readerGlobalScale = 1;

        function isZoomButtonsEnabled() {
            try { return localStorage.getItem('reader_show_zoom_buttons') === 'true'; } catch (e) { return false; }
        }

        function setZoomButtonsEnabled(v) {
            try { localStorage.setItem('reader_show_zoom_buttons', v ? 'true' : 'false'); } catch (e) {}
        }

        function createReaderZoomControls() {
            // remove existing controls
            const existing = document.querySelector('.reader-zoom-controls');
            if (existing) existing.remove();

            if (!isZoomButtonsEnabled()) return;

            const container = document.createElement('div');
            container.className = 'reader-zoom-controls';
            container.style.position = 'fixed';
            // Place controls bottom-left so they don't cover the settings panel on the right
            container.style.left = '20px';
            container.style.bottom = '70px';
            container.style.zIndex = '9999';
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            container.style.gap = '6px';

            const btnStyles = 'width:44px;height:44px;font-size:18px;border-radius:6px;border:1px solid rgba(0,0,0,0.1);background:#fff;box-shadow:0 1px 3px rgba(0,0,0,0.1);cursor:pointer';

            const btnZoomIn = document.createElement('button');
            btnZoomIn.innerHTML = '+';
            btnZoomIn.title = 'Zoom In';
            btnZoomIn.style.cssText = btnStyles;
            btnZoomIn.addEventListener('click', () => {
                readerGlobalScale = Math.min(3, Math.round((readerGlobalScale + 0.1) * 10) / 10);
                applyReaderScale();
            });

            const btnZoomOut = document.createElement('button');
            btnZoomOut.innerHTML = '‚àí';
            btnZoomOut.title = 'Zoom Out';
            btnZoomOut.style.cssText = btnStyles;
            btnZoomOut.addEventListener('click', () => {
                readerGlobalScale = Math.max(0.2, Math.round((readerGlobalScale - 0.1) * 10) / 10);
                applyReaderScale();
            });

            const btnReset = document.createElement('button');
            btnReset.innerHTML = '‚ü≤';
            btnReset.title = 'Reset Zoom';
            btnReset.style.cssText = btnStyles;
            btnReset.addEventListener('click', () => {
                readerGlobalScale = 1;
                applyReaderScale();
            });

            container.appendChild(btnZoomIn);
            container.appendChild(btnZoomOut);
            container.appendChild(btnReset);

            document.body.appendChild(container);
        }

        // Appliquer l'√©chelle globale du lecteur √† toutes les images affich√©es
        function applyReaderScale() {
            try {
                const readerContent = document.getElementById('reader-content');
                if (!readerContent) return;
                const imgs = readerContent.querySelectorAll('.reader-image-wrapper img');
                imgs.forEach(img => {
                    // Apply zoom by changing max-width so the layout reflows and images stay contiguous
                    try {
                        const wrapper = img.closest('.reader-image-wrapper');
                        const base = parseFloat(wrapper?.dataset?.baseWidth) || 450;
                        const newMax = Math.max(20, Math.round(base * readerGlobalScale));
                        img.style.maxWidth = newMax + 'px';
                        img.dataset.scale = String(readerGlobalScale);
                    } catch (ee) {
                        // Fallback: apply max-width directly
                        img.style.maxWidth = (450 * readerGlobalScale) + 'px';
                    }
                });
                // Update progress/visuals if necessary
                updateProgress();
            } catch (e) {
                console.warn('applyReaderScale error', e);
            }
        }

        // Variable globale pour stocker les donn√©es
        let globalData = [];
        let saveTimeout = null; // Timeout pour debounce de la sauvegarde
        
        // Fonction pour sauvegarder automatiquement dans data.php (avec debounce)
        function scheduleAutoSave(data) {
            if (!isDeveloperMode()) {
                return;
            }
            
            // Annuler la sauvegarde pr√©c√©dente si elle n'a pas encore √©t√© ex√©cut√©e
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            
            // Programmer la sauvegarde apr√®s 300ms d'inactivit√© (r√©duit pour plus de r√©activit√©)
            saveTimeout = setTimeout(async () => {
                await saveDataToFileAuto(data);
            }, 300);
        }
        
        // Fonction pour sauvegarder automatiquement dans data.php via PHP
        async function saveDataToFileAuto(data) {
            if (!isDeveloperMode()) {
                return;
            }
            
            try {
                const response = await fetch('save-data.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                if (result.success) {
                    console.log('‚úÖ data.php sauvegard√© automatiquement');
                } else {
                    console.error('Erreur lors de la sauvegarde:', result.message);
                }
            } catch (error) {
                console.error('Erreur lors de la sauvegarde automatique:', error);
            }
        }

        // SDK MySQL - Utilise la base de donn√©es MySQL via PHP
        function createMySQLSDK() {
            let localData = [];
            let dataHandler = null;

            return {
                init: async (handler) => {
                    dataHandler = handler;
                    
                    // Charger TOUTES les donn√©es depuis MySQL
                    try {
                        const response = await fetch('./api-all-data.php?t=' + Date.now(), {
                            cache: 'no-cache',
                            headers: {
                                'Cache-Control': 'no-cache'
                            }
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            if (result.success && Array.isArray(result.data)) {
                                localData = result.data;
                                console.log('‚úÖ Donn√©es charg√©es depuis MySQL:', localData.length, '√©l√©ments');
                            } else {
                                console.warn('‚ö†Ô∏è R√©ponse MySQL invalide');
                                localData = [];
                            }
                        } else {
                            console.error('‚ö†Ô∏è Erreur HTTP lors du chargement MySQL:', response.status);
                            // En cas d'erreur, essayer de charger depuis data.php comme fallback
                            try {
                                const jsonResponse = await fetch('./data.php?t=' + Date.now());
                                if (jsonResponse.ok) {
                                    const jsonData = await jsonResponse.json();
                                    localData = Array.isArray(jsonData) ? jsonData : [];
                                    console.log('‚ö†Ô∏è Fallback: donn√©es charg√©es depuis data.php:', localData.length, '√©l√©ments');
                                }
                            } catch (e) {
                                console.error('‚ö†Ô∏è Erreur fallback data.php:', e);
                                localData = [];
                            }
                        }
                    } catch (error) {
                        console.error('‚ö†Ô∏è Erreur lors du chargement MySQL:', error);
                        // Fallback vers data.php
                        try {
                            const jsonResponse = await fetch('./data.php?t=' + Date.now());
                            if (jsonResponse.ok) {
                                const jsonData = await jsonResponse.json();
                                localData = Array.isArray(jsonData) ? jsonData : [];
                                console.log('‚ö†Ô∏è Fallback: donn√©es charg√©es depuis data.php');
                            }
                        } catch (e) {
                            localData = [];
                        }
                    }
                    
                    // Toujours synchroniser globalData avec localData
                    globalData = JSON.parse(JSON.stringify(localData));
                    console.log('‚úÖ Donn√©es charg√©es et synchronis√©es:', globalData.length, '√©l√©ments');
                    
                    // Notifier le handler avec les donn√©es charg√©es IMM√âDIATEMENT
                        if (dataHandler) {
                        requestAnimationFrame(() => {
                            dataHandler.onDataChanged(localData);
                        });
                        }
                    
                    return { isOk: true };
                },
                create: async (data) => {
                    if (!isDeveloperMode()) {
                        return { isOk: false, error: 'Mode d√©veloppeur requis' };
                    }
                    
                    data.__backendId = 'local_' + Date.now() + '_' + Math.random();
                    
                    // D√©terminer le type et sauvegarder dans MySQL
                    let apiUrl = '';
                    if (data.manhwa_title && !data.chapter_number) {
                        // C'est un manhwa
                        apiUrl = './api-manhwas.php';
                    } else if (data.chapter_number !== undefined) {
                        // C'est un chapitre
                        apiUrl = './api-chapters.php';
                    } else {
                        // Autre type (tracking, trash) - utiliser l'ancien syst√®me pour l'instant
                    localData.push(data);
                        globalData = JSON.parse(JSON.stringify(localData));
                        if (dataHandler) {
                            dataHandler.onDataChanged(localData);
                        }
                        saveDataToFileAuto(globalData).catch(err => {
                            console.error('Erreur sauvegarde:', err);
                        });
                        return { isOk: true };
                    }
                    
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(data)
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            // Recharger toutes les donn√©es depuis MySQL
                            const allDataResponse = await fetch('./api-all-data.php?t=' + Date.now());
                            if (allDataResponse.ok) {
                                const allDataResult = await allDataResponse.json();
                                if (allDataResult.success) {
                                    localData = allDataResult.data;
                                    globalData = JSON.parse(JSON.stringify(localData));
                                    
                                    // Mettre √† jour imm√©diatement
                    if (dataHandler) {
                                        dataHandler.onDataChanged(localData);
                                    }
                                    
                                    console.log('‚úÖ √âl√©ment cr√©√© et synchronis√© avec MySQL');
                                    return { isOk: true };
                                }
                            }
                        } else {
                            console.error('‚ùå Erreur cr√©ation MySQL:', result.error);
                            return { isOk: false, error: result.error };
                        }
                    } catch (error) {
                        console.error('‚ùå Erreur lors de la cr√©ation:', error);
                        return { isOk: false, error: error.message };
                    }
                    
                    return { isOk: true };
                },
                update: async (record) => {
                    // MODIFICATIONS AUTORIS√âES UNIQUEMENT EN MODE D√âVELOPPEUR (sauf pour le suivi qui utilise localStorage)
                    if (!isDeveloperMode()) {
                        return { isOk: false, error: 'Mode d√©veloppeur requis pour les modifications' };
                    }
                    
                    // D√©terminer le type et mettre √† jour dans MySQL
                    let apiUrl = '';
                    if (record.manhwa_title && !record.chapter_number) {
                        // C'est un manhwa
                        apiUrl = './api-manhwas.php';
                    } else if (record.chapter_number !== undefined) {
                        // C'est un chapitre
                        apiUrl = './api-chapters.php';
                    } else {
                        // Autre type - utiliser l'ancien syst√®me
                    const index = localData.findIndex(item => item.__backendId === record.__backendId);
                    if (index !== -1) {
                        localData[index] = record;
                            globalData = JSON.parse(JSON.stringify(localData));
                        if (dataHandler) {
                                dataHandler.onDataChanged(localData);
                            }
                            saveDataToFileAuto(globalData).catch(err => {
                                console.error('Erreur sauvegarde:', err);
                            });
                        }
                        return { isOk: true };
                    }
                    
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(record)
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            // Recharger toutes les donn√©es depuis MySQL
                            const allDataResponse = await fetch('./api-all-data.php?t=' + Date.now());
                            if (allDataResponse.ok) {
                                const allDataResult = await allDataResponse.json();
                                if (allDataResult.success) {
                                    localData = allDataResult.data;
                                    globalData = JSON.parse(JSON.stringify(localData));
                                    
                                    // Mettre √† jour imm√©diatement
                                    if (dataHandler) {
                                        dataHandler.onDataChanged(localData);
                                    }
                                    
                                    console.log('‚úÖ √âl√©ment mis √† jour dans MySQL');
                                    return { isOk: true };
                                }
                            }
                        } else {
                            console.error('‚ùå Erreur mise √† jour MySQL:', result.error);
                            return { isOk: false, error: result.error };
                        }
                    } catch (error) {
                        console.error('‚ùå Erreur lors de la mise √† jour:', error);
                        return { isOk: false, error: error.message };
                    }
                    
                    return { isOk: true };
                },
                delete: async (record) => {
                    if (!isDeveloperMode()) {
                        return { isOk: false, error: 'Mode d√©veloppeur requis' };
                    }
                    
                    // D√©terminer le type et supprimer dans MySQL
                    let apiUrl = '';
                    if (record.manhwa_title && !record.chapter_number) {
                        // C'est un manhwa
                        apiUrl = './api-manhwas.php';
                    } else if (record.chapter_number !== undefined) {
                        // C'est un chapitre
                        apiUrl = './api-chapters.php';
                    } else {
                        // Autre type - utiliser l'ancien syst√®me
                    localData = localData.filter(item => item.__backendId !== record.__backendId);
                        globalData = JSON.parse(JSON.stringify(localData));
                    if (dataHandler) {
                            dataHandler.onDataChanged(localData);
                        }
                        saveDataToFileAuto(globalData).catch(err => {
                            console.error('Erreur sauvegarde:', err);
                        });
                        return { isOk: true };
                    }
                    
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'DELETE',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(record)
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            // Recharger toutes les donn√©es depuis MySQL
                            const allDataResponse = await fetch('./api-all-data.php?t=' + Date.now());
                            if (allDataResponse.ok) {
                                const allDataResult = await allDataResponse.json();
                                if (allDataResult.success) {
                                    localData = allDataResult.data;
                                    globalData = JSON.parse(JSON.stringify(localData));
                                    
                                    // Mettre √† jour imm√©diatement
                                    if (dataHandler) {
                                        dataHandler.onDataChanged(localData);
                                    }
                                    
                                    console.log('‚úÖ √âl√©ment supprim√© de MySQL');
                                    return { isOk: true };
                                }
                            }
                        } else {
                            console.error('‚ùå Erreur suppression MySQL:', result.error);
                            return { isOk: false, error: result.error };
                        }
                    } catch (error) {
                        console.error('‚ùå Erreur lors de la suppression:', error);
                        return { isOk: false, error: error.message };
                    }
                    
                    return { isOk: true };
                }
            };
        }

        // Initialisation du Data SDK
        const dataHandler = {
            onDataChanged(data) {
                console.log('üìä onDataChanged appel√© avec', data.length, '√©l√©ments');
                
                // Filtrer les manhwas (ont manhwa_id ET manhwa_title MAIS PAS chapter_number)
                const manhwas = data.filter(item => {
                    // Un manhwa a manhwa_id, manhwa_title, mais PAS chapter_number
                    return item.manhwa_id && 
                           item.manhwa_title && 
                           (item.chapter_number === undefined || item.chapter_number === null) &&
                           item.type !== 'tracking' && 
                           item.type !== 'trash';
                });
                
                // Filtrer les chapitres (ont chapter_number MAIS PAS manhwa_title)
                const chapters = data.filter(item => {
                    // Un chapitre a chapter_number mais PAS manhwa_title
                    return (item.chapter_number !== undefined && item.chapter_number !== null) &&
                           !item.manhwa_title &&
                           item.type !== 'tracking' && 
                           item.type !== 'trash';
                });
                
                console.log('üìö Manhwas trouv√©s:', manhwas.length);
                console.log('üìñ Chapitres trouv√©s:', chapters.length);
                
                allManhwas = manhwas;
                allChapters = chapters;
                
                // Charger les suivis depuis data.php
                loadTrackingList();
                
                // Mettre √† jour TOUTES les pages IMM√âDIATEMENT
                updateAllPages();
            }
        };

        // Protection contre F12 et inspecteur (uniquement en ligne)
        document.addEventListener('keydown', (e) => {
            if (!isDeveloperMode()) {
                // Bloquer F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
                if (e.key === 'F12' || 
                    (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) ||
                    (e.ctrlKey && e.key === 'U')) {
                    e.preventDefault();
                    return false;
                }
            }
        });
        
        // Protection contre le clic droit (uniquement en ligne)
        document.addEventListener('contextmenu', (e) => {
            if (!isDeveloperMode()) {
                e.preventDefault();
                return false;
            }
        });
        
        // Protection contre les iframes (emp√™cher le site d'√™tre int√©gr√©)
        if (window.top !== window.self && !isDeveloperMode()) {
            window.top.location = window.self.location;
        }
        
        // Authentification Google Drive (uniquement en ligne)
        let isGoogleDriveAuthenticated = false;
        let googleDriveAccessToken = null;
        
        async function initGoogleDriveAuth() {
            if (isDeveloperMode()) {
                // En localhost, pas besoin d'authentification
                isGoogleDriveAuthenticated = true;
                return;
            }
            
            // V√©rifier si l'utilisateur est d√©j√† authentifi√©
            const savedToken = localStorage.getItem('googleDriveToken');
            if (savedToken) {
                googleDriveAccessToken = savedToken;
                isGoogleDriveAuthenticated = true;
                return;
            }
            
            // Afficher le modal d'authentification
            showGoogleDriveAuthModal();
        }
        
        function showGoogleDriveAuthModal() {
            const modal = document.createElement('div');
            modal.id = 'google-drive-auth-modal';
            modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark-mode:bg-gray-800 rounded-xl shadow-2xl max-w-md w-full mx-4 p-6">
                    <h2 class="text-2xl font-bold mb-4 text-gray-900 dark-mode:text-gray-100">Authentification requise</h2>
                    <p class="text-gray-600 dark-mode:text-gray-300 mb-6">
                        Vous devez vous connecter avec votre compte Google Drive pour acc√©der √† ce site.
                        Vos donn√©es personnelles seront synchronis√©es avec votre Drive.
                    </p>
                    <div id="g_id_onload"
                         data-client_id="YOUR_GOOGLE_CLIENT_ID"
                         data-callback="handleGoogleDriveAuth"
                         data-auto_prompt="false">
                    </div>
                    <div class="g_id_signin" 
                         data-type="standard"
                         data-size="large"
                         data-theme="outline"
                         data-text="sign_in_with"
                         data-shape="rectangular"
                         data-logo_alignment="left">
                    </div>
                    <p class="text-xs text-gray-500 dark-mode:text-gray-400 mt-4">
                        En vous connectant, vous acceptez que vos donn√©es soient synchronis√©es avec Google Drive.
                    </p>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        window.handleGoogleDriveAuth = function(response) {
            if (response.credential) {
                // D√©coder le token JWT (simplifi√© - en production, v√©rifiez c√¥t√© serveur)
                googleDriveAccessToken = response.credential;
                localStorage.setItem('googleDriveToken', googleDriveAccessToken);
                isGoogleDriveAuthenticated = true;
                
                const modal = document.getElementById('google-drive-auth-modal');
                if (modal) modal.remove();
                
                showNotification('Authentification r√©ussie!', 'success');
                initializeApp();
            }
        };
        
        // Sauvegarder la page actuelle
        function saveCurrentPage() {
            const currentPage = document.querySelector('.page-content:not(.hidden)')?.id;
            if (currentPage) {
                const pageName = currentPage.replace('-page', '').replace('page-', '');
                localStorage.setItem('currentPage', pageName);
            }
        }
        
        // Restaurer la page actuelle
        function restoreCurrentPage() {
            const savedPage = localStorage.getItem('currentPage');
            console.log('üîÑ Tentative de restauration de la page:', savedPage);
            if (savedPage && savedPage !== 'home' && savedPage !== '' && savedPage !== null) {
                // Attendre que les pages soient charg√©es
                setTimeout(() => {
                    const pageElement = document.getElementById(`${savedPage}-page`);
                    if (pageElement) {
                        console.log('‚úÖ Restauration de la page:', savedPage);
                        // Ne pas sauvegarder √† nouveau lors de la restauration
                        document.querySelectorAll('.page-content').forEach(page => {
                            page.classList.add('hidden');
                        });
                        pageElement.classList.remove('hidden');
                    } else {
                        console.log('‚ö†Ô∏è Page non trouv√©e:', savedPage);
                    }
                }, 500);
            } else {
                console.log('‚ÑπÔ∏è Pas de page √† restaurer ou page d\'accueil');
            }
        }

        async function initializeApp() {
            // CACHER TOUTES LES PAGES IMM√âDIATEMENT pour √©viter de voir l'accueil
            document.querySelectorAll('.page-content').forEach(page => {
                page.classList.add('hidden');
            });
            
            // Masquer les boutons d'ajout si on n'est pas en mode d√©veloppeur
            if (!isDeveloperMode()) {
                const addManhwaContainer = document.getElementById('add-manhwa-settings-container');
                if (addManhwaContainer) {
                    addManhwaContainer.style.display = 'none';
                }
            }
            
            // D√©tection automatique: MySQL (recommand√©) ou fallback JSON
            if (!window.dataSdk) {
                console.log('üîß Mode LOCAL d√©tect√© - Utilisation de MySQL');
                isLocalMode = true;
                window.dataSdk = createMySQLSDK();
                if (isDeveloperMode()) {
                    showNotification('Mode d√©veloppeur activ√© üîß (MySQL)', 'info');
                }
            } else {
                console.log('‚òÅÔ∏è Mode CANVA d√©tect√© - Utilisation du Data SDK');
                isLocalMode = false;
            }

            const result = await window.dataSdk.init(dataHandler);
            // Nettoyage automatique des commentaires orphelins (mode d√©veloppeur/local uniquement)
            (async () => {
                try {
                    if (isDeveloperMode()) {
                        const cleanupResp = await fetch('cleanup-comments.php');
                        if (cleanupResp.ok) {
                            const cj = await cleanupResp.json();
                            if (cj && cj.success && cj.deleted_count && cj.deleted_count > 0) {
                                showNotification(`${cj.deleted_count} commentaires orphelins supprim√©s`, 'success');
                                console.log('cleanup-comments:', cj.deleted_ids || []);
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Erreur lors du nettoyage des commentaires orphelins', e);
                }
            })();
            
            // Charger la galerie
            loadGalleryImages();
            
            // Restaurer la page IMM√âDIATEMENT apr√®s chargement
            const savedPage = localStorage.getItem('currentPage');
            if (savedPage && savedPage !== 'home' && savedPage !== '' && savedPage !== null) {
                const pageElement = document.getElementById(`${savedPage}-page`);
                if (pageElement) {
                    // Restaurer imm√©diatement sans d√©lai
                    document.querySelectorAll('.page-content').forEach(page => {
                        page.classList.add('hidden');
                    });
                    pageElement.classList.remove('hidden');
                    console.log('‚úÖ Page restaur√©e imm√©diatement:', savedPage);
                    // Si on restaure la page de d√©tail, tenter de restaurer l'ID du manhwa
                    if (savedPage === 'manhwa-detail') {
                        const savedManhwaId = localStorage.getItem('currentManhwaId');
                        if (savedManhwaId) {
                            currentManhwaId = savedManhwaId;
                            // Afficher le d√©tail si les donn√©es sont charg√©es
                            try { showManhwaDetail(currentManhwaId); } catch (e) { console.warn('Impossible d\'afficher manhwa detail au chargement', e); }
                        }
                    } else if (savedPage === 'reader') {
                        // Restaurer le lecteur si l'utilisateur √©tait en train de lire
                        const savedManhwaId = localStorage.getItem('currentManhwaId');
                        const savedChapterNumber = localStorage.getItem('currentChapterNumber');
                        if (savedManhwaId && savedChapterNumber) {
                            try {
                                await readChapter(savedManhwaId, parseInt(savedChapterNumber, 10));
                            } catch (e) {
                                console.warn('Impossible de restaurer le lecteur au chargement', e);
                            }
                        }
                    }
                } else {
                    // Si la page n'existe pas, montrer home
                    document.getElementById('home-page')?.classList.remove('hidden');
                }
            } else {
                // Pas de page sauvegard√©e, montrer home
                document.getElementById('home-page')?.classList.remove('hidden');
            }
            if (!result.isOk) {
                showNotification('Erreur lors de l\'initialisation', 'error');
                console.error('Erreur SDK:', result.error);
            } else {
                console.log('‚úÖ Application initialis√©e avec succ√®s');
                console.log(`üìä ${allManhwas.length} manhwas et ${allChapters.length} chapitres charg√©s`);
            }
        }

        // Gestion du th√®me
        function toggleTheme() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode');
            document.getElementById('navbar').classList.toggle('dark-mode');
            document.getElementById('sidebar').classList.toggle('dark-mode');
            settingsPanel.classList.toggle('dark-mode');
            
            // Mettre √† jour tous les √©l√©ments avec la classe card
            document.querySelectorAll('.card').forEach(card => {
                card.classList.toggle('dark-mode');
            });
            
            // Mettre √† jour tous les modals
            document.querySelectorAll('#add-manhwa-modal > div, #add-chapter-modal > div, #edit-manhwa-modal > div, #edit-chapter-modal > div, #tracking-modal > div').forEach(modal => {
                modal.classList.toggle('dark-mode');
            });
            
            // Mettre √† jour le toggle switch
            if (isDarkMode) {
                themeToggle.classList.remove('bg-gray-300');
                themeToggle.classList.add('bg-indigo-600');
                toggleCircle.classList.remove('translate-x-1');
                toggleCircle.classList.add('translate-x-6');
                themeIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>';
            } else {
                themeToggle.classList.remove('bg-indigo-600');
                themeToggle.classList.add('bg-gray-300');
                toggleCircle.classList.remove('translate-x-6');
                toggleCircle.classList.add('translate-x-1');
                themeIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>';
            }
            
            localStorage.setItem('darkMode', isDarkMode);
            
            // Rafra√Æchir la page de suivi pour appliquer les nouvelles couleurs
            if (document.getElementById('tracking-page') && !document.getElementById('tracking-page').classList.contains('hidden')) {
                updateTrackingPage();
            }
        }

        themeToggle.addEventListener('click', toggleTheme);

        // Charger le th√®me sauvegard√© au d√©marrage
        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('darkMode');
            if (savedTheme === 'true') {
                isDarkMode = false; // On met false pour que toggleTheme() le passe √† true
                toggleTheme();
            }
        }

        // Appeler loadSavedTheme() au d√©marrage
        loadSavedTheme();

        // Initialise le toggle Zoom boutons dans les param√®tres
        (function initReaderZoomToggle() {
            const toggle = document.getElementById('reader-zoom-buttons-toggle');
            if (!toggle) return;
            // Set initial state
            toggle.checked = isZoomButtonsEnabled();
            toggle.addEventListener('change', (e) => {
                setZoomButtonsEnabled(e.target.checked);
                // Update controls immediately if on reader page
                if (document.getElementById('reader-page') && !document.getElementById('reader-page').classList.contains('hidden')) {
                    createReaderZoomControls();
                }
            });
        })();

        // Gestion du menu sidebar
        menuBtn.addEventListener('click', () => {
            sidebar.classList.toggle('-translate-x-full');
            settingsPanel.classList.add('translate-x-full');
        });

        // Gestion du panneau param√®tres
        settingsBtn.addEventListener('click', () => {
            settingsPanel.classList.toggle('translate-x-full');
            sidebar.classList.add('-translate-x-full');
        });

        closeSettings.addEventListener('click', () => {
            settingsPanel.classList.add('translate-x-full');
        });

        // Bouton ajouter manhwa depuis param√®tres
        addManhwaSettings.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // V√©rifier le mode d√©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }
            
            // Populate folder select before showing
            try {
                const resp = await fetch('./api-list-folders.php');
                if (resp.ok) {
                    const json = await resp.json();
                    const sel = document.getElementById('manhwa-folder-select');
                    if (sel && json.success && Array.isArray(json.folders)) {
                        // clear + default
                        sel.innerHTML = '<option value="">-- Aucun --</option>';
                        json.folders.forEach(f => {
                            const o = document.createElement('option'); o.value = f; o.textContent = f; sel.appendChild(o);
                        });
                    }
                }
            } catch (err) {
                console.warn('Impossible de charger la liste des dossiers:', err);
            }

            addManhwaModal.classList.remove('hidden');
            settingsPanel.classList.add('translate-x-full');
        });

        // Fermer sidebar et settings en cliquant en dehors
        document.addEventListener('click', (e) => {
            if (!sidebar.contains(e.target) && !menuBtn.contains(e.target)) {
                sidebar.classList.add('-translate-x-full');
            }
            if (!settingsPanel.contains(e.target) && !settingsBtn.contains(e.target)) {
                settingsPanel.classList.add('translate-x-full');
            }
        });

        // Navigation entre les pages
        navItems.forEach(item => {
            item.addEventListener('click', () => {
                const page = item.getAttribute('data-page');
                showPage(page);
                sidebar.classList.add('-translate-x-full');
            });
        });

        function showPage(pageName) {
            console.log('üìÑ Affichage de la page:', pageName);
            document.querySelectorAll('.page-content').forEach(page => {
                page.classList.add('hidden');
            });
            
            const pageElement = document.getElementById(`${pageName}-page`);
            if (pageElement) {
                pageElement.classList.remove('hidden');
                // Sauvegarder la page actuelle imm√©diatement (SAUF home)
                if (pageName !== 'home') {
                    localStorage.setItem('currentPage', pageName);
                    console.log('üíæ Page sauvegard√©e:', pageName);
                } else {
                    // Si on va sur home, ne pas sauvegarder (ou supprimer la sauvegarde)
                    localStorage.removeItem('currentPage');
                    console.log('üè† Page home - sauvegarde supprim√©e');
                }
            } else {
                console.error('‚ùå Page non trouv√©e:', pageName);
            }
        }

        // Modal Manhwa - Gestion des images
        const coverUrl = document.getElementById('manhwa-cover-url');
        const imagePreview = document.getElementById('image-preview');
        const previewImg = document.getElementById('preview-img');

        // Pr√©visualisation de l'image depuis le chemin local
        coverUrl.addEventListener('input', (e) => {
            let path = e.target.value.trim();
            if (path) {
                // Nettoyer le chemin comme pour les chapitres MHTML
                path = path.replace(/\\/g, '/');
                if (path.includes('Site/')) {
                    path = path.split('Site/')[1];
                }
                if (path.includes('Image/') && !path.startsWith('Image/')) {
                    path = path.substring(path.indexOf('Image/'));
                }
                if (!path.startsWith('./') && !path.startsWith('/') && !path.startsWith('http')) {
                    path = './' + path;
                }
                
                previewImg.src = path;
                imagePreview.classList.remove('hidden');
                previewImg.onerror = () => {
                    imagePreview.classList.add('hidden');
                };
            } else {
                imagePreview.classList.add('hidden');
            }
        });

        closeManhwaModal.addEventListener('click', () => {
            addManhwaModal.classList.add('hidden');
            addManhwaForm.reset();
            imagePreview.classList.add('hidden');
        });

        document.getElementById('cancel-manhwa').addEventListener('click', () => {
            addManhwaModal.classList.add('hidden');
            addManhwaForm.reset();
            imagePreview.classList.add('hidden');
        });

        addManhwaForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // V√©rifier le mode d√©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }

            const submitBtn = e.target.querySelector('button[type="submit"]');
            const submitText = document.getElementById('manhwa-submit-text');
            const loading = document.getElementById('manhwa-loading');
            
            submitText.classList.add('hidden');
            loading.classList.remove('hidden');
            submitBtn.disabled = true;

            const title = document.getElementById('manhwa-title').value.trim();
            let coverImagePath = document.getElementById('manhwa-cover-url').value.trim();
            const description = document.getElementById('manhwa-description').value.trim();
            const season = document.getElementById('manhwa-season').value.trim();

            // Nettoyer le chemin pour le stockage (comme pour les chapitres MHTML)
            coverImagePath = coverImagePath.replace(/\\/g, '/');
            if (coverImagePath.includes('Site/')) {
                coverImagePath = coverImagePath.split('Site/')[1];
            }
            if (coverImagePath.includes('Image/') && !coverImagePath.startsWith('Image/')) {
                coverImagePath = coverImagePath.substring(coverImagePath.indexOf('Image/'));
            }
            if (!coverImagePath.startsWith('./') && !coverImagePath.startsWith('/') && !coverImagePath.startsWith('http')) {
                coverImagePath = './' + coverImagePath;
            }

            const manhwaId = 'manhwa_' + Date.now();

            const chosenFolder = document.getElementById('manhwa-folder-select') ? document.getElementById('manhwa-folder-select').value : '';
            if (!chosenFolder) {
                showNotification('Veuillez choisir un dossier dans `chapitres/` (obligatoire).', 'error');
                submitText.classList.remove('hidden');
                loading.classList.add('hidden');
                submitBtn.disabled = false;
                return;
            }

            const result = await window.dataSdk.create({
                manhwa_id: manhwaId,
                manhwa_title: title,
                manhwa_cover: coverImagePath,
                manhwa_description: description,
                manhwa_season: season || null,
                date_added: new Date().toISOString()
            });

            // Si l'utilisateur a choisi un dossier local, enregistrer la mapping et cr√©er les chapitres existants
            if (result.isOk && chosenFolder) {
                try {
                    // Enregistrer la mapping manhwa_id -> folder
                    await fetch('./api-manhwa-folders.php', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ manhwa_id: manhwaId, folder: chosenFolder })
                    });
                    // Demander au serveur de scanner et cr√©er les chapitres
                    const auto = await autoCreateChaptersFromFolder(manhwaId, chosenFolder);
                    if (auto && auto.success) {
                        showNotification(`${auto.created} chapitres cr√©√©s automatiquement √† partir du dossier`, 'success');
                    }
                } catch (err) {
                    console.warn('Erreur en enregistrant le dossier du manhwa', err);
                }
            }

            if (result.isOk) {
                showNotification('Manhwa ajout√© avec succ√®s!', 'success');
                addManhwaModal.classList.add('hidden');
                addManhwaForm.reset();
                imagePreview.classList.add('hidden');
            } else {
                showNotification('Erreur lors de l\'ajout du manhwa', 'error');
                console.error('Erreur:', result.error);
            }

            submitText.classList.remove('hidden');
            loading.classList.add('hidden');
            submitBtn.disabled = false;
        });

        // Pr√©visualisation de l'image de couverture lors de la cr√©ation
        const chapterCoverAdd = document.getElementById('chapter-cover-add');
        const chapterCoverAddPreview = document.getElementById('chapter-cover-add-preview');
        const chapterCoverAddPreviewImg = document.getElementById('chapter-cover-add-preview-img');
        
        if (chapterCoverAdd) {
            chapterCoverAdd.addEventListener('input', (e) => {
                let path = e.target.value.trim();
                if (path) {
                    path = path.replace(/\\/g, '/');
                    if (path.includes('Site/')) {
                        path = path.split('Site/')[1];
                    }
                    if (path.includes('Image/') && !path.startsWith('Image/')) {
                        path = path.substring(path.indexOf('Image/'));
                    }
                    if (!path.startsWith('./') && !path.startsWith('/') && !path.startsWith('http')) {
                        path = './' + path;
                    }
                    chapterCoverAddPreviewImg.src = path;
                    chapterCoverAddPreview.classList.remove('hidden');
                    chapterCoverAddPreviewImg.onerror = () => {
                        chapterCoverAddPreview.classList.add('hidden');
                    };
                } else {
                    chapterCoverAddPreview.classList.add('hidden');
                }
            });
        }

        // Modal Chapitre
        closeChapterModal.addEventListener('click', () => {
            addChapterModal.classList.add('hidden');
            addChapterForm.reset();
            document.getElementById('mhtml-preview').classList.add('hidden');
            document.getElementById('mhtml-status').classList.add('hidden');
            if (chapterCoverAddPreview) chapterCoverAddPreview.classList.add('hidden');
        });

        document.getElementById('cancel-chapter').addEventListener('click', () => {
            addChapterModal.classList.add('hidden');
            addChapterForm.reset();
            document.getElementById('mhtml-preview').classList.add('hidden');
            document.getElementById('mhtml-status').classList.add('hidden');
            if (chapterCoverAddPreview) chapterCoverAddPreview.classList.add('hidden');
        });

        // V√©rifier rapidement que le fichier MHTML existe quand l'utilisateur entre le chemin
        const mhtmlPathInput = document.getElementById('mhtml-path');
        let checkTimeout = null;
        mhtmlPathInput.addEventListener('input', async (e) => {
            const path = e.target.value.trim();
            const statusDiv = document.getElementById('mhtml-status');
            const previewDiv = document.getElementById('mhtml-preview');
            
            if (!path || !path.endsWith('.mhtml')) {
                statusDiv.classList.add('hidden');
                previewDiv.classList.add('hidden');
                return;
            }
            
            // Attendre 1 seconde apr√®s que l'utilisateur arr√™te de taper
            clearTimeout(checkTimeout);
            statusDiv.classList.remove('hidden');
            statusDiv.innerHTML = `
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                    <div class="flex items-center">
                        <div class="loading-spinner w-5 h-5 mr-3"></div>
                        <p class="text-blue-700 font-medium">V√©rification du fichier...</p>
                    </div>
                </div>
            `;
            previewDiv.classList.add('hidden');
            
            checkTimeout = setTimeout(async () => {
                try {
                    // Nettoyer le chemin
                    let cleanPath = path.replace(/\\/g, '/');
                if (cleanPath.includes('Site/')) {
                    cleanPath = cleanPath.split('Site/')[1];
                }
                if (cleanPath.includes('chapitres/') && !cleanPath.startsWith('chapitres/')) {
                    cleanPath = cleanPath.substring(cleanPath.indexOf('chapitres/'));
                }
                    if (!cleanPath.startsWith('./') && !cleanPath.startsWith('/') && !cleanPath.startsWith('http')) {
                        cleanPath = './' + cleanPath;
                    }
                    
                    const response = await fetch(cleanPath, { method: 'HEAD' });
                    if (response.ok) {
                        statusDiv.innerHTML = `
                            <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                                <p class="text-green-700 font-bold">‚úÖ Fichier MHTML trouv√© et valide!</p>
                                <p class="text-green-600 text-sm mt-1">Le fichier sera charg√© lors de l'ouverture du chapitre</p>
                            </div>
                        `;
                    } else {
                        throw new Error(`Fichier non trouv√© (Status: ${response.status})`);
                    }
                } catch (error) {
                    statusDiv.innerHTML = `
                        <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                            <p class="text-red-700 font-bold">‚ùå Fichier non trouv√©</p>
                            <p class="text-red-600 text-sm mt-1">${error.message}</p>
                        </div>
                    `;
                }
            }, 1000);
        });

            // Charger la liste des dossiers / chapitres depuis le serveur
            async function loadChapterFolders() {
                try {
                    const resp = await fetch('api-chapters-folders.php?t=' + Date.now());
                    if (!resp.ok) return;
                    const json = await resp.json();
                    if (!json.success) return;
                    const select = document.getElementById('chapter-folder-select');
                    // Clear except first
                    select.innerHTML = '<option value="">-- Choisir manhwa / chapitre --</option>';
                    json.data.forEach(m => {
                        if (!Array.isArray(m.chapters) || m.chapters.length === 0) return;
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = m.name;
                        m.chapters.forEach(ch => {
                            const opt = document.createElement('option');
                            opt.value = `chapitres/${m.name}/${ch}`;
                            opt.text = `${m.name} / ${ch}`;
                            optgroup.appendChild(opt);
                        });
                        select.appendChild(optgroup);
                    });
                } catch (e) {
                    console.warn('Impossible de charger la liste des dossiers de chapitres', e);
                }
            }




        addChapterForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // V√©rifier le mode d√©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }
            
            if (!currentManhwaId) {
                showNotification('Erreur: Aucun manhwa s√©lectionn√©', 'error');
                return;
            }

            const submitBtn = e.target.querySelector('button[type="submit"]');
            const submitText = document.getElementById('chapter-submit-text');
            const loading = document.getElementById('chapter-loading');
            
            submitText.classList.add('hidden');
            loading.classList.remove('hidden');
            submitBtn.disabled = true;

            const chapterNumber = parseInt(document.getElementById('chapter-number').value);
            const chapterTitle = document.getElementById('chapter-title').value.trim();
            const chapterDescription = document.getElementById('chapter-description').value.trim();
            const chapterSeason = document.getElementById('chapter-season-add').value.trim();
            let chapterCover = document.getElementById('chapter-cover-add').value.trim();

            // Nettoyer le chemin de l'image de couverture (vide = utiliser celle du manhwa)
            if (chapterCover) {
                chapterCover = chapterCover.replace(/\\/g, '/');
                if (chapterCover.includes('Site/')) {
                    chapterCover = chapterCover.split('Site/')[1];
                }
                if (chapterCover.includes('Image/') && !chapterCover.startsWith('Image/')) {
                    chapterCover = chapterCover.substring(chapterCover.indexOf('Image/'));
                }
                if (!chapterCover.startsWith('./') && !chapterCover.startsWith('/') && !chapterCover.startsWith('http')) {
                    chapterCover = './' + chapterCover;
                }
            } else {
                chapterCover = null; // null = utiliser l'image du manhwa par d√©faut
            }

            // V√©rifier si le chapitre existe d√©j√†
            const existingChapter = allChapters.find(ch => 
                ch.manhwa_id === currentManhwaId && ch.chapter_number === chapterNumber
            );

            if (existingChapter) {
                showNotification(`Le chapitre ${chapterNumber} existe d√©j√†`, 'error');
                submitText.classList.remove('hidden');
                loading.classList.add('hidden');
                submitBtn.disabled = false;
                return;
            }

            // R√©cup√©rer le chemin MHTML entr√© par l'utilisateur
            // Priorit√©: dossier s√©lectionn√© via select
            const folderSelect = document.getElementById('chapter-folder-select');
            let chapterPages = '';
            if (folderSelect && folderSelect.value) {
                // Normaliser
                chapterPages = folderSelect.value.replace(/\\/g, '/');
                if (!chapterPages.startsWith('./') && !chapterPages.startsWith('/')) chapterPages = './' + chapterPages;
            } else {
                // Fallback: champ MHTML (optionnel)
                let mhtmlPath = document.getElementById('mhtml-path').value.trim();
                if (mhtmlPath) {
                    mhtmlPath = mhtmlPath.replace(/\\/g, '/');
                    if (mhtmlPath.includes('Site/')) mhtmlPath = mhtmlPath.split('Site/')[1];
                    if (mhtmlPath.includes('chapitres/') && !mhtmlPath.startsWith('chapitres/')) {
                        mhtmlPath = mhtmlPath.substring(mhtmlPath.indexOf('chapitres/'));
                    }
                    if (!mhtmlPath.startsWith('./') && !mhtmlPath.startsWith('/') && !mhtmlPath.startsWith('http')) mhtmlPath = './' + mhtmlPath;
                    chapterPages = mhtmlPath;
                }
            }

            if (!chapterPages) {
                showNotification('Veuillez s√©lectionner un dossier de chapitre ou coller un fichier MHTML', 'error');
                submitText.classList.remove('hidden');
                loading.classList.add('hidden');
                submitBtn.disabled = false;
                return;
            }

            // Stocker le chemin (dossier ou fichier) dans la base
            const result = await window.dataSdk.create({
                manhwa_id: currentManhwaId,
                chapter_number: chapterNumber,
                chapter_title: chapterTitle,
                chapter_description: chapterDescription,
                chapter_season: chapterSeason || null,
                chapter_pages: chapterPages,
                chapter_cover: chapterCover,
                date_added: new Date().toISOString()
            });

            if (result.isOk) {
                showNotification('Chapitre ajout√© avec succ√®s! üéâ', 'success');
                addChapterModal.classList.add('hidden');
                addChapterForm.reset();
                document.getElementById('mhtml-preview').classList.add('hidden');
                document.getElementById('mhtml-status').classList.add('hidden');
                
                // La mise √† jour a d√©j√† √©t√© faite par onDataChanged, mais on force le refresh de la page d√©tail
                setTimeout(() => {
                    if (currentManhwaId) {
                        showManhwaDetail(currentManhwaId);
                    }
                }, 300);
            } else {
                showNotification('Erreur lors de l\'ajout du chapitre', 'error');
            }

            submitText.classList.remove('hidden');
            loading.classList.add('hidden');
            submitBtn.disabled = false;
        });

        // Modal Modifier Manhwa
        const editManhwaModal = document.getElementById('edit-manhwa-modal');
        const closeEditManhwaModal = document.getElementById('close-edit-manhwa-modal');
        const editManhwaForm = document.getElementById('edit-manhwa-form');
        const editCoverUrl = document.getElementById('edit-manhwa-cover-url');
        const editImagePreview = document.getElementById('edit-image-preview');
        const editPreviewImg = document.getElementById('edit-preview-img');
        let currentEditManhwaId = null;

        // Pr√©visualisation pour le modal d'√©dition
        editCoverUrl.addEventListener('input', (e) => {
            let path = e.target.value.trim();
            if (path) {
                path = path.replace(/\\/g, '/');
                if (path.includes('Site/')) {
                    path = path.split('Site/')[1];
                }
                if (path.includes('Image/') && !path.startsWith('Image/')) {
                    path = path.substring(path.indexOf('Image/'));
                }
                if (!path.startsWith('./') && !path.startsWith('/') && !path.startsWith('http')) {
                    path = './' + path;
                }
                editPreviewImg.src = path;
                editImagePreview.classList.remove('hidden');
                editPreviewImg.onerror = () => {
                    editImagePreview.classList.add('hidden');
                };
            } else {
                editImagePreview.classList.add('hidden');
            }
        });

        closeEditManhwaModal.addEventListener('click', () => {
            editManhwaModal.classList.add('hidden');
            editManhwaForm.reset();
            editImagePreview.classList.add('hidden');
            currentEditManhwaId = null;
        });

        document.getElementById('cancel-edit-manhwa').addEventListener('click', () => {
            editManhwaModal.classList.add('hidden');
            editManhwaForm.reset();
            editImagePreview.classList.add('hidden');
            currentEditManhwaId = null;
        });

        editManhwaForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const submitBtn = e.target.querySelector('button[type="submit"]');
            const submitText = document.getElementById('edit-manhwa-submit-text');
            const loading = document.getElementById('edit-manhwa-loading');
            
            submitText.classList.add('hidden');
            loading.classList.remove('hidden');
            submitBtn.disabled = true;

            const manhwa = allManhwas.find(m => m.__backendId === currentEditManhwaId);
            if (!manhwa) {
                showNotification('Erreur: Manhwa introuvable', 'error');
                submitText.classList.remove('hidden');
                loading.classList.add('hidden');
                submitBtn.disabled = false;
                return;
            }

            const title = document.getElementById('edit-manhwa-title').value.trim();
            let coverImagePath = document.getElementById('edit-manhwa-cover-url').value.trim();
            const description = document.getElementById('edit-manhwa-description').value.trim();
            const season = document.getElementById('edit-manhwa-season').value.trim();

            // Nettoyer le chemin
            coverImagePath = coverImagePath.replace(/\\/g, '/');
            if (coverImagePath.includes('Site/')) {
                coverImagePath = coverImagePath.split('Site/')[1];
            }
            if (coverImagePath.includes('Image/') && !coverImagePath.startsWith('Image/')) {
                coverImagePath = coverImagePath.substring(coverImagePath.indexOf('Image/'));
            }
            if (!coverImagePath.startsWith('./') && !coverImagePath.startsWith('/') && !coverImagePath.startsWith('http')) {
                coverImagePath = './' + coverImagePath;
            }

            // Mettre √† jour le manhwa
            const updatedManhwa = {
                ...manhwa,
                manhwa_title: title,
                manhwa_cover: coverImagePath,
                manhwa_description: description,
                manhwa_season: season || null
            };

            const result = await window.dataSdk.update(updatedManhwa);

            if (result.isOk) {
                showNotification('Manhwa modifi√© avec succ√®s!', 'success');
                editManhwaModal.classList.add('hidden');
                editManhwaForm.reset();
                editImagePreview.classList.add('hidden');
                currentEditManhwaId = null;
            } else {
                showNotification('Erreur lors de la modification', 'error');
            }

            submitText.classList.remove('hidden');
            loading.classList.add('hidden');
            submitBtn.disabled = false;
        });

        // Fonction pour ouvrir le modal de modification de manhwa
        function openEditManhwaModal(manhwaId) {
            const manhwa = allManhwas.find(m => m.__backendId === manhwaId);
            if (!manhwa) return;

            currentEditManhwaId = manhwaId;
            document.getElementById('edit-manhwa-title').value = manhwa.manhwa_title;
            document.getElementById('edit-manhwa-cover-url').value = manhwa.manhwa_cover.replace('./', '');
            document.getElementById('edit-manhwa-description').value = manhwa.manhwa_description;
            document.getElementById('edit-manhwa-season').value = manhwa.manhwa_season || '';
            
            // Afficher la pr√©visualisation
            let previewPath = manhwa.manhwa_cover;
            if (!previewPath.startsWith('./') && !previewPath.startsWith('/') && !previewPath.startsWith('http')) {
                previewPath = './' + previewPath;
            }
            editPreviewImg.src = previewPath;
            editImagePreview.classList.remove('hidden');
            
            editManhwaModal.classList.remove('hidden');
        }

        // Modal Modifier Chapitre
        const editChapterModal = document.getElementById('edit-chapter-modal');
        const closeEditChapterModal = document.getElementById('close-edit-chapter-modal');
        const editChapterForm = document.getElementById('edit-chapter-form');
        const editChapterCover = document.getElementById('edit-chapter-cover');
        const editChapterCoverPreview = document.getElementById('edit-chapter-cover-preview');
        const editChapterPreviewImg = document.getElementById('edit-chapter-preview-img');
        let currentEditChapterId = null;

        // Pr√©visualisation pour l'image de couverture du chapitre
        editChapterCover.addEventListener('input', (e) => {
            let path = e.target.value.trim();
            if (path) {
                path = path.replace(/\\/g, '/');
                if (path.includes('Site/')) {
                    path = path.split('Site/')[1];
                }
                if (path.includes('Image/') && !path.startsWith('Image/')) {
                    path = path.substring(path.indexOf('Image/'));
                }
                if (!path.startsWith('./') && !path.startsWith('/') && !path.startsWith('http')) {
                    path = './' + path;
                }
                editChapterPreviewImg.src = path;
                editChapterCoverPreview.classList.remove('hidden');
                editChapterPreviewImg.onerror = () => {
                    editChapterCoverPreview.classList.add('hidden');
                };
            } else {
                editChapterCoverPreview.classList.add('hidden');
            }
        });

        closeEditChapterModal.addEventListener('click', () => {
            editChapterModal.classList.add('hidden');
            editChapterForm.reset();
            editChapterCoverPreview.classList.add('hidden');
            currentEditChapterId = null;
        });

        document.getElementById('cancel-edit-chapter').addEventListener('click', () => {
            editChapterModal.classList.add('hidden');
            editChapterForm.reset();
            editChapterCoverPreview.classList.add('hidden');
            currentEditChapterId = null;
        });

        editChapterForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const submitBtn = e.target.querySelector('button[type="submit"]');
            const submitText = document.getElementById('edit-chapter-submit-text');
            const loading = document.getElementById('edit-chapter-loading');
            
            submitText.classList.add('hidden');
            loading.classList.remove('hidden');
            submitBtn.disabled = true;

            const chapter = allChapters.find(ch => ch.__backendId === currentEditChapterId);
            if (!chapter) {
                showNotification('Erreur: Chapitre introuvable', 'error');
                submitText.classList.remove('hidden');
                loading.classList.add('hidden');
                submitBtn.disabled = false;
                return;
            }

            const chapterNumber = parseInt(document.getElementById('edit-chapter-number').value);
            const chapterTitle = document.getElementById('edit-chapter-title').value.trim();
            const chapterDescription = document.getElementById('edit-chapter-description').value.trim();
            const chapterSeason = document.getElementById('edit-chapter-season').value.trim();
            let chapterCover = document.getElementById('edit-chapter-cover').value.trim();

            // Nettoyer le chemin de l'image de couverture (vide = utiliser celle du manhwa)
            if (chapterCover) {
                chapterCover = chapterCover.replace(/\\/g, '/');
                if (chapterCover.includes('Site/')) {
                    chapterCover = chapterCover.split('Site/')[1];
                }
                if (chapterCover.includes('Image/') && !chapterCover.startsWith('Image/')) {
                    chapterCover = chapterCover.substring(chapterCover.indexOf('Image/'));
                }
                if (!chapterCover.startsWith('./') && !chapterCover.startsWith('/') && !chapterCover.startsWith('http')) {
                    chapterCover = './' + chapterCover;
                }
            } else {
                chapterCover = null; // null = utiliser l'image du manhwa par d√©faut
            }

            // Nettoyer le chemin MHTML si on est en mode d√©veloppeur
            let mhtmlPath = chapter.chapter_pages; // Garder l'ancien par d√©faut
            if (isDeveloperMode()) {
                const mhtmlInput = document.getElementById('edit-chapter-mhtml').value.trim();
                if (mhtmlInput) {
                    mhtmlPath = mhtmlInput.replace(/\\/g, '/');
                    if (mhtmlPath.includes('Site/')) {
                        mhtmlPath = mhtmlPath.split('Site/')[1];
                    }
                    if (mhtmlPath.includes('chapitres/') && !mhtmlPath.startsWith('chapitres/')) {
                        mhtmlPath = mhtmlPath.substring(mhtmlPath.indexOf('chapitres/'));
                    }
                    if (!mhtmlPath.startsWith('./') && !mhtmlPath.startsWith('/') && !mhtmlPath.startsWith('http')) {
                        mhtmlPath = './' + mhtmlPath;
                    }
                }
            }

            // Mettre √† jour le chapitre
            const updatedChapter = {
                ...chapter,
                chapter_number: chapterNumber,
                chapter_title: chapterTitle,
                chapter_description: chapterDescription,
                chapter_season: chapterSeason || null,
                chapter_cover: chapterCover, // null ou chemin personnalis√©
                chapter_pages: mhtmlPath // Chemin MHTML (modifiable seulement en mode d√©veloppeur)
            };

            const result = await window.dataSdk.update(updatedChapter);

            if (result.isOk) {
                showNotification('Chapitre modifi√© avec succ√®s!', 'success');
                editChapterModal.classList.add('hidden');
                editChapterForm.reset();
                editChapterCoverPreview.classList.add('hidden');
                currentEditChapterId = null;
            } else {
                showNotification('Erreur lors de la modification', 'error');
            }

            submitText.classList.remove('hidden');
            loading.classList.add('hidden');
            submitBtn.disabled = false;
        });

        // Fonction pour ouvrir le modal de modification de chapitre
        function openEditChapterModal(chapterId) {
            const chapter = allChapters.find(ch => ch.__backendId === chapterId);
            if (!chapter) return;

            currentEditChapterId = chapterId;
            document.getElementById('edit-chapter-number').value = chapter.chapter_number;
            document.getElementById('edit-chapter-title').value = chapter.chapter_title;
            document.getElementById('edit-chapter-description').value = chapter.chapter_description || '';
            document.getElementById('edit-chapter-season').value = chapter.chapter_season || '';
            document.getElementById('edit-chapter-cover').value = chapter.chapter_cover ? chapter.chapter_cover.replace('./', '') : '';
            
            // Afficher le champ MHTML seulement en mode d√©veloppeur
            const mhtmlContainer = document.getElementById('edit-chapter-mhtml-container');
            if (isDeveloperMode()) {
                mhtmlContainer.classList.remove('hidden');
                document.getElementById('edit-chapter-mhtml').value = chapter.chapter_pages ? chapter.chapter_pages.replace('./', '') : '';
            } else {
                mhtmlContainer.classList.add('hidden');
            }
            
            // Afficher la pr√©visualisation si une image personnalis√©e existe
            if (chapter.chapter_cover) {
                let previewPath = chapter.chapter_cover;
                if (!previewPath.startsWith('./') && !previewPath.startsWith('/') && !previewPath.startsWith('http')) {
                    previewPath = './' + previewPath;
                }
                editChapterPreviewImg.src = previewPath;
                editChapterCoverPreview.classList.remove('hidden');
            } else {
                editChapterCoverPreview.classList.add('hidden');
            }
            
            editChapterModal.classList.remove('hidden');
        }

        // ========== SYST√àME DE SUIVI ==========
        let trackingList = [];
        
        // Charger les suivis depuis data.php (via globalData)
        function loadTrackingList() {
            try {
                trackingList = globalData.filter(item => item.type === 'tracking');
            } catch (error) {
                console.error('Erreur lors du chargement des suivis:', error);
                trackingList = [];
            }
        }
        
      // Sauvegarder les suivis via PHP
async function saveTrackingList() {
    // Sauvegarde chaque suivi et v√©rifie la r√©ponse; retourne true si toutes r√©ussissent
    for (const t of trackingList) {
        try {
            const resp = await fetch(`save-tracking.php?action=save&id=${encodeURIComponent(t.id)}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(t)
            });

            // D√©fensive parsing: certains environnements peuvent renvoyer body vide.
            const text = await resp.text();
            let json = null;
            if (text && text.trim().length > 0) {
                try {
                    json = JSON.parse(text);
                } catch (e) {
                    console.error('saveTrackingList: r√©ponse JSON invalide', text, e);
                    return false;
                }
            } else {
                // pas de corps : consid√©rer comme succ√®s si status 200/201
                json = { success: resp.ok };
            }

            if (!json || !json.success) {
                console.error('saveTrackingList: √©chec sauvegarde', json);
                return false;
            }

        } catch (e) {
            console.error('saveTrackingList: erreur r√©seau', e);
            return false;
        }
    }
    return true;
}

        
       async function addTracking(title, chapter, status, notes, season) {
    const id = 'tracking_' + Date.now() + '_' + Math.random(); // <-- g√©n√©rer un id unique
        try {
            const response = await fetch('save-tracking.php?action=save', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({id, title, chapter, status, notes, season})
            });
            const result = await response.json();
            if (result.success) {
                const tracking = {
                    type: 'tracking',
                    id,
                    title,
                    chapter: parseInt(chapter) || 0,
                    status: status || 'en-cours',
                    notes: notes || '',
                    season: season || null,
                    date_added: new Date().toISOString(),
                    date_updated: new Date().toISOString()
                };
                trackingList.push(tracking);
                updateTrackingPage();
                return tracking;
            }
            showNotification(`Erreur : ${result.message || 'sauvegarde invalide'}`, 'error');
            return null;
        } catch (e) {
            console.error('addTracking error', e);
            showNotification('Erreur r√©seau lors de la cr√©ation du suivi', 'error');
            return null;
        }
}

        
        // Modifier un suivi
        async function updateTracking(id, title, chapter, status, notes, season) {
            const index = trackingList.findIndex(t => t.id === id);
            if (index !== -1) {
                trackingList[index] = {
                    ...trackingList[index],
                    title: title,
                    chapter: parseInt(chapter) || 0,
                    status: status || 'en-cours',
                    notes: notes || '',
                    season: season || null,
                    date_updated: new Date().toISOString()
                };
                await saveTrackingList();
                return true;
            }
            return false;
        }
        
     // Fonction qui supprime un suivi via PHP/MySQL
async function deleteTracking(id) {
    try {
        const response = await fetch(`save-tracking.php?action=delete&id=${encodeURIComponent(id)}`);
        const result = await response.json();

        if (result.success) {
            // Retirer localement pour mise √† jour visuelle
            trackingList = trackingList.filter(t => t.id !== id);
            updateTrackingPage(); // rafra√Æchir la page suivi
            showNotification('Suivi d√©plac√© dans la corbeille', 'success');
        } else {
            showNotification(`Erreur : ${result.message}`, 'error');
        }
    } catch (error) {
        console.error('Erreur lors de la suppression du suivi :', error);
        showNotification('Erreur r√©seau ou serveur', 'error');
    }
}

// Fonction appel√©e par le bouton
window.deleteTrackingItem = async function(id) {
    const tracking = trackingList.find(t => t.id === id);
    if (!tracking) return;
        
    await deleteTracking(id);
    updateTrackingPage();
    showNotification('Suivi d√©plac√© dans la corbeille', 'success');
};



        
        // Augmenter le chapitre
        async function incrementChapter(id) {
            const tracking = trackingList.find(t => t.id === id);
            if (tracking) {
                const old = tracking.chapter;
                tracking.chapter = (tracking.chapter || 0) + 1;
                tracking.date_updated = new Date().toISOString();
                const ok = await saveTrackingList();
                if (!ok) {
                    // revert
                    tracking.chapter = old;
                    tracking.date_updated = new Date().toISOString();
                    showNotification('Erreur lors de la sauvegarde du suivi', 'error');
                    return false;
                }
                return true;
            }
            return false;
        }
        
        // Diminuer le chapitre
        async function decrementChapter(id) {
            const tracking = trackingList.find(t => t.id === id);
            if (tracking && tracking.chapter > 0) {
                const old = tracking.chapter;
                tracking.chapter = tracking.chapter - 1;
                tracking.date_updated = new Date().toISOString();
                const ok = await saveTrackingList();
                if (!ok) {
                    tracking.chapter = old;
                    tracking.date_updated = new Date().toISOString();
                    showNotification('Erreur lors de la sauvegarde du suivi', 'error');
                    return false;
                }
                return true;
            }
            return false;
        }
        
        // Mettre √† jour la page de suivi
        // Fonction de recherche et filtrage pour les suivis
        function filterAndSearchTracking() {
            const searchTerm = (document.getElementById('tracking-search')?.value || '').toLowerCase();
            const filterValue = document.getElementById('tracking-filter')?.value || 'all';
            
            let filtered = [...trackingList];
            
            // Recherche
            if (searchTerm) {
                filtered = filtered.filter(tracking => 
                    tracking.title.toLowerCase().includes(searchTerm) ||
                    tracking.notes?.toLowerCase().includes(searchTerm) ||
                    tracking.season?.toLowerCase().includes(searchTerm)
                );
            }
            
            // Filtrage
            switch(filterValue) {
                case 'en-cours':
                case 'fini':
                case 'en-pause':
                    filtered = filtered.filter(t => t.status === filterValue);
                    break;
                case 'az':
                    filtered.sort((a, b) => a.title.localeCompare(b.title));
                    break;
                case 'za':
                    filtered.sort((a, b) => b.title.localeCompare(a.title));
                    break;
            }
            
            return filtered;
        }
        
        function updateTrackingPage() {
            const trackingListContainer = document.getElementById('tracking-list');
            if (!trackingListContainer) return;
            
            trackingListContainer.innerHTML = '';
            
            const filteredTracking = filterAndSearchTracking();
            
            if (filteredTracking.length === 0) {
                trackingListContainer.innerHTML = `
                    <div class="text-center py-12 bg-gray-50 dark-mode:bg-gray-800 rounded-lg">
                        <svg class="w-24 h-24 mx-auto text-gray-300 dark-mode:text-gray-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                        </svg>
                        <h3 class="text-xl font-semibold text-gray-600 dark-mode:text-gray-300 mb-2">${trackingList.length === 0 ? 'Aucun suivi' : 'Aucun r√©sultat trouv√©'}</h3>
                        <p class="text-gray-500 dark-mode:text-gray-400 mb-4">${trackingList.length === 0 ? 'Commencez par ajouter un suivi de lecture!' : 'Essayez une autre recherche'}</p>
                    </div>
                `;
                return;
            }
            
            filteredTracking.forEach((tracking, index) => {
                // Couleurs adapt√©es au mode sombre
                const statusColors = isDarkMode ? {
                    'en-cours': 'bg-blue-600 text-blue-100',
                    'fini': 'bg-green-600 text-green-100',
                    'en-pause': 'bg-yellow-600 text-yellow-100'
                } : {
                    'en-cours': 'bg-blue-100 text-blue-700',
                    'fini': 'bg-green-100 text-green-700',
                    'en-pause': 'bg-yellow-100 text-yellow-700'
                };
                const statusLabels = {
                    'en-cours': 'En cours',
                    'fini': 'Fini',
                    'en-pause': 'En pause'
                };
                
                const item = document.createElement('div');
                item.className = 'bg-white rounded-lg shadow-md p-4 hover:shadow-lg transition-shadow card draggable-item cursor-move';
                item.draggable = true;
                item.dataset.trackingId = tracking.id;
                item.dataset.index = index;
                
                // Drag & Drop (cliquer-d√©placer)
                let isDragging = false;
                
                item.addEventListener('dragstart', (e) => {
                    // Ne pas activer si on clique sur un bouton
                    if (e.target.closest('button')) {
                        e.preventDefault();
                        return;
                    }
                    isDragging = true;
                    e.dataTransfer.setData('text/plain', tracking.id);
                    e.dataTransfer.effectAllowed = 'move';
                    item.classList.add('opacity-50');
                });
                
                item.addEventListener('dragend', () => {
                    item.classList.remove('opacity-50');
                    isDragging = false;
                });
                
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    item.classList.add('border-2', 'border-indigo-500');
                });
                
                item.addEventListener('dragleave', () => {
                    item.classList.remove('border-2', 'border-indigo-500');
                });
                
                item.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    item.classList.remove('border-2', 'border-indigo-500');
                    
                    const draggedId = e.dataTransfer.getData('text/plain');
                    if (draggedId === tracking.id) return;
                    
                    await reorderTracking(draggedId, tracking.id);
                });
                
                item.innerHTML = `
                    <div class="flex items-start justify-between">
                        <div class="flex-grow">
                            <h3 class="text-lg font-bold mb-2 text-gray-900 dark-mode:text-gray-100">${tracking.title}</h3>
                            <div class="flex items-center space-x-2 mb-2">
                                <span class="badge ${statusColors[tracking.status] || statusColors['en-cours']}">${statusLabels[tracking.status] || 'En cours'}</span>
                                ${tracking.season ? `<span class="badge bg-purple-100 text-purple-700 dark-mode:bg-purple-600 dark-mode:text-purple-100">S. ${tracking.season}</span>` : ''}
                            </div>
                            ${tracking.notes ? `<p class="text-sm text-gray-600 dark-mode:text-gray-300 mt-1">${tracking.notes}</p>` : ''}
                        </div>
                        <div class="flex items-center space-x-2">
                            <button onclick="decrementChapterTracking('${tracking.id}')" class="w-8 h-8 flex items-center justify-center bg-gray-100 hover:bg-gray-200 dark-mode:bg-gray-700 dark-mode:hover:bg-gray-600 rounded transition-colors text-gray-700 dark-mode:text-gray-200" title="Diminuer">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"></path>
                                </svg>
                            </button>
                            <span class="text-sm font-bold text-indigo-600 dark-mode:text-indigo-400 px-2 min-w-[3rem] text-center">Ch. ${tracking.chapter}</span>
                            <button onclick="incrementChapterTracking('${tracking.id}')" class="w-8 h-8 flex items-center justify-center bg-indigo-600 hover:bg-indigo-700 text-white rounded transition-colors" title="Augmenter">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                                </svg>
                            </button>
                            <button onclick="openEditTrackingModal('${tracking.id}')" class="p-2 text-blue-500 hover:bg-blue-50 dark-mode:hover:bg-blue-900 rounded-lg transition-colors" title="Modifier">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                                </svg>
                            </button>
                            <button onclick="deleteTrackingItem('${tracking.id}')" class="p-2 text-red-500 hover:bg-red-50 dark-mode:hover:bg-red-900 rounded-lg transition-colors" title="Supprimer">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                `;
                trackingListContainer.appendChild(item);
            });
        }
        
        // Fonctions globales pour les boutons
        window.incrementChapterTracking = async function(id) {
            if (await incrementChapter(id)) {
                updateTrackingPage();
                showNotification('Chapitre augment√©!', 'success');
            }
        };
        
        window.decrementChapterTracking = async function(id) {
            if (await decrementChapter(id)) {
                updateTrackingPage();
                showNotification('Chapitre diminu√©!', 'success');
            }
        };
        
        window.deleteTrackingItem = async function(id) {
            const tracking = trackingList.find(t => t.id === id);
            if (!tracking) return;
            
            const confirmed = await showConfirmDialog(
                'Supprimer ce suivi?',
                'Le suivi sera d√©plac√© dans la corbeille.'
            );
            if (confirmed) {
                // Ajouter √† la corbeille
                await addToTrash(tracking, 'tracking');
                
                await deleteTracking(id);
                updateTrackingPage();
                showNotification('Suivi d√©plac√© dans la corbeille', 'success');
            }
        };
        
        window.openEditTrackingModal = function(id) {
            const tracking = trackingList.find(t => t.id === id);
            if (!tracking) return;
            
            document.getElementById('tracking-modal-title').textContent = 'Modifier le Suivi';
            document.getElementById('tracking-title').value = tracking.title;
            document.getElementById('tracking-chapter').value = tracking.chapter;
            document.getElementById('tracking-status').value = tracking.status;
            document.getElementById('tracking-notes').value = tracking.notes || '';
            document.getElementById('tracking-season').value = tracking.season || '';
            document.getElementById('tracking-form').dataset.trackingId = id;
            
            trackingModal.classList.remove('hidden');
        };
        
        
        // Gestionnaires pour le modal de suivi
        const trackingModal = document.getElementById('tracking-modal');
        const closeTrackingModal = document.getElementById('close-tracking-modal');
        const trackingForm = document.getElementById('tracking-form');
        const addTrackingBtn = document.getElementById('add-tracking-btn');
        
        addTrackingBtn.addEventListener('click', () => {
            document.getElementById('tracking-modal-title').textContent = 'Ajouter un Suivi';
            trackingForm.reset();
            trackingForm.dataset.trackingId = '';
            trackingModal.classList.remove('hidden');
        });
        
        closeTrackingModal.addEventListener('click', () => {
            trackingModal.classList.add('hidden');
            trackingForm.reset();
        });
        
        document.getElementById('cancel-tracking').addEventListener('click', () => {
            trackingModal.classList.add('hidden');
            trackingForm.reset();
        });
        
        trackingForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const title = document.getElementById('tracking-title').value.trim();
            const chapter = document.getElementById('tracking-chapter').value;
            const status = document.getElementById('tracking-status').value;
            const notes = document.getElementById('tracking-notes').value.trim();
            const season = document.getElementById('tracking-season').value.trim();
            const trackingId = trackingForm.dataset.trackingId;
            
            if (trackingId) {
                // Modifier
                if (await updateTracking(trackingId, title, chapter, status, notes, season)) {
                    showNotification('Suivi modifi√© avec succ√®s!', 'success');
                    trackingModal.classList.add('hidden');
                    trackingForm.reset();
                    updateTrackingPage();
                }
            } else {
                // Ajouter
                await addTracking(title, chapter, status, notes, season);
                showNotification('Suivi ajout√© avec succ√®s!', 'success');
                trackingModal.classList.add('hidden');
                trackingForm.reset();
                updateTrackingPage();
            }
        });
        
        // Charger les suivis au d√©marrage
        loadTrackingList();
        
        // Event listeners pour la recherche et le filtrage
        const librarySearch = document.getElementById('library-search');
        const libraryFilter = document.getElementById('library-filter');
        const recentSearch = document.getElementById('recent-search');
        const recentFilter = document.getElementById('recent-filter');
        const favoritesSearch = document.getElementById('favorites-search');
        const favoritesFilter = document.getElementById('favorites-filter');
        const trackingSearch = document.getElementById('tracking-search');
        const trackingFilter = document.getElementById('tracking-filter');
        
        if (librarySearch) {
            librarySearch.addEventListener('input', () => updateLibraryPage());
            librarySearch.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') updateLibraryPage();
            });
        }
        if (libraryFilter) {
            libraryFilter.addEventListener('change', () => updateLibraryPage());
        }
        
        if (recentSearch) {
            recentSearch.addEventListener('input', () => updateRecentPage());
            recentSearch.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') updateRecentPage();
            });
        }
        if (recentFilter) {
            recentFilter.addEventListener('change', () => updateRecentPage());
        }
        
        if (favoritesSearch) {
            favoritesSearch.addEventListener('input', () => updateFavoritesPage());
            favoritesSearch.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') updateFavoritesPage();
            });
        }
        if (favoritesFilter) {
            favoritesFilter.addEventListener('change', () => updateFavoritesPage());
        }
        
        if (trackingSearch) {
            trackingSearch.addEventListener('input', () => updateTrackingPage());
            trackingSearch.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') updateTrackingPage();
            });
        }
        if (trackingFilter) {
            trackingFilter.addEventListener('change', () => updateTrackingPage());
        }
        
        const trashSearch = document.getElementById('trash-search');
        const trashFilter = document.getElementById('trash-filter');
        
        if (trashSearch) {
            trashSearch.addEventListener('input', () => updateTrashPage());
            trashSearch.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') updateTrashPage();
            });
        }
        if (trashFilter) {
            trashFilter.addEventListener('change', () => updateTrashPage());
        }
        
        // Fonction de recherche et filtrage pour les favoris
        function filterAndSearchFavorites() {
            const searchTerm = (document.getElementById('favorites-search')?.value || '').toLowerCase();
            const filterValue = document.getElementById('favorites-filter')?.value || 'recent';
            
            let filtered = allChapters.filter(ch => ch.is_favorite === true);
            
            // Recherche (inclut les descriptions)
            if (searchTerm) {
                filtered = filtered.filter(chapter => {
                    const manhwa = allManhwas.find(m => m.manhwa_id === chapter.manhwa_id);
                    return manhwa && (
                        manhwa.manhwa_title.toLowerCase().includes(searchTerm) ||
                        manhwa.manhwa_description?.toLowerCase().includes(searchTerm) ||
                        chapter.chapter_title?.toLowerCase().includes(searchTerm) ||
                        chapter.chapter_description?.toLowerCase().includes(searchTerm) ||
                        chapter.chapter_number.toString().includes(searchTerm)
                    );
                });
            }
            
            // Filtrage
            switch(filterValue) {
                case 'recent':
                    filtered.sort((a, b) => new Date(b.date_added) - new Date(a.date_added));
                    break;
                case 'oldest':
                    filtered.sort((a, b) => new Date(a.date_added) - new Date(b.date_added));
                    break;
                case 'az':
                    filtered.sort((a, b) => {
                        const manhwaA = allManhwas.find(m => m.manhwa_id === a.manhwa_id);
                        const manhwaB = allManhwas.find(m => m.manhwa_id === b.manhwa_id);
                        return (manhwaA?.manhwa_title || '').localeCompare(manhwaB?.manhwa_title || '');
                    });
                    break;
                case 'za':
                    filtered.sort((a, b) => {
                        const manhwaA = allManhwas.find(m => m.manhwa_id === a.manhwa_id);
                        const manhwaB = allManhwas.find(m => m.manhwa_id === b.manhwa_id);
                        return (manhwaB?.manhwa_title || '').localeCompare(manhwaA?.manhwa_title || '');
                    });
                    break;
            }
            
            return filtered;
        }
        
        // Page favoris
        function updateFavoritesPage() {
            const favoritesList = document.getElementById('favorites-list');
            if (!favoritesList) return;
            
            favoritesList.innerHTML = '';
            
            const favoriteChapters = filterAndSearchFavorites();
            
            if (favoriteChapters.length === 0) {
                favoritesList.innerHTML = `
                    <div class="text-center py-12">
                        <svg class="w-24 h-24 mx-auto text-gray-300 dark-mode:text-gray-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
                        </svg>
                        <h3 class="text-xl font-semibold text-gray-600 dark-mode:text-gray-300 mb-2">${allChapters.filter(ch => ch.is_favorite === true).length === 0 ? 'Aucun favori' : 'Aucun r√©sultat trouv√©'}</h3>
                        <p class="text-gray-500 dark-mode:text-gray-400 mb-4">${allChapters.filter(ch => ch.is_favorite === true).length === 0 ? 'Ajoutez des chapitres en favoris pour les retrouver facilement!' : 'Essayez une autre recherche'}</p>
                    </div>
                `;
                return;
            }
            
            favoriteChapters.forEach(chapter => {
                const manhwa = allManhwas.find(m => m.manhwa_id === chapter.manhwa_id);
                if (!manhwa) return;
                
                const chapterCover = chapter.chapter_cover || manhwa.manhwa_cover;
                
                const item = document.createElement('div');
                item.className = 'bg-white rounded-lg shadow-md p-4 flex items-center cursor-pointer hover:bg-gray-50 card chapter-item';
                item.onclick = () => readChapter(chapter.manhwa_id, chapter.chapter_number);
                item.innerHTML = `
                    <img src="${chapterCover}" alt="${manhwa.manhwa_title}" class="w-16 h-20 object-cover rounded mr-4">
                    <div class="flex-grow">
                        <h4 class="font-semibold text-gray-900 dark-mode:text-gray-100">${manhwa.manhwa_title}</h4>
                        <p class="text-sm text-gray-600 dark-mode:text-gray-300">Chapitre ${chapter.chapter_number}: ${chapter.chapter_title}</p>
                        ${chapter.chapter_season ? `<span class="inline-block mt-1 px-2 py-1 text-xs bg-purple-100 text-purple-700 dark-mode:bg-purple-600 dark-mode:text-purple-100 rounded">S. ${chapter.chapter_season}</span>` : ''}
                        <p class="text-xs text-gray-500 dark-mode:text-gray-400 mt-1">${formatDate(chapter.date_added)}</p>
                    </div>
                    <div class="flex items-center space-x-2 ml-4">
                        ${isDeveloperMode() ? `
                        <button onclick="event.stopPropagation(); openEditChapterModal('${chapter.__backendId}')" class="p-2 text-blue-500 hover:bg-blue-50 dark-mode:hover:bg-blue-900 rounded-lg transition-colors" title="Modifier ce chapitre">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                            </svg>
                        </button>
                        <button onclick="event.stopPropagation(); deleteChapter('${chapter.__backendId}')" class="p-2 text-red-500 hover:bg-red-50 dark-mode:hover:bg-red-900 rounded-lg transition-colors" title="Supprimer ce chapitre">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                            </svg>
                        </button>
                        ` : ''}
                        <button onclick="event.stopPropagation(); toggleFavorite('${chapter.__backendId}')" class="p-2 ${chapter.is_favorite ? 'text-red-500' : 'text-gray-400'} hover:bg-gray-50 dark-mode:hover:bg-gray-700 rounded-lg transition-colors" title="${chapter.is_favorite ? 'Retirer des favoris' : 'Ajouter aux favoris'}">
                            <svg class="w-5 h-5" fill="${chapter.is_favorite ? '#ef4444' : 'none'}" stroke="${chapter.is_favorite ? 'none' : 'currentColor'}" stroke-width="${chapter.is_favorite ? '0' : '2'}" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
                            </svg>
                        </button>
                    </div>
                `;
                favoritesList.appendChild(item);
            });
        }
        
        // Fonction pour ajouter/retirer un chapitre des favoris (FONCTIONNE EN LIGNE ET LOCAL)
        async function toggleFavorite(chapterId) {
            console.log('‚ù§Ô∏è Toggle favorite pour chapitre:', chapterId);
            const chapter = allChapters.find(ch => ch.__backendId === chapterId);
            if (!chapter) {
                console.error('‚ùå Chapitre non trouv√©:', chapterId);
                return;
            }
            
            // Mettre √† jour imm√©diatement dans la liste locale
            const newFavoriteStatus = !chapter.is_favorite;
            chapter.is_favorite = newFavoriteStatus;
            
            // Mettre √† jour aussi dans allChapters
            const chapterIndex = allChapters.findIndex(ch => ch.__backendId === chapterId);
            if (chapterIndex !== -1) {
                allChapters[chapterIndex].is_favorite = newFavoriteStatus;
            }
            
            // Mettre √† jour l'UI imm√©diatement
            updateAllPages();
            
            // Sauvegarder (en ligne: localStorage, en local: data.php)
            if (isDeveloperMode()) {
                // En mode d√©veloppeur, sauvegarder dans data.php
                const updatedChapter = {
                    ...chapter,
                    is_favorite: newFavoriteStatus
                };
                const result = await window.dataSdk.update(updatedChapter);
                if (result.isOk) {
                    showNotification(newFavoriteStatus ? 'Ajout√© aux favoris ‚ù§Ô∏è' : 'Retir√© des favoris', 'success');
                } else {
                    console.error('‚ùå Erreur lors de la mise √† jour:', result.error);
                }
            } else {
                // En ligne, sauvegarder dans localStorage pour la synchronisation
                const favorites = JSON.parse(localStorage.getItem('favorites') || '[]');
                if (newFavoriteStatus) {
                    if (!favorites.includes(chapterId)) {
                        favorites.push(chapterId);
                    }
                } else {
                    const index = favorites.indexOf(chapterId);
                    if (index > -1) {
                        favorites.splice(index, 1);
                    }
                }
                localStorage.setItem('favorites', JSON.stringify(favorites));
                showNotification(newFavoriteStatus ? 'Ajout√© aux favoris ‚ù§Ô∏è' : 'Retir√© des favoris', 'success');
            }
        }
        
        window.toggleFavorite = toggleFavorite;

        // Fonction de recherche et filtrage pour la corbeille
        function filterAndSearchTrash() {
            const searchTerm = (document.getElementById('trash-search')?.value || '').toLowerCase();
            const filterValue = document.getElementById('trash-filter')?.value || 'all';
            
            let filtered = globalData.filter(item => item.type === 'trash');
            
            // Recherche
            if (searchTerm) {
                filtered = filtered.filter(trashItem => {
                    if (trashItem.trash_type === 'manhwa') {
                        return trashItem.original_data.manhwa_title?.toLowerCase().includes(searchTerm);
                    } else if (trashItem.trash_type === 'chapter') {
                        return trashItem.original_data.chapter_title?.toLowerCase().includes(searchTerm) ||
                               trashItem.original_data.chapter_number?.toString().includes(searchTerm);
                    } else if (trashItem.trash_type === 'tracking') {
                        return trashItem.original_data.title?.toLowerCase().includes(searchTerm);
                    }
                    return false;
                });
            }
            
            // Filtrage
            switch(filterValue) {
                case 'manhwa':
                case 'chapter':
                case 'tracking':
                    filtered = filtered.filter(item => item.trash_type === filterValue);
                    break;
                case 'recent':
                    filtered.sort((a, b) => new Date(b.deleted_at) - new Date(a.deleted_at));
                    break;
                case 'oldest':
                    filtered.sort((a, b) => new Date(a.deleted_at) - new Date(b.deleted_at));
                    break;
            }
            
            return filtered;
        }
        
        // Page corbeille
        function updateTrashPage() {
            const trashList = document.getElementById('trash-list');
            if (!trashList) return;
            
            trashList.innerHTML = '';
            
            const trashItems = filterAndSearchTrash();
            const allTrashItems = globalData.filter(item => item.type === 'trash');
            
            if (trashItems.length === 0) {
                trashList.innerHTML = `
                    <div class="text-center py-12">
                        <svg class="w-24 h-24 mx-auto text-gray-300 dark-mode:text-gray-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                        <h3 class="text-xl font-semibold text-gray-600 dark-mode:text-gray-300 mb-2">${allTrashItems.length === 0 ? 'Corbeille vide' : 'Aucun r√©sultat trouv√©'}</h3>
                        <p class="text-gray-500 dark-mode:text-gray-400 mb-4">${allTrashItems.length === 0 ? 'Les √©l√©ments supprim√©s appara√Ætront ici' : 'Essayez une autre recherche'}</p>
                    </div>
                `;
                return;
            }
            
            trashItems.forEach(trashItem => {
                const item = document.createElement('div');
                item.className = 'bg-white rounded-lg shadow-md p-4 flex items-center justify-between card';
                
                let title = '';
                let subtitle = '';
                let icon = '';
                
                if (trashItem.trash_type === 'manhwa') {
                    title = trashItem.original_data.manhwa_title;
                    subtitle = 'Manhwa';
                    icon = 'üìö';
                } else if (trashItem.trash_type === 'chapter') {
                    const manhwa = allManhwas.find(m => m.manhwa_id === trashItem.original_data.manhwa_id);
                    title = `Chapitre ${trashItem.original_data.chapter_number}: ${trashItem.original_data.chapter_title}`;
                    subtitle = manhwa ? `de ${manhwa.manhwa_title}` : 'Chapitre';
                    icon = 'üìñ';
                } else if (trashItem.trash_type === 'tracking') {
                    title = trashItem.original_data.title;
                    subtitle = 'Suivi de lecture';
                    icon = 'üìä';
                }
                
                item.innerHTML = `
                    <div class="flex items-center flex-grow">
                        <span class="text-2xl mr-4">${icon}</span>
                        <div>
                            <h4 class="font-semibold text-gray-900 dark-mode:text-gray-100">${title}</h4>
                            <p class="text-sm text-gray-600 dark-mode:text-gray-300">${subtitle}</p>
                            <p class="text-xs text-gray-500 dark-mode:text-gray-400 mt-1">Supprim√© le ${formatDate(trashItem.deleted_at)}</p>
                        </div>
                    </div>
                    <div class="flex space-x-2">
                        <button onclick="restoreFromTrash('${trashItem.id}')" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors" title="Restaurer">
                            Restaurer
                        </button>
                        <button onclick="deletePermanentlyFromTrash('${trashItem.id}')" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors" title="Supprimer d√©finitivement">
                            Supprimer d√©finitivement
                        </button>
                    </div>
                `;
                trashList.appendChild(item);
            });
        }
        
 // ...existing code...
window.restoreFromTrash = async function(trashId) {
    const confirmed = await showConfirmDialog(
        'Restaurer cet √©l√©ment ?',
        'L\'√©l√©ment sera remis dans vos suivis.'
    );
    if (!confirmed) return;

    if (!trashId) {
        showNotification('Erreur : ID manquant pour la restauration', 'error');
        return;
    }

    try {
        const response = await fetch('save-data.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'restore',
                item: { id: trashId, trash_type: 'tracking' }
            })
        });

        // Parser la r√©ponse JSON en toute s√©curit√©
        const result = await response.json();

        if (result.success) {
            showNotification('√âl√©ment restaur√© avec succ√®s !', 'success');

            // Retirer de la corbeille localement et ajouter aux suivis
            const restoredItemIndex = globalData.findIndex(item => item.id === trashId);
            if (restoredItemIndex !== -1) {
                const restored = globalData[restoredItemIndex];
                restored.type = 'tracking';
                trackingList.push(restored);
                globalData.splice(restoredItemIndex, 1);
            }

            updateAllPages();
            updateTrashPage();

            if (isDeveloperMode()) {
                scheduleAutoSave(globalData);
            } else {
                await saveDataToFileAuto(globalData);
            }
        } else {
            showNotification(`Erreur : ${result.message}`, 'error');
        }
    } catch (err) {
        console.error(err);
        showNotification('Erreur r√©seau ou serveur', 'error');
    }
};
// ...existing code...


      window.deletePermanentlyFromTrash = async function(trashId) {
    const confirmed = await showConfirmDialog(
        'Supprimer d√©finitivement ?',
        'Cette action est irr√©versible.'
    );
    if (!confirmed) return;

    try {
        // Use save-data.php POST delete_permanent for consistent behavior
        const resp = await fetch('save-data.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'delete_permanent', id: trashId })
        });

        const text = await resp.text();
        let result = null;
        if (text && text.trim().length > 0) {
            try { result = JSON.parse(text); } catch (e) { result = { success: resp.ok, message: text }; }
        } else {
            result = { success: resp.ok };
        }

        if (result && result.success) {
            showNotification('√âl√©ment supprim√© d√©finitivement', 'success');

            // Retirer localement pour mettre √† jour l'affichage
            globalData = globalData.filter(item => item.id !== trashId);

            // Persist local change depending on mode
            if (isDeveloperMode()) {
                scheduleAutoSave(globalData);
            } else {
                await saveDataToFileAuto(globalData);
            }

            // Mettre √† jour l'affichage
            updateAllPages();
        } else {
            showNotification(`Erreur : ${result && result.message ? result.message : 'suppression √©chou√©e'}`, 'error');
        }
    } catch (err) {
        console.error(err);
        showNotification('Erreur r√©seau ou serveur', 'error');
    }
};

        // Mise √† jour de toutes les pages
        function updateAllPages() {
            updateHomePage();
            updateLibraryPage();
            updateRecentPage();
            updateFavoritesPage();
            updateTrackingPage();
            updateTrashPage();
            updateGalleryPage();
            updateStatistics();
            
            // Si on est sur la page de d√©tail d'un manhwa, la mettre √† jour aussi
            const manhwaDetailPage = document.getElementById('manhwa-detail-page');
            if (manhwaDetailPage && !manhwaDetailPage.classList.contains('hidden') && currentManhwaId) {
                showManhwaDetail(currentManhwaId);
            }
            
            // Sauvegarder la page actuelle (sauf si c'est home)
            const currentPage = document.querySelector('.page-content:not(.hidden)')?.id;
            if (currentPage) {
                const pageName = currentPage.replace('-page', '').replace('page-', '');
                if (pageName !== 'home') {
                    localStorage.setItem('currentPage', pageName);
                }
            }
        }
        
        // Page Galerie
       
        
        async function loadGalleryImages() {
            try {
                if (isDeveloperMode()) {
                    // En mode d√©veloppeur, scanner le dossier gallery via PHP
                    const response = await fetch('./scan-gallery.php?t=' + Date.now());
                    if (response.ok) {
                        const data = await response.json();
                        galleryImages = data.images || [];
                    } else {
                        console.error('Erreur scan gallery:', response.status);
                        galleryImages = [];
                    }
                } else {
                    // En ligne, essayer gallery-list.json, sinon retomber sur scan-gallery.php
                    try {
                        const response = await fetch('./gallery-list.json?t=' + Date.now());
                        if (response.ok) {
                            const data = await response.json();
                            galleryImages = data.images || [];
                        } else {
                            // Si le fichier n'existe pas, essayer de scanner via scan-gallery.php
                            console.warn('‚ö†Ô∏è gallery-list.json non trouv√©. Tentative de fallback via scan-gallery.php');
                            const scanResp = await fetch('./scan-gallery.php?t=' + Date.now());
                            if (scanResp.ok) {
                                const scanData = await scanResp.json();
                                galleryImages = scanData.images || [];
                            } else {
                                galleryImages = [];
                                console.warn('‚ö†Ô∏è scan-gallery.php indisponible ou a renvoy√© une erreur');
                            }
                        }
                    } catch (err) {
                        console.error('Erreur chargement gallery:', err);
                        galleryImages = [];
                    }
                }
                
                // Shuffle automatique √† chaque chargement
                if (galleryImages.length > 0) {
                    for (let i = galleryImages.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [galleryImages[i], galleryImages[j]] = [galleryImages[j], galleryImages[i]];
                    }
                }
            } catch (error) {
                console.error('Erreur lors du chargement de la galerie:', error);
                galleryImages = [];
            }
            updateGalleryPage();
        }
        
        function updateGalleryPage() {
            const galleryGrid = document.getElementById('gallery-grid');
            if (!galleryGrid) return;
            
            galleryGrid.innerHTML = '';
            
            if (galleryImages.length === 0) {
                galleryGrid.innerHTML = `
                    <div class="col-span-full text-center py-12">
                        <p class="text-gray-500 dark-mode:text-gray-300">Aucune image dans la galerie</p>
                        <p class="text-sm text-gray-400 dark-mode:text-gray-500 mt-2">Ajoutez des images dans le dossier gallery/</p>
                    </div>
                `;
                return;
            }
            
            galleryImages.forEach((image, index) => {
                const item = document.createElement('div');
                item.className = 'break-inside-avoid mb-4 bg-white rounded-lg shadow-md overflow-hidden cursor-move draggable-gallery-item';
                item.draggable = true;
                item.dataset.imageIndex = index;
                
                // Drag & Drop
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', index.toString());
                    item.classList.add('opacity-50');
                });
                
                item.addEventListener('dragend', () => {
                    item.classList.remove('opacity-50');
                });
                
                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    item.classList.add('border-2', 'border-indigo-500');
                });
                
                item.addEventListener('dragleave', () => {
                    item.classList.remove('border-2', 'border-indigo-500');
                });
                
                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    item.classList.remove('border-2', 'border-indigo-500');
                    
                    const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    if (draggedIndex === index) return;
                    
                    // R√©organiser
                    const temp = galleryImages[draggedIndex];
                    galleryImages[draggedIndex] = galleryImages[index];
                    galleryImages[index] = temp;
                    
                    updateGalleryPage();
                });
                
                item.innerHTML = `
                    <img src="${image.path}" alt="${image.name}" class="w-full h-auto object-cover rounded-lg cursor-pointer hover:opacity-90 transition-opacity" loading="lazy" onclick="window.open('${image.path}', '_blank')">
                `;
                
                galleryGrid.appendChild(item);
            });
        }
        
        function shuffleGallery() {
            // M√©langer al√©atoirement
            for (let i = galleryImages.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [galleryImages[i], galleryImages[j]] = [galleryImages[j], galleryImages[i]];
            }
            updateGalleryPage();
        }
        
        window.shuffleGallery = shuffleGallery;

        // Mise √† jour des statistiques
        function updateStatistics() {
            document.getElementById('stats-manhwas').textContent = allManhwas.length;
            document.getElementById('stats-chapters').textContent = allChapters.length;
        }

        // Page d'accueil
        function updateHomePage() {
            const continueReadingContainer = document.getElementById('continue-reading');
            const latestChaptersContainer = document.getElementById('latest-chapters');

            continueReadingContainer.innerHTML = '';
            latestChaptersContainer.innerHTML = '';

            if (allManhwas.length === 0) {
                continueReadingContainer.innerHTML = `
                    <div class="col-span-full text-center py-12">
                        <svg class="w-24 h-24 mx-auto text-gray-300 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
                        </svg>
                        <h3 class="text-xl font-semibold text-gray-600 dark-mode:text-gray-200 mb-2">Aucun manhwa dans votre biblioth√®que</h3>
                        <p class="text-gray-500 dark-mode:text-gray-300 mb-4">${isDeveloperMode() ? 'Commencez par ajouter votre premier manhwa!' : 'La biblioth√®que est vide. Les manhwas doivent √™tre ajout√©s en mode d√©veloppeur (localhost).'}</p>
                        ${isDeveloperMode() ? `
                        <button onclick="openAddManhwaModal()" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700">
                            Ajouter un Manhwa
                        </button>
                        ` : ''}
                    </div>
                `;
                return;
            }

            // Afficher les manhwas avec progression
            allManhwas.forEach(manhwa => {
                const chapters = allChapters.filter(ch => ch.manhwa_id === manhwa.manhwa_id);
                const totalChapters = chapters.length;
                const lastChapter = chapters.sort((a, b) => b.chapter_number - a.chapter_number)[0];

                const card = document.createElement('div');
                card.className = 'card bg-white rounded-lg shadow-md overflow-hidden cursor-pointer';
                card.onclick = () => showManhwaDetail(manhwa.manhwa_id);
                card.innerHTML = `
                    <img src="${manhwa.manhwa_cover}" alt="${manhwa.manhwa_title}" class="manhwa-cover">
                    <div class="p-4">
                        <h3 class="font-bold text-lg mb-2">${manhwa.manhwa_title}</h3>
                        ${lastChapter ? `
                            <p class="text-sm text-gray-600 mb-2">Dernier chapitre: ${lastChapter.chapter_number}</p>
                            <span class="badge bg-indigo-100 text-indigo-600">${totalChapters} chapitres</span>
                        ` : `
                            <p class="text-sm text-gray-600 dark-mode:text-blue-200">Aucun chapitre disponible</p>
                        `}
                    </div>
                `;
                continueReadingContainer.appendChild(card);
            });

            // Afficher les derniers chapitres
            const sortedChapters = [...allChapters].sort((a, b) => 
                new Date(b.date_added) - new Date(a.date_added)
            ).slice(0, 10);

            sortedChapters.forEach(chapter => {
                const manhwa = allManhwas.find(m => m.manhwa_id === chapter.manhwa_id);
                if (!manhwa) return;

                const chapterItem = document.createElement('div');
                chapterItem.className = 'chapter-item bg-white rounded-lg shadow-md p-4 flex items-center cursor-pointer';
                chapterItem.onclick = () => readChapter(chapter.manhwa_id, chapter.chapter_number);
                // Utiliser l'image de couverture du chapitre si elle existe, sinon celle du manhwa
                const chapterCover = chapter.chapter_cover || manhwa.manhwa_cover;
                chapterItem.innerHTML = `
                    <img src="${chapterCover}" alt="${manhwa.manhwa_title}" class="w-16 h-20 object-cover rounded mr-4">
                    <div class="flex-grow">
                        <h4 class="font-semibold">${manhwa.manhwa_title}</h4>
                        <p class="text-sm text-gray-600">Chapitre ${chapter.chapter_number}: ${chapter.chapter_title}</p>
                        <p class="text-xs text-gray-500 mt-1">${formatDate(chapter.date_added)}</p>
                    </div>
                    <svg class="w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                `;
                latestChaptersContainer.appendChild(chapterItem);
            });
        }

        // Fonction pour ouvrir le modal d'ajout de manhwa
        function openAddManhwaModal() {
            // V√©rifier le mode d√©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }
            
            addManhwaModal.classList.remove('hidden');
        }

        // Fonction de recherche et filtrage pour la biblioth√®que
        function filterAndSearchLibrary() {
            const searchTerm = (document.getElementById('library-search')?.value || '').toLowerCase();
            const filterValue = document.getElementById('library-filter')?.value || 'all';
            
            let filtered = [...allManhwas];
            
            // Recherche (inclut les descriptions)
            if (searchTerm) {
                filtered = filtered.filter(manhwa => {
                    const manhwaMatch = manhwa.manhwa_title.toLowerCase().includes(searchTerm) ||
                                       manhwa.manhwa_description?.toLowerCase().includes(searchTerm);
                    // Chercher aussi dans les chapitres de ce manhwa
                    const chapters = allChapters.filter(ch => ch.manhwa_id === manhwa.manhwa_id);
                    const chapterMatch = chapters.some(ch => 
                        ch.chapter_title?.toLowerCase().includes(searchTerm) ||
                        ch.chapter_description?.toLowerCase().includes(searchTerm) ||
                        ch.chapter_number.toString().includes(searchTerm)
                    );
                    return manhwaMatch || chapterMatch;
                });
            }
            
            // Filtrage
            switch(filterValue) {
                case 'az':
                    filtered.sort((a, b) => a.manhwa_title.localeCompare(b.manhwa_title));
                    break;
                case 'za':
                    filtered.sort((a, b) => b.manhwa_title.localeCompare(a.manhwa_title));
                    break;
                case 'recent':
                    filtered.sort((a, b) => new Date(b.date_added) - new Date(a.date_added));
                    break;
                case 'oldest':
                    filtered.sort((a, b) => new Date(a.date_added) - new Date(b.date_added));
                    break;
            }
            
            return filtered;
        }

        // Page biblioth√®que
        function updateLibraryPage() {
            const libraryGrid = document.getElementById('library-grid');
            libraryGrid.innerHTML = '';

            if (allManhwas.length === 0) {
                libraryGrid.innerHTML = `
                    <div class="col-span-full text-center py-12">
                        <p class="text-gray-500 dark-mode:text-gray-400">Votre biblioth√®que est vide</p>
                    </div>
                `;
                return;
            }

            const filteredManhwas = filterAndSearchLibrary();
            
            if (filteredManhwas.length === 0) {
                libraryGrid.innerHTML = `
                    <div class="col-span-full text-center py-12">
                        <p class="text-gray-500 dark-mode:text-gray-400">Aucun r√©sultat trouv√©</p>
                    </div>
                `;
                return;
            }

            filteredManhwas.forEach((manhwa, index) => {
                const chapters = allChapters.filter(ch => ch.manhwa_id === manhwa.manhwa_id);
                const card = document.createElement('div');
                card.className = 'card bg-white rounded-lg shadow-md overflow-hidden cursor-move draggable-item';
                card.draggable = true;
                card.dataset.manhwaId = manhwa.__backendId;
                card.dataset.index = index;
                // Toujours activer le drag & drop, m√™me en ligne
                
                // Drag & Drop (cliquer-d√©placer)
                let clickTimeout = null;
                
                card.addEventListener('mousedown', (e) => {
                    // Ne pas activer le drag si on clique sur un bouton
                    if (e.target.closest('button')) {
                        return;
                    }
                    // Si on clique sur le contenu (img, h3, p, span), ouvrir le d√©tail apr√®s un court d√©lai
                    if (e.target.tagName === 'IMG' || e.target.tagName === 'H3' || e.target.tagName === 'P' || e.target.tagName === 'SPAN') {
                        clickTimeout = setTimeout(() => {
                            showManhwaDetail(manhwa.manhwa_id);
                        }, 200);
                        return;
                    }
                });
                
                card.addEventListener('dragstart', (e) => {
                    // Annuler le clic si on commence √† drag
                    if (clickTimeout) {
                        clearTimeout(clickTimeout);
                        clickTimeout = null;
                    }
                    e.dataTransfer.setData('text/plain', manhwa.__backendId);
                    e.dataTransfer.effectAllowed = 'move';
                    card.classList.add('opacity-50');
                });
                
                card.addEventListener('dragend', () => {
                    card.classList.remove('opacity-50');
                });
                
                card.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    card.classList.add('border-2', 'border-indigo-500');
                });
                
                card.addEventListener('dragleave', () => {
                    card.classList.remove('border-2', 'border-indigo-500');
                });
                
                card.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    card.classList.remove('border-2', 'border-indigo-500');
                    
                    const draggedId = e.dataTransfer.getData('text/plain');
                    if (draggedId === manhwa.__backendId) return;
                    
                    await reorderManhwas(draggedId, manhwa.__backendId);
                });
                
                card.innerHTML = `
                    <img src="${manhwa.manhwa_cover}" alt="${manhwa.manhwa_title}" class="manhwa-cover">
                    <div class="p-4">
                        <h3 class="font-bold text-lg mb-2">${manhwa.manhwa_title}</h3>
                        <p class="text-sm text-gray-600 mb-2 line-clamp-2">${manhwa.manhwa_description}</p>
                        <span class="badge bg-indigo-100 text-indigo-600">${chapters.length} chapitres</span>
                    </div>
                `;
                libraryGrid.appendChild(card);
            });
        }

        // Fonction de recherche et filtrage pour les r√©cents
        function filterAndSearchRecent() {
            const searchTerm = (document.getElementById('recent-search')?.value || '').toLowerCase();
            const filterValue = document.getElementById('recent-filter')?.value || 'recent';
            
            let filtered = [...allChapters];
            
            // Recherche (inclut les descriptions)
            if (searchTerm) {
                filtered = filtered.filter(chapter => {
                    const manhwa = allManhwas.find(m => m.manhwa_id === chapter.manhwa_id);
                    return manhwa && (
                        manhwa.manhwa_title.toLowerCase().includes(searchTerm) ||
                        manhwa.manhwa_description?.toLowerCase().includes(searchTerm) ||
                        chapter.chapter_title?.toLowerCase().includes(searchTerm) ||
                        chapter.chapter_description?.toLowerCase().includes(searchTerm) ||
                        chapter.chapter_number.toString().includes(searchTerm)
                    );
                });
            }
            
            // Filtrage
            switch(filterValue) {
                case 'recent':
                    filtered.sort((a, b) => new Date(b.date_added) - new Date(a.date_added));
                    break;
                case 'oldest':
                    filtered.sort((a, b) => new Date(a.date_added) - new Date(b.date_added));
                    break;
                case 'az':
                    filtered.sort((a, b) => {
                        const manhwaA = allManhwas.find(m => m.manhwa_id === a.manhwa_id);
                        const manhwaB = allManhwas.find(m => m.manhwa_id === b.manhwa_id);
                        return (manhwaA?.manhwa_title || '').localeCompare(manhwaB?.manhwa_title || '');
                    });
                    break;
                case 'za':
                    filtered.sort((a, b) => {
                        const manhwaA = allManhwas.find(m => m.manhwa_id === a.manhwa_id);
                        const manhwaB = allManhwas.find(m => m.manhwa_id === b.manhwa_id);
                        return (manhwaB?.manhwa_title || '').localeCompare(manhwaA?.manhwa_title || '');
                    });
                    break;
            }
            
            return filtered.slice(0, 50);
        }

        // Page r√©cents
        function updateRecentPage() {
            const recentList = document.getElementById('recent-list');
            recentList.innerHTML = '';

            const recentChapters = filterAndSearchRecent();

            if (recentChapters.length === 0) {
                recentList.innerHTML = `
                    <div class="text-center py-12">
                        <p class="text-gray-500 dark-mode:text-gray-400">${allChapters.length === 0 ? 'Aucun historique de lecture' : 'Aucun r√©sultat trouv√©'}</p>
                    </div>
                `;
                return;
            }

            recentChapters.forEach(chapter => {
                const manhwa = allManhwas.find(m => m.manhwa_id === chapter.manhwa_id);
                if (!manhwa) return;

                // Utiliser l'image de couverture du chapitre si elle existe, sinon celle du manhwa
                const chapterCover = chapter.chapter_cover || manhwa.manhwa_cover;

                const item = document.createElement('div');
                item.className = 'bg-white rounded-lg shadow-md p-4 flex items-center cursor-pointer hover:bg-gray-50 card chapter-item';
                item.onclick = () => readChapter(chapter.manhwa_id, chapter.chapter_number);
                item.innerHTML = `
                    <img src="${chapterCover}" alt="${manhwa.manhwa_title}" class="w-16 h-20 object-cover rounded mr-4">
                    <div class="flex-grow">
                        <h4 class="font-semibold text-gray-900 dark-mode:text-gray-100">${manhwa.manhwa_title}</h4>
                        <p class="text-sm text-gray-600 dark-mode:text-gray-300">Chapitre ${chapter.chapter_number}: ${chapter.chapter_title}</p>
                        <p class="text-xs text-gray-500 dark-mode:text-gray-400 mt-1">${formatDate(chapter.date_added)}</p>
                    </div>
                `;
                // Ajouter boutons (modifier, supprimer, favori) en mode d√©veloppeur
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'flex items-center space-x-2 ml-4';
                
                if (isDeveloperMode()) {
                    const editBtn = document.createElement('button');
                    editBtn.className = 'p-2 text-blue-500 hover:bg-blue-50 dark-mode:hover:bg-blue-900 rounded-lg transition-colors';
                    editBtn.title = 'Modifier ce chapitre';
                    editBtn.onclick = (e) => {
                        e.stopPropagation();
                        openEditChapterModal(chapter.__backendId);
                    };
                    editBtn.innerHTML = `
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                        </svg>
                    `;
                    actionsDiv.appendChild(editBtn);
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'p-2 text-red-500 hover:bg-red-50 dark-mode:hover:bg-red-900 rounded-lg transition-colors';
                    deleteBtn.title = 'Supprimer ce chapitre';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteChapter(chapter.__backendId);
                    };
                    deleteBtn.innerHTML = `
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                    `;
                    actionsDiv.appendChild(deleteBtn);
                }
                
                const favoriteBtn = document.createElement('button');
                favoriteBtn.className = `p-2 ${chapter.is_favorite ? 'text-red-500' : 'text-gray-400'} hover:bg-gray-50 dark-mode:hover:bg-gray-700 rounded-lg transition-colors`;
                favoriteBtn.title = chapter.is_favorite ? 'Retirer des favoris' : 'Ajouter aux favoris';
                favoriteBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleFavorite(chapter.__backendId);
                };
                favoriteBtn.innerHTML = `
                    <svg class="w-5 h-5" fill="${chapter.is_favorite ? '#ef4444' : 'none'}" stroke="currentColor" stroke-width="${chapter.is_favorite ? '0' : '2'}" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
                    </svg>
                `;
                actionsDiv.appendChild(favoriteBtn);
                
                item.appendChild(actionsDiv);
                
                recentList.appendChild(item);
            });
        }

        // Afficher le d√©tail d'un manhwa
        function showManhwaDetail(manhwaId) {
            currentManhwaId = manhwaId;
            // Sauvegarder l'ID du manhwa affich√© pour restauration apr√®s reload
            try { localStorage.setItem('currentManhwaId', manhwaId); } catch (e) { /* ignore */ }
            const manhwa = allManhwas.find(m => m.manhwa_id === manhwaId);
            if (!manhwa) return;

            const chapters = allChapters
                .filter(ch => ch.manhwa_id === manhwaId)
                .sort((a, b) => a.chapter_number - b.chapter_number);

            const detailContent = document.getElementById('manhwa-detail-content');
            detailContent.innerHTML = `
                <div class="grid md:grid-cols-3 gap-8 mb-8">
                    <div>
                        <img src="${manhwa.manhwa_cover}" alt="${manhwa.manhwa_title}" class="w-full rounded-lg shadow-lg">
                    </div>
                    <div class="md:col-span-2">
                        <h1 class="text-4xl font-bold mb-4">${manhwa.manhwa_title}</h1>
                        <p class="text-gray-600 mb-6">${manhwa.manhwa_description}</p>
                        <div class="flex items-center space-x-4 mb-6">
                            <span class="badge bg-indigo-100 text-indigo-600">${chapters.length} chapitres</span>
                            <span class="badge bg-green-100 text-green-600">En cours</span>
                        </div>
                        <div class="flex space-x-3">
                            ${isDeveloperMode() ? `
                            <button type="button" onclick="event.stopPropagation(); openEditManhwaModal('${manhwa.__backendId}')" class="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 flex items-center">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                                </svg>
                                Modifier
                            </button>
                            ` : ''}
                            ${isDeveloperMode() && !isLocalMode ? `
                            <button type="button" onclick="event.stopPropagation(); openAddChapterModal()" class="bg-indigo-600 text-white px-6 py-3 rounded-lg hover:bg-indigo-700 flex items-center">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                                </svg>
                                Ajouter un Chapitre
                            </button>
                            <button type="button" onclick="event.stopPropagation(); deleteManhwa('${manhwa.__backendId}')" class="bg-red-600 text-white px-6 py-3 rounded-lg hover:bg-red-700 flex items-center">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                </svg>
                                Supprimer ce Manhwa
                            </button>
                            ` : ''}
                            ${isLocalMode ? `
                            <button type="button" onclick="event.stopPropagation(); openMissingChaptersModal('${manhwa.manhwa_id}')" class="bg-yellow-500 text-white px-6 py-3 rounded-lg hover:bg-yellow-600 flex items-center ml-3">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6M12 9v6"></path></svg>
                                Chapitres manquants
                            </button>
                            ` : ''}
                        </div>
                    </div>
                </div>

                <h2 class="text-2xl font-bold mb-4">Liste des Chapitres</h2>
                <div class="space-y-3">
                    ${chapters.length === 0 ? `
                        <div class="bg-gray-100 dark-mode:bg-gray-900 rounded-lg p-8 text-center border border-gray-300 dark-mode:border-gray-700">
                            <p class="text-gray-800 dark-mode:text-blue-200 text-lg font-medium">Aucun chapitre disponible. Ajoutez-en un!</p>
                        </div>
                    ` : chapters.map(chapter => {
                        // Utiliser l'image de couverture du chapitre si elle existe, sinon celle du manhwa
                        const chapterCover = chapter.chapter_cover || manhwa.manhwa_cover;
                        return `
                        <div class="chapter-item bg-white rounded-lg shadow-md p-4 flex items-center">
                            <img src="${chapterCover}" alt="${manhwa.manhwa_title}" class="w-12 h-16 object-cover rounded mr-4">
                            <div class="flex-shrink-0 w-12 h-12 bg-indigo-100 rounded-lg flex items-center justify-center mr-4">
                                <span class="font-bold text-indigo-600">${chapter.chapter_number}</span>
                            </div>
                            <div class="flex-grow cursor-pointer" onclick="readChapter('${manhwaId}', ${chapter.chapter_number})">
                                <h3 class="font-semibold">Chapitre ${chapter.chapter_number}: ${chapter.chapter_title}</h3>
                                ${chapter.chapter_description ? `<p class="text-sm text-gray-600 dark-mode:text-gray-300">${chapter.chapter_description}</p>` : ''}
                                ${chapter.chapter_season ? `<span class="inline-block mt-1 px-2 py-1 text-xs bg-purple-100 text-purple-700 dark-mode:bg-purple-600 dark-mode:text-purple-100 rounded">S. ${chapter.chapter_season}</span>` : ''}
                                <p class="text-xs text-gray-500 dark-mode:text-gray-400 mt-1">${formatDate(chapter.date_added)}</p>
                            </div>
                            ${isDeveloperMode() ? `
                            <button onclick="event.stopPropagation(); openEditChapterModal('${chapter.__backendId}')" class="ml-4 p-2 text-blue-500 hover:bg-blue-50 rounded-lg transition-colors" title="Modifier ce chapitre">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                                </svg>
                            </button>
                            ` : ''}
                            ${isDeveloperMode() ? `
                            <button onclick="event.stopPropagation(); deleteChapter('${chapter.__backendId}')" class="ml-2 p-2 text-red-500 hover:bg-red-50 rounded-lg transition-colors" title="Supprimer ce chapitre">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                </svg>
                            </button>
                            ` : ''}
                            <button onclick="event.stopPropagation(); toggleFavorite('${chapter.__backendId}')" class="ml-2 p-2 ${chapter.is_favorite ? 'text-red-500' : 'text-gray-400'} hover:bg-gray-50 dark-mode:hover:bg-gray-700 rounded-lg transition-colors" title="${chapter.is_favorite ? 'Retirer des favoris' : 'Ajouter aux favoris'}">
                                <svg class="w-5 h-5" fill="${chapter.is_favorite ? '#ef4444' : 'none'}" stroke="${chapter.is_favorite ? 'none' : 'currentColor'}" stroke-width="${chapter.is_favorite ? '0' : '2'}" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
                                </svg>
                            </button>
                            <svg class="w-6 h-6 text-gray-400 cursor-pointer ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" onclick="readChapter('${manhwaId}', ${chapter.chapter_number})">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path>
                            </svg>
                        </div>
                    `;
                    }).join('')}
                </div>
            `;

            showPage('manhwa-detail');
        }

        // Ouvrir le modal d'ajout de chapitre
        async function openAddChapterModal() {
            // V√©rifier le mode d√©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }
            
            // Charger les dossiers disponibles avant d'afficher
            await loadChapterFolders();
            // Si on est en mode local, masquer la s√©lection manuelle du dossier
            try {
                const sel = document.getElementById('chapter-folder-select');
                if (sel) {
                    if (isLocalMode) sel.style.display = 'none'; else sel.style.display = '';
                }
            } catch (e) {}
            addChapterModal.classList.remove('hidden');
        }

        // Modal: Chapitres manquants logic
        let _missing_currentManhwa = null;
        document.getElementById('close-missing-chapters').addEventListener('click', () => {
            document.getElementById('missing-chapters-modal').classList.add('hidden');
            document.getElementById('missing-results').innerHTML = '';
        });

        async function openMissingChaptersModal(manhwaId) {
            _missing_currentManhwa = manhwaId;
            document.getElementById('missing-chapters-modal').classList.remove('hidden');
            document.getElementById('missing-results').innerHTML = '';
            document.getElementById('missing-max-input').value = '';
        }

        async function checkMissingChapters() {
            const max = parseInt(document.getElementById('missing-max-input').value);
            if (!max || max < 1) { showNotification('Entrez un num√©ro max valide', 'error'); return; }
            try {
                // Get folder mapping
                const mapResp = await fetch('./api-manhwa-folders.php');
                const mapJson = await mapResp.json();
                const folder = mapJson.map && mapJson.map[_missing_currentManhwa] ? mapJson.map[_missing_currentManhwa] : null;
                if (!folder) { document.getElementById('missing-results').innerText = 'Aucun dossier associ√© √† ce manhwa.'; return; }
                const scanResp = await fetch(`./api-scan-chapters.php?folder=${encodeURIComponent(folder)}`);
                const scanJson = await scanResp.json();
                const present = (scanJson.chapters || []).map(n => Number(n));
                const missing = [];
                for (let i = 1; i <= max; i++) if (!present.includes(i)) missing.push(i);
                document.getElementById('missing-results').innerHTML = missing.length ? `Chapitres manquants: ${missing.join(', ')}` : 'Aucun chapitre manquant d√©tect√©';
                // store missing list for create
                document.getElementById('missing-results').dataset.missing = JSON.stringify(missing);
            } catch (err) {
                console.error('checkMissingChapters error', err);
                showNotification('Erreur lors de la v√©rification', 'error');
            }
        }

        async function createMissingChapters() {
            const raw = document.getElementById('missing-results').dataset.missing || '[]';
            const missing = JSON.parse(raw);
            if (!Array.isArray(missing) || missing.length === 0) { showNotification('Aucun chapitre √† cr√©er', 'info'); return; }
            for (const num of missing) {
                await fetch('./api-chapters.php', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ manhwa_id: _missing_currentManhwa, chapter_number: num }) });
            }
            showNotification(`${missing.length} chapitres cr√©√©s localement`, 'success');
            document.getElementById('missing-chapters-modal').classList.add('hidden');
        }

        document.getElementById('missing-check-btn').addEventListener('click', checkMissingChapters);
        document.getElementById('missing-create-btn').addEventListener('click', createMissingChapters);
        // Expose for templates and onclick handlers
        window.openMissingChaptersModal = openMissingChaptersModal;

        // Retour √† la biblioth√®que
        document.getElementById('back-to-library').addEventListener('click', () => {
            showPage('library');
        });

        // Lire un chapitre
        async function readChapter(manhwaId, chapterNumber) {
            // Ensure data is loaded (allChapters) before attempting to find chapter
            await ensureDataLoaded();

            currentManhwaId = manhwaId;
            currentChapterNumber = chapterNumber;
            // Sauvegarder pour restauration apr√®s reload
            try {
                localStorage.setItem('currentManhwaId', manhwaId);
                localStorage.setItem('currentChapterNumber', String(chapterNumber));
            } catch (e) { /* ignore */ }

            const chapter = allChapters.find(ch => 
                ch.manhwa_id === manhwaId && ch.chapter_number === chapterNumber
            );

            if (!chapter) {
                showNotification('Chapitre introuvable', 'error');
                return;
            }

            const manhwa = allManhwas.find(m => m.manhwa_id === manhwaId);
            
            // Mettre √† jour l'info du chapitre
            document.getElementById('chapter-info').textContent = 
                `${manhwa.manhwa_title} - Chapitre ${chapterNumber}`;

            const readerContent = document.getElementById('reader-content');
            
            // Afficher un loader
            readerContent.innerHTML = `
                <div class="flex flex-col items-center justify-center py-12">
                    <div class="loading-spinner mb-4"></div>
                    <p class="text-gray-600">Chargement du chapitre...</p>
                </div>
            `;

            showPage('reader');
            window.scrollTo(0, 0);
            
            // Charger les commentaires
            loadComments(manhwaId, chapterNumber);

            // Le chapter_pages contient maintenant le chemin du fichier (MHTML ou dossier dans /chapitres)
            const mhtmlPath = (chapter.chapter_pages || '').trim();
            
            // Nettoyer le chemin
            let cleanPath = mhtmlPath.replace(/\\/g, '/');
            if (cleanPath.includes('Site/')) {
                cleanPath = cleanPath.split('Site/')[1];
            }
            if (cleanPath.includes('chapitres/') && !cleanPath.startsWith('chapitres/')) {
                cleanPath = cleanPath.substring(cleanPath.indexOf('chapitres/'));
            }
            if (!cleanPath.startsWith('./') && !cleanPath.startsWith('/') && !cleanPath.startsWith('http')) {
                cleanPath = './' + cleanPath;
            }
            
            // Si le chemin pointe vers un dossier dans chapitres/, appeler l'API qui listera les images
            if (cleanPath.includes('chapitres/') && !cleanPath.toLowerCase().endsWith('.mhtml')) {
                try {
                    const resp = await fetch('api-chapter-images.php?path=' + encodeURIComponent(cleanPath));
                    if (resp.ok) {
                        const j = await resp.json();
                        if (j.success && Array.isArray(j.images) && j.images.length > 0) {
                            readerContent.innerHTML = '';
                            // Ins√©rer chaque image en ordre (top -> bottom)
                            for (const img of j.images) {
                                // Wrapper to center the image and control max width
                                const wrapper = document.createElement('div');
                                wrapper.className = 'reader-image-wrapper';
                                wrapper.style.display = 'flex';
                                wrapper.style.justifyContent = 'center';
                                wrapper.style.alignItems = 'center';
                                wrapper.style.margin = '0';
                                wrapper.style.padding = '0';
                                wrapper.style.width = '100%';
                                wrapper.style.overflow = 'hidden';

                                const el = document.createElement('img');
                                el.src = img.url;
                                el.alt = img.name || '';
                                el.loading = 'lazy';
                                el.style.display = 'block';
                                el.style.margin = '0 auto';
                                el.style.padding = '0';
                                // Default max width is taken from wrapper.dataset.baseWidth (smaller by default)
                                el.style.maxWidth = (wrapper.dataset.baseWidth || '450') + 'px';
                                el.style.width = '100%';
                                el.style.height = 'auto';
                                el.style.objectFit = 'contain';
                                el.style.transformOrigin = 'center center';
                                // Use max-width transition so layout reflows and pages remain contiguous
                                el.style.transition = 'max-width 120ms ease';
                                el.dataset.scale = '1';

                                // No wheel/double-click zoom: zoom controlled via buttons in settings.
                                // Initialize base width on wrapper for default image size (smaller default)
                                wrapper.dataset.baseWidth = wrapper.dataset.baseWidth || '450';
                                el.style.maxWidth = (wrapper.dataset.baseWidth || '450') + 'px';

                                wrapper.appendChild(el);
                                readerContent.appendChild(wrapper);
                            }
                            // Once images are rendered, ensure zoom controls exist and current scale applied
                            createReaderZoomControls();
                            applyReaderScale();
                            // Mettre √† jour la progression apr√®s un court d√©lai
                            setTimeout(updateProgress, 200);
                            return;
                        }
                    }
                } catch (e) {
                    console.warn('Erreur chargement dossier de chapitres via API', e);
                }
                // Si √©chec, on retombera sur le comportement MHTML ci-dessous
            }

            // Charger le fichier MHTML et extraire le contenu HTML pour l'afficher (fallback)
            try {
                const response = await fetch(cleanPath);
                if (!response.ok) {
                    throw new Error(`Fichier non trouv√©: ${cleanPath}`);
                }

                const text = await response.text();
                
                // Trouver le boundary
                const boundaryMatch = text.match(/boundary=?([^\"\r\n]+)/i);
                let boundary = '------MultipartBoundary';
                if (boundaryMatch) {
                    boundary = boundaryMatch[1].trim();
                    if (!boundary.startsWith('----')) {
                        boundary = '----' + boundary;
                    }
                }

                // Parser le MHTML pour trouver la partie HTML principale
                const parts = text.split(new RegExp(boundary.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&')));
                let htmlContent = '';

                for (const part of parts) {
                    if (part.includes('Content-Type: text/html') || part.includes('content-type: text/html')) {
                        const headerEndMatch = part.match(/\r?\n\r?\n/);
                        if (headerEndMatch) {
                            const headerEndIndex = headerEndMatch.index + headerEndMatch[0].length;
                            htmlContent = part.substring(headerEndIndex);
                            htmlContent = htmlContent.split(boundary)[0].trim();
                            break;
                        }
                    }
                }

                if (htmlContent) {
                    const iframe = document.createElement('iframe');
                    iframe.style.cssText = 'width: 100%; min-height: 100vh; border: none; background: white;';
                    iframe.sandbox = 'allow-same-origin allow-scripts';
                    iframe.onload = () => {
                        updateProgress();
                        console.log('MHTML HTML charg√© avec succ√®s');
                    };

                    readerContent.innerHTML = '';
                    readerContent.appendChild(iframe);

                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    iframeDoc.open();
                    iframeDoc.write(htmlContent);
                    iframeDoc.close();
                } else {
                    throw new Error('Aucun contenu HTML trouv√© dans le fichier MHTML');
                }

            } catch (error) {
                console.error('Erreur lors du chargement du MHTML:', error);
                readerContent.innerHTML = `
                    <div class="text-center py-12">
                        <p class="text-red-600">Erreur lors du chargement du chapitre</p>
                        <p class="text-gray-500 text-sm mt-2">${error.message}</p>
                        <p class="text-gray-500 text-xs mt-1">Chemin: ${cleanPath}</p>
                    </div>
                `;
            }

            // G√©rer les boutons de navigation
            updateChapterNavigation(manhwaId, chapterNumber);
        }

        // Fonction optimis√©e pour extraire les images d'un MHTML (sans stockage)
        async function extractImagesFromMhtml(mhtmlPath) {
            // Nettoyer le chemin
            let cleanPath = mhtmlPath.replace(/\\/g, '/');
            if (cleanPath.includes('Site/')) {
                cleanPath = cleanPath.split('Site/')[1];
            }
            if (cleanPath.includes('chapitres/') && !cleanPath.startsWith('chapitres/')) {
                cleanPath = cleanPath.substring(cleanPath.indexOf('chapitres/'));
            }
            if (!cleanPath.startsWith('./') && !cleanPath.startsWith('/') && !cleanPath.startsWith('http')) {
                cleanPath = './' + cleanPath;
            }

            // Charger le fichier
            const response = await fetch(cleanPath);
            if (!response.ok) {
                throw new Error(`Fichier non trouv√©: ${cleanPath}`);
            }

            const arrayBuffer = await response.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            // Convertir en texte pour trouver le boundary et parser les headers
            const decoder = new TextDecoder('utf-8', { fatal: false });
            const text = decoder.decode(arrayBuffer);

            // Trouver le boundary dans l'en-t√™te
            const boundaryMatch = text.match(/boundary="?([^"\r\n]+)"?/i);
            let boundary = '------MultipartBoundary';
            if (boundaryMatch) {
                boundary = boundaryMatch[1].trim();
                if (!boundary.startsWith('----')) {
                    boundary = '----' + boundary;
                }
            }

            // Parser le texte pour trouver les sections d'images
            const parts = text.split(new RegExp(boundary.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')));
            const images = [];
            
            // Calculer les offsets de texte pour chaque partie
            let textOffset = 0;
            const partOffsets = [];
            for (let i = 0; i < parts.length; i++) {
                partOffsets.push(textOffset);
                textOffset += parts[i].length;
                if (i > 0) textOffset += boundary.length;
            }

            for (let partIndex = 0; partIndex < parts.length; partIndex++) {
                const part = parts[partIndex];
                const textOffset = partOffsets[partIndex];
                
                // V√©rifier si c'est une image
                const contentTypeMatch = part.match(/[Cc]ontent-[Tt]ype:\s*image\/(jpeg|jpg|png|gif|webp|bmp)/i);
                if (!contentTypeMatch) continue;

                const imageType = contentTypeMatch[1].toLowerCase() === 'jpg' ? 'jpeg' : contentTypeMatch[1].toLowerCase();
                const isBase64 = /[Cc]ontent-[Tt]ransfer-[Ee]ncoding:\s*base64/i.test(part);
                const isBinary = /[Cc]ontent-[Tt]ransfer-[Ee]ncoding:\s*binary/i.test(part);

                // Trouver la fin des headers (double saut de ligne)
                const headerEndMatch = part.match(/\r?\n\r?\n/);
                if (!headerEndMatch) continue;
                
                const headerEndIndex = headerEndMatch.index + headerEndMatch[0].length;
                const dataText = part.substring(headerEndIndex);

                if (isBase64) {
                    // Extraire les donn√©es base64
                    const lines = dataText.split(/\r?\n/);
                    let base64Data = '';
                    for (const line of lines) {
                        const trimmed = line.trim();
                        if (trimmed.startsWith('----')) break;
                        if (trimmed && /^[A-Za-z0-9+/=\s]+$/.test(trimmed)) {
                            base64Data += trimmed.replace(/\s/g, '');
                        }
                    }
                    if (base64Data && base64Data.length > 100) {
                        // Valider que c'est du base64 valide
                        const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
                        if (!base64Regex.test(base64Data)) {
                            console.warn(`Image base64 ${images.length + 1}: donn√©es base64 invalides`);
                            continue;
                        }
                        const dataUrl = `data:image/${imageType};base64,${base64Data}`;
                        console.log(`Image base64 extraite: type=${imageType}, taille=${base64Data.length} chars`);
                        images.push(dataUrl);
                    }
                } else {
                    // Pour les donn√©es binaires, utiliser une m√©thode plus pr√©cise
                    // Trouver le boundary suivant dans le texte pour d√©terminer la fin
                    const nextBoundaryIndex = text.indexOf(boundary, textOffset + part.length);
                    
                    // Calculer les positions dans le fichier binaire
                    // Trouver la position du d√©but de cette partie dans le binaire
                    const partStartInText = textOffset;
                    const partHeaderText = part.substring(0, headerEndIndex);
                    
                    // Chercher le d√©but de cette partie dans le binaire
                    // Utiliser Content-Location ou Content-ID comme marqueur unique
                    const contentLocationMatch = part.match(/[Cc]ontent-[Ll]ocation:\s*([^\r\n]+)/i);
                    const contentIdMatch = part.match(/[Cc]ontent-[Ii][Dd]:\s*<([^>]+)>/i);
                    
                    let binaryPartStart = -1;
                    let headerBytesLength = 0;
                    let searchStart = Math.max(0, Math.floor(textOffset * 0.9)); // Commencer pr√®s de la position attendue
                    
                    if (contentLocationMatch || contentIdMatch) {
                        // Utiliser un header unique pour la recherche
                        const uniqueHeader = contentLocationMatch ? contentLocationMatch[1] : contentIdMatch[1];
                        const headerBytes = new TextEncoder().encode(uniqueHeader);
                        headerBytesLength = headerBytes.length;
                        
                        // Chercher √† partir d'une position approximative
                        for (let pos = searchStart; pos < Math.min(searchStart + 100000, uint8Array.length - headerBytes.length); pos++) {
                            let match = true;
                            for (let k = 0; k < headerBytes.length; k++) {
                                if (uint8Array[pos + k] !== headerBytes[k]) {
                                    match = false;
                                    break;
                                }
                            }
                            if (match) {
                                // Remonter pour trouver le d√©but du boundary
                                for (let back = pos; back >= Math.max(0, pos - 200); back--) {
                                    const testBoundary = decoder.decode(uint8Array.slice(back, back + Math.min(50, uint8Array.length - back)));
                                    if (testBoundary.includes(boundary.substring(0, 20))) {
                                        binaryPartStart = back;
                                        break;
                                    }
                                }
                                if (binaryPartStart !== -1) break;
                            }
                        }
                    }
                    
                    // Fallback: utiliser la position approximative bas√©e sur le texte
                    if (binaryPartStart === -1) {
                        // Estimer la position en supposant que texte et binaire sont align√©s au d√©but
                        binaryPartStart = Math.floor(textOffset);
                        // Calculer la longueur du header en bytes
                        const headerBytes = new TextEncoder().encode(partHeaderText);
                        headerBytesLength = headerBytes.length;
                    }
                    
                    // Trouver la fin des headers (chercher \r\n\r\n ou \n\n)
                    let binaryDataStart = binaryPartStart + headerBytesLength;
                    for (let pos = binaryDataStart - 20; pos < binaryDataStart + 20 && pos < uint8Array.length; pos++) {
                        if (pos >= 0 && uint8Array[pos] === 0x0A && pos + 1 < uint8Array.length && uint8Array[pos + 1] === 0x0A) {
                            binaryDataStart = pos + 2;
                            break;
                        }
                        if (pos >= 1 && uint8Array[pos - 1] === 0x0D && uint8Array[pos] === 0x0A && 
                            pos + 1 < uint8Array.length && uint8Array[pos + 1] === 0x0D && pos + 2 < uint8Array.length && uint8Array[pos + 2] === 0x0A) {
                            binaryDataStart = pos + 3;
                            break;
                        }
                    }
                    
                    // Trouver la fin des donn√©es (chercher le boundary suivant)
                    const boundaryBytes = new TextEncoder().encode(boundary);
                    let binaryDataEnd = uint8Array.length;
                    
                    // Chercher le boundary avec diff√©rents pr√©fixes possibles
                    const prefixes = [
                        new TextEncoder().encode('\r\n' + boundary),
                        new TextEncoder().encode('\n' + boundary),
                        boundaryBytes
                    ];
                    
                    for (const prefixBytes of prefixes) {
                        for (let pos = binaryDataStart; pos < uint8Array.length - prefixBytes.length; pos++) {
                            let match = true;
                            for (let k = 0; k < prefixBytes.length; k++) {
                                if (uint8Array[pos + k] !== prefixBytes[k]) {
                                    match = false;
                                    break;
                                }
                            }
                            if (match) {
                                binaryDataEnd = pos;
                                break;
                            }
                        }
                        if (binaryDataEnd < uint8Array.length) break;
                    }
                    
                    // Extraire les donn√©es binaires
                    if (binaryDataEnd > binaryDataStart && binaryDataEnd <= uint8Array.length) {
                        const binaryData = uint8Array.slice(binaryDataStart, binaryDataEnd);
                        
                        if (binaryData.length >= 100) {
                            // V√©rifier la signature du fichier image
                            let isValidImage = false;
                            if (imageType === 'jpeg' && binaryData[0] === 0xFF && binaryData[1] === 0xD8) {
                                isValidImage = true;
                            } else if (imageType === 'png' && binaryData[0] === 0x89 && binaryData[1] === 0x50 && binaryData[2] === 0x4E && binaryData[3] === 0x47) {
                                isValidImage = true;
                            } else if (imageType === 'gif' && binaryData[0] === 0x47 && binaryData[1] === 0x49 && binaryData[2] === 0x46) {
                                isValidImage = true;
                            } else if (imageType === 'webp' && binaryData[0] === 0x52 && binaryData[1] === 0x49 && binaryData[2] === 0x46 && binaryData[3] === 0x46) {
                                isValidImage = true;
                            } else {
                                // Si la signature ne correspond pas, essayer quand m√™me (peut √™tre un format diff√©rent)
                                isValidImage = true;
                            }
                            
                            if (isValidImage) {
                                // Convertir en base64 par chunks
                                let base64String = '';
                                const chunkSize = 8192;
                                try {
                                    for (let j = 0; j < binaryData.length; j += chunkSize) {
                                        const chunk = binaryData.slice(j, Math.min(j + chunkSize, binaryData.length));
                                        const binaryString = Array.from(chunk, byte => String.fromCharCode(byte)).join('');
                                        base64String += btoa(binaryString);
                                    }
                                    
                            if (base64String && base64String.length > 100) {
                                // Valider que c'est du base64 valide
                                const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
                                if (!base64Regex.test(base64String)) {
                                    console.warn(`Image binaire ${images.length + 1}: base64 invalide apr√®s conversion`);
                                    continue;
                                }
                                const dataUrl = `data:image/${imageType};base64,${base64String}`;
                                console.log(`Image binaire extraite: type=${imageType}, taille=${binaryData.length} bytes, base64 length=${base64String.length}`);
                                images.push(dataUrl);
                            } else {
                                console.warn(`Image ${images.length + 1}: base64 trop court (${base64String ? base64String.length : 0})`);
                            }
                                } catch (error) {
                                    console.error(`Erreur lors de la conversion base64 pour image ${images.length + 1}:`, error);
                                }
                            } else {
                                console.warn(`Image ${images.length + 1} ignor√©e: signature invalide pour type ${imageType} (premiers bytes: ${Array.from(binaryData.slice(0, 4)).map(b => '0x' + b.toString(16)).join(' ')})`);
                            }
                        }
                    }
                }
            }

            console.log(`Total d'images extraites: ${images.length}`);
            return images;
        }

        // Mise √† jour de la navigation des chapitres
        function updateChapterNavigation(manhwaId, chapterNumber) {
            const chapters = allChapters
                .filter(ch => ch.manhwa_id === manhwaId)
                .sort((a, b) => a.chapter_number - b.chapter_number);

            const currentIndex = chapters.findIndex(ch => ch.chapter_number === chapterNumber);
            const prevChapter = chapters[currentIndex - 1];
            const nextChapter = chapters[currentIndex + 1];

            const prevBtn = document.getElementById('prev-chapter');
            const nextBtn = document.getElementById('next-chapter');

            if (prevChapter) {
                prevBtn.disabled = false;
                prevBtn.onclick = () => readChapter(manhwaId, prevChapter.chapter_number);
                prevBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                prevBtn.disabled = true;
                prevBtn.onclick = null;
                prevBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }

            if (nextChapter) {
                nextBtn.disabled = false;
                nextBtn.onclick = () => readChapter(manhwaId, nextChapter.chapter_number);
                nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                nextBtn.disabled = true;
                nextBtn.onclick = null;
                nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        // Gestion des commentaires
        let currentChapterComments = [];
        let commentImagesSelected = [];
        
        function loadComments(manhwaId, chapterNumber) {
            // Charger depuis l'API (MySQL local ou Supabase en ligne)
            (async () => {
                try {
                    const result = await CommentsAPI.getComments(manhwaId, chapterNumber);
                    if (result.success) {
                        // Normaliser les images (stock√©es en DB en tant que JSON string)
                        currentChapterComments = Array.isArray(result.data) ? result.data.map(c => {
                            try {
                                if (c.images && typeof c.images === 'string') c.images = JSON.parse(c.images);
                            } catch (e) { c.images = []; }
                            if (!c.images) c.images = [];
                            return c;
                        }) : [];
                        // Persist locally as a backup so refresh won't lose content if API later fails
                        try { localStorage.setItem(`comments_${manhwaId}_${chapterNumber}`, JSON.stringify(currentChapterComments)); } catch (e) {}
                        updateCommentsDisplay();
                        return;
                    }
                } catch (e) {
                    console.warn('Erreur chargement commentaires API', e);
                }

                // Fallback localStorage
                const saved = localStorage.getItem(`comments_${manhwaId}_${chapterNumber}`);
                if (saved) currentChapterComments = JSON.parse(saved);
                else currentChapterComments = [];
                updateCommentsDisplay();
            })();
        }
        
        function saveComments(manhwaId, chapterNumber) {
            // Enregistrer via API: supprimer toutes les anciennes locales et r√©-POST les commentaires
            (async () => {
                try {
                    // Si l'API est disponible, envoyer chaque commentaire (cr√©ation ou update)
                    for (const c of currentChapterComments) {
                        if (c.id && c.id.startsWith('comment_')) {
                            // nouvel id probable: POST
                            const payload = {
                                id: c.id,
                                manhwa_id: manhwaId,
                                chapter_number: chapterNumber,
                                author: c.author || 'Anonyme',
                                text: c.text,
                                images: c.images || [],
                                date: c.date || new Date().toISOString()
                            };
                            await fetch('api-comments.php', {
                                method: 'POST',
                                headers: {'Content-Type':'application/json'},
                                body: JSON.stringify(payload)
                            });
                        } else if (c.id) {
                            // existing id: PUT
                            await fetch('api-comments.php', {
                                method: 'PUT',
                                headers: {'Content-Type':'application/json'},
                                body: JSON.stringify(c)
                            });
                        }
                    }
                    // After attempting to sync with API, persist a local backup so refresh keeps comments
                    try { localStorage.setItem(`comments_${manhwaId}_${chapterNumber}`, JSON.stringify(currentChapterComments)); } catch (e) {}
                } catch (e) {
                    console.warn('saveComments API error', e);
                    // Fallback: sauvegarde locale
                    try { localStorage.setItem(`comments_${manhwaId}_${chapterNumber}`, JSON.stringify(currentChapterComments)); } catch (e) {}
                }
            })();
        }
        
        function updateCommentsDisplay() {
            const commentsList = document.getElementById('comments-list');
            if (!commentsList) return;
            
            commentsList.innerHTML = '';
            
            const searchTerm = (document.getElementById('comment-search')?.value || '').toLowerCase();
            const filterValue = document.getElementById('comment-filter')?.value || 'all';
            
            let filtered = [...currentChapterComments];
            
            // Recherche
            if (searchTerm) {
                filtered = filtered.filter(comment => 
                    comment.text.toLowerCase().includes(searchTerm) ||
                    comment.author?.toLowerCase().includes(searchTerm)
                );
            }
            
            // Filtrage
            if (filterValue === 'recent') {
                filtered.sort((a, b) => new Date(b.date) - new Date(a.date));
            } else if (filterValue === 'oldest') {
                filtered.sort((a, b) => new Date(a.date) - new Date(b.date));
            }
            
            if (filtered.length === 0) {
                commentsList.innerHTML = `
                    <div class="text-center py-8 text-gray-600 dark-mode:text-gray-300">
                        ${currentChapterComments.length === 0 ? 'Aucun commentaire pour le moment' : 'Aucun r√©sultat trouv√©'}
                    </div>
                `;
                return;
            }
            
            filtered.forEach(comment => {
                const item = document.createElement('div');
                // Use comment-card class so it follows the same theme as settings panel
                item.className = 'comment-card';
                item.innerHTML = `
                    <div class="flex items-start justify-between mb-2">
                        <div>
                            <p class="font-semibold text-gray-900 dark-mode:text-indigo-200">${comment.author || 'Anonyme'}</p>
                            <p class="text-xs text-gray-500 dark-mode:text-gray-300">${formatDate(comment.date)}</p>
                        </div>
                        <button onclick="deleteComment('${comment.id}')" class="text-red-500 hover:text-red-700 text-sm">Supprimer</button>
                    </div>
                    <p class="text-gray-800 dark-mode:text-gray-100 mb-3 whitespace-pre-wrap">${comment.text}</p>
                    ${comment.images && comment.images.length > 0 ? `
                        <div class="flex flex-wrap gap-2 mb-2">
                            ${comment.images.map(img => `
                                <img src="${img}" alt="Comment image" class="w-24 h-24 object-contain rounded-lg cursor-pointer" onclick="window.open('${img}', '_blank')">
                            `).join('')}
                        </div>
                    ` : ''}
                `;
                commentsList.appendChild(item);
            });
        }
        
        window.openGalleryForComment = function() {
            // Ouvrir un modal pour s√©lectionner des images de la galerie
            const modal = document.createElement('div');
            modal.id = 'gallery-select-modal';
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark-mode:bg-gray-800 rounded-xl shadow-2xl max-w-4xl w-full mx-4 max-h-[80vh] overflow-y-auto p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-gray-900 dark-mode:text-gray-100">S√©lectionner des images</h3>
                        <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600">‚úï</button>
                    </div>
                    <div class="grid grid-cols-4 gap-4" id="gallery-select-grid"></div>
                    <div class="mt-4 flex justify-end">
                        <button onclick="confirmGallerySelection()" class="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">Confirmer</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            const grid = modal.querySelector('#gallery-select-grid');
            galleryImages.forEach((img, index) => {
                const item = document.createElement('div');
                item.className = 'relative cursor-pointer';
                item.innerHTML = `
                    <img src="${img.path}" alt="${img.name}" class="w-full h-32 object-contain bg-gray-100 rounded-lg">
                    <input type="checkbox" class="absolute top-2 right-2" data-image-path="${img.path}">
                `;
                grid.appendChild(item);
            });
        };
        
        window.confirmGallerySelection = function() {
            const checkboxes = document.querySelectorAll('#gallery-select-grid input[type="checkbox"]:checked');
            commentImagesSelected = Array.from(checkboxes).map(cb => cb.dataset.imagePath);
            
            // Afficher les images s√©lectionn√©es
            const preview = document.getElementById('comment-images-preview');
            preview.innerHTML = commentImagesSelected.map(img => `
                <img src="${img}" alt="Selected" class="w-16 h-16 object-cover rounded-lg">
            `).join('');
            
            const modal = document.getElementById('gallery-select-modal');
            if (modal) modal.remove();
        };
        
        window.addComment = function() {
            const text = document.getElementById('comment-text').value.trim();
            if (!text && commentImagesSelected.length === 0) {
                showNotification('Veuillez entrer un commentaire ou ajouter une image', 'error');
                return;
            }
            const comment = {
                id: 'comment_' + Date.now() + '_' + Math.random(),
                text: text,
                images: [...commentImagesSelected],
                author: 'Vous',
                date: new Date().toISOString()
            };

            // Envoyer au serveur (MySQL local ou Supabase)
            (async () => {
                try {
                    const resp = await CommentsAPI.addComment({
                        id: comment.id,
                        manhwa_id: currentManhwaId,
                        chapter_number: currentChapterNumber,
                        author: comment.author,
                        text: comment.text,
                        images: comment.images,
                        date: comment.date
                    });
                    
                    if (resp.success) {
                        // recharger
                        await loadComments(currentManhwaId, currentChapterNumber);
                        showNotification('Commentaire ajout√©!', 'success');
                    } else {
                        // fallback local
                        currentChapterComments.push(comment);
                        saveComments(currentManhwaId, currentChapterNumber);
                        updateCommentsDisplay();
                        showNotification('Commentaire sauvegard√© localement (erreur serveur)', 'warning');
                    }
                } catch (e) {
                    currentChapterComments.push(comment);
                    saveComments(currentManhwaId, currentChapterNumber);
                    updateCommentsDisplay();
                    showNotification('Commentaire sauvegard√© localement (erreur r√©seau)', 'warning');
                }
            })();

            // R√©initialiser l'UI imm√©diatement
            document.getElementById('comment-text').value = '';
            commentImagesSelected = [];
            document.getElementById('comment-images-preview').innerHTML = '';
        };
        
        window.deleteComment = function(commentId) {
            (async () => {
                try {
                    const resp = await CommentsAPI.deleteComment(commentId);
                    if (resp.success) {
                        await loadComments(currentManhwaId, currentChapterNumber);
                        showNotification('Commentaire supprim√©', 'success');
                        return;
                    }
                } catch (e) {
                    console.warn('deleteComment API error', e);
                }

                // Fallback local
                currentChapterComments = currentChapterComments.filter(c => c.id !== commentId);
                saveComments(currentManhwaId, currentChapterNumber);
                updateCommentsDisplay();
                showNotification('Commentaire supprim√© localement', 'success');
            })();
        };
        
        window.openEmojiPicker = function() {
            // Expanded emoji set (smileys, people, animals, food, flags, objects)
            const emojis = [
                'üòÄ','üòÉ','üòÑ','üòÅ','üòÜ','üòÖ','ü§£','üòÇ','üôÇ','üôÉ','üòâ','üòä','üòá','ü•∞','üòç','ü§©','üòò','üòó','üòö','üòô','üòã','üòõ','üòú','ü§™','üòù','ü§ë','ü§ó','ü§≠','ü§´','ü§î','ü§ê','ü§®','üòê','üòë','üò∂','üòè','üòí','üôÑ','üò¨','ü§•','üòå','üòî','üò™','ü§§','üò¥','üò∑','ü§í','ü§ï','ü§¢','ü§Æ','ü§ß','ü•µ','ü•∂','üòµ','ü§Ø','ü§†','ü•≥','üòé','ü§ì','üßê',
                // animals
                'üê∂','üê±','üê≠','üêπ','üê∞','ü¶ä','üêª','üêº','üê®','üêØ','ü¶Å','üêÆ','üê∑','üê∏','üêµ','üêî','üêß','üê¶','üê§','ü¶Ü','ü¶â','ü¶á','üê∫','ü¶Ñ','üê¥','üêó',
                // food
                'üçè','üçé','üçê','üçä','üçã','üçå','üçâ','üçá','üçì','üçà','üçí','üçë','ü•≠','ü••','ü•ù','üçÖ','üçÜ','ü•ë','ü•¶','ü•ï','üåΩ','ü•î','üç†','ü•ê','üçû','üßÄ','üçó','üçñ','üç§','üç£','üçú','üçï','üçî','üçü',
                // objects
                '‚öΩ','üèÄ','üèà','üéæ','üé≤','üéÆ','üéß','üé§','üé¨','üì∑','üì±','üíª','‚åö','üîë','üïØÔ∏è','üí°','üìö','‚úèÔ∏è','üñäÔ∏è',
                // flags (a few common ones)
                'üá´üá∑','üá∫üá∏','üá¨üáß','üáØüáµ','üá∞üá∑','üá®üá≥','üá™üá∏','üáÆüáπ','üá©üá™','üá∑üá∫','üáßüá∑','üáÆüá≥',
                // misc
                '‚ù§Ô∏è','üß°','üíõ','üíö','üíô','üíú','üñ§','ü§ç','ü§é','üëç','üëé','üëè','üôè','üí™','‚úåÔ∏è','ü§ù'
            ];
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark-mode:bg-gray-800 rounded-xl shadow-2xl max-w-md w-full mx-4 p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-gray-900 dark-mode:text-gray-100">Choisir un emoji</h3>
                        <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600">‚úï</button>
                    </div>
                    <div class="grid grid-cols-8 gap-2 max-h-64 overflow-y-auto">
                        ${emojis.map(emoji => `
                            <button onclick="insertEmoji('${emoji}')" class="text-2xl hover:bg-gray-100 dark-mode:hover:bg-gray-700 rounded p-2">${emoji}</button>
                        `).join('')}
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        };
        
        window.insertEmoji = function(emoji) {
            const textarea = document.getElementById('comment-text');
            const cursorPos = textarea.selectionStart;
            const textBefore = textarea.value.substring(0, cursorPos);
            const textAfter = textarea.value.substring(cursorPos);
            textarea.value = textBefore + emoji + textAfter;
            textarea.selectionStart = textarea.selectionEnd = cursorPos + emoji.length;
            textarea.focus();
            document.querySelector('.fixed').remove();
        };
        
        // Event listeners pour la recherche et le filtrage des commentaires
        const commentSearch = document.getElementById('comment-search');
        const commentFilter = document.getElementById('comment-filter');
        
        if (commentSearch) {
            commentSearch.addEventListener('input', () => updateCommentsDisplay());
        }
        if (commentFilter) {
            commentFilter.addEventListener('change', () => updateCommentsDisplay());
        }

        // Mise √† jour de la progression de lecture
        function updateProgress() {
            const readerContent = document.getElementById('reader-content');
            const images = readerContent.querySelectorAll('img');
            let loadedImages = 0;

            images.forEach(img => {
                if (img.complete && img.naturalHeight !== 0) {
                    loadedImages++;
                }
            });

            const progress = (loadedImages / images.length) * 100;
            document.getElementById('reading-progress').style.width = progress + '%';
        }

        // Attendre que les donn√©es soient charg√©es (allChapters) - utile au d√©marrage
        function ensureDataLoaded(timeoutMs = 2000) {
            return new Promise((resolve) => {
                const start = Date.now();
                (function waitForData() {
                    if (Array.isArray(allChapters) && allChapters.length >= 0) {
                        // Consider loaded when SDK init finished (we rely on init to populate arrays)
                        resolve(true);
                        return;
                    }
                    if (Date.now() - start > timeoutMs) {
                        resolve(false);
                        return;
                    }
                    setTimeout(waitForData, 100);
                })();
            });
        }

        // Supprimer un chapitre
        // Fonction pour r√©organiser les manhwas (drag & drop)
        async function reorderManhwas(draggedId, targetId) {
            // Permettre le r√©ordonnancement m√™me en ligne (pour l'affichage seulement)
            
            const draggedIndex = allManhwas.findIndex(m => m.__backendId === draggedId);
            const targetIndex = allManhwas.findIndex(m => m.__backendId === targetId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            // R√©organiser dans le tableau
            const [draggedItem] = allManhwas.splice(draggedIndex, 1);
            allManhwas.splice(targetIndex, 0, draggedItem);
            
            // Mettre √† jour l'ordre :
            // - en mode d√©veloppeur : sauvegarde globale (data.php)
            // - en ligne (utilisateur) : sauvegarder l'ordre dans localStorage propre √† l'utilisateur
            if (isDeveloperMode()) {
                globalData = globalData.filter(item => 
                    !item.manhwa_id || item.chapter_number || item.type === 'tracking' || item.type === 'trash'
                );
                
                allManhwas.forEach((manhwa, idx) => {
                    // annoter order_index pour les sauvegardes futures
                    manhwa.order_index = idx;
                    const existing = globalData.find(item => item.__backendId === manhwa.__backendId);
                    if (existing) {
                        globalData.push(existing);
                    }
                });
                
                // Sauvegarder
                scheduleAutoSave(globalData);
            } else {
                // Mode en ligne : sauver l'ordre par utilisateur en localStorage (pr√™t pour envoi serveur si besoin)
                const userId = getCurrentUserId();
                const order = allManhwas.map((m, idx) => ({ id: m.manhwa_id || m.__backendId, order_index: idx }));
                try {
                    localStorage.setItem(`manhwa_order_${userId}`, JSON.stringify(order));
                } catch (e) {
                    console.warn('Impossible de sauvegarder l\'ordre utilisateur dans localStorage', e);
                }
            }
            updateLibraryPage();
            showNotification('Ordre mis √† jour', 'success');
        }
        
        // Fonction pour r√©organiser les suivis (drag & drop)
        async function reorderTracking(draggedId, targetId) {
            const draggedIndex = trackingList.findIndex(t => t.id === draggedId);
            const targetIndex = trackingList.findIndex(t => t.id === targetId);
            
            if (draggedIndex === -1 || targetIndex === -1) return;
            
            // R√©organiser dans le tableau
            const [draggedItem] = trackingList.splice(draggedIndex, 1);
            trackingList.splice(targetIndex, 0, draggedItem);
            
            // Sauvegarder
            await saveTrackingList();
            updateTrackingPage();
            showNotification('Ordre mis √† jour', 'success');
        }
        
        // Fonction pour ajouter √† la corbeille
        async function addToTrash(item, itemType) {
            const trashItem = {
                type: 'trash',
                trash_type: itemType, // 'manhwa', 'chapter', 'tracking'
                original_data: item,
                deleted_at: new Date().toISOString(),
                id: 'trash_' + Date.now() + '_' + Math.random()
            };
            
            globalData.push(trashItem);
            
            if (isDeveloperMode()) {
                scheduleAutoSave(globalData);
            } else {
                await saveDataToFileAuto(globalData);
            }
        }
        
        async function deleteChapter(chapterId) {
            // V√©rifier le mode d√©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }
            
            const chapter = allChapters.find(ch => ch.__backendId === chapterId);
            if (!chapter) return;

            const confirmed = await showConfirmDialog(
                `Supprimer le chapitre ${chapter.chapter_number}?`,
                'Le chapitre sera d√©plac√© dans la corbeille.'
            );

            if (!confirmed) return;

            // Ajouter √† la corbeille AVANT de supprimer
            await addToTrash(chapter, 'chapter');

            // Supprimer imm√©diatement de la liste locale pour mise √† jour instantan√©e
            allChapters = allChapters.filter(ch => ch.__backendId !== chapterId);
            
            // Mettre √† jour IMM√âDIATEMENT toutes les pages AVANT la sauvegarde
            updateAllPages();
            
            // Supprimer via SDK (sauvegarde en arri√®re-plan)
            const result = await window.dataSdk.delete(chapter);

            if (result.isOk) {
                // Supprimer aussi les commentaires associ√©s c√¥t√© serveur
                try {
                    await CommentsAPI.deleteComment(null, chapter.manhwa_id, chapter.chapter_number);
                } catch (e) {
                    console.warn('Erreur suppression commentaires associ√©s (chapter)', e);
                }

                showNotification('Chapitre d√©plac√© dans la corbeille', 'success');
            } else {
                // Restaurer si erreur
                allChapters.push(chapter);
                showNotification('Erreur lors de la suppression', 'error');
                updateAllPages();
            }
        }

        // Supprimer un manhwa
        async function deleteManhwa(manhwaId) {
            // V√©rifier le mode d√©veloppeur
            if (!isDeveloperMode()) {
                showDeveloperModeRequired();
                return;
            }
            
            const manhwa = allManhwas.find(m => m.__backendId === manhwaId);
            if (!manhwa) return;

            const chapters = allChapters.filter(ch => ch.manhwa_id === manhwa.manhwa_id);
            
            const confirmed = await showConfirmDialog(
                `Supprimer "${manhwa.manhwa_title}"?`,
                `Cette action d√©placera aussi les ${chapters.length} chapitres associ√©s dans la corbeille.`
            );

            if (!confirmed) return;

            // Ajouter √† la corbeille
            await addToTrash(manhwa, 'manhwa');
            for (const chapter of chapters) {
                await addToTrash(chapter, 'chapter');
            }

            // Supprimer d'abord tous les chapitres
            for (const chapter of chapters) {
                await window.dataSdk.delete(chapter);
            }

            // Puis supprimer le manhwa
            const result = await window.dataSdk.delete(manhwa);
            
            if (result.isOk) {
                // Supprimer aussi tous les commentaires li√©s √† ce manhwa
                try {
                    await CommentsAPI.deleteComment(null, manhwa.manhwa_id);
                } catch (e) {
                    console.warn('Erreur suppression commentaires associ√©s (manhwa)', e);
                }

                showNotification('Manhwa d√©plac√© dans la corbeille', 'success');
                updateAllPages();
                showPage('library');
            } else {
                showNotification('Erreur lors de la suppression', 'error');
            }
        }

        // Exposer certaines fonctions au scope global pour les handlers inline (script type="module")
        window.openEditManhwaModal = openEditManhwaModal;
        window.openEditChapterModal = openEditChapterModal;
        window.openAddManhwaModal = openAddManhwaModal;
        window.openAddChapterModal = openAddChapterModal;
        window.deleteManhwa = deleteManhwa;
        window.deleteChapter = deleteChapter;
        window.readChapter = readChapter; // exposer readChapter pour les onclick inline
        // Exposer la fonction de lecture (utilis√©e dans les onclick inline)
        window.readChapter = readChapter;

        // Dialog de confirmation (sans alert!)
        function showConfirmDialog(title, message) {
            return new Promise((resolve) => {
                const dialog = document.createElement('div');
                dialog.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                dialog.innerHTML = `
                    <div class="bg-white rounded-xl shadow-2xl max-w-md mx-4 p-6">
                        <h3 class="text-xl font-bold mb-2">${title}</h3>
                        <p class="text-gray-600 mb-6">${message}</p>
                        <div class="flex justify-end space-x-3">
                            <button id="cancel-confirm" class="px-4 py-2 border rounded-lg hover:bg-gray-100">
                                Annuler
                            </button>
                            <button id="ok-confirm" class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700">
                                Supprimer
                            </button>
                        </div>
                    </div>
                `;
                document.body.appendChild(dialog);

                dialog.querySelector('#cancel-confirm').onclick = () => {
                    dialog.remove();
                    resolve(false);
                };

                dialog.querySelector('#ok-confirm').onclick = () => {
                    dialog.remove();
                    resolve(true);
                };
            });
        }

        // Retour au d√©tail depuis le lecteur
        document.getElementById('back-to-detail').addEventListener('click', () => {
            if (currentManhwaId) {
                showManhwaDetail(currentManhwaId);
            } else {
                showPage('home');
            }
        });

        // Fonction utilitaire pour formater les dates
        function formatDate(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffTime = Math.abs(now - date);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            if (diffDays === 0 || diffDays === 1) return "Aujourd'hui";
            if (diffDays === 2) return "Hier";
            if (diffDays < 7) return `Il y a ${diffDays} jours`;
            if (diffDays < 30) return `Il y a ${Math.floor(diffDays / 7)} semaines`;
            return date.toLocaleDateString('fr-FR');
        }

        // Syst√®me de notification
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `fixed top-20 right-4 px-6 py-3 rounded-lg shadow-lg z-50 ${
                type === 'success' ? 'bg-green-500' : 
                type === 'error' ? 'bg-red-500' : 
                'bg-blue-500'
            } text-white font-medium`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Initialiser l'application
        window.addEventListener('DOMContentLoaded', () => {
            initializeApp();
        });
    </script>
    
</body>
</html>